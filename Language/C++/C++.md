

[TOC]

------



# 第一章  为什么会有C++这门语言

## 1.1.0章节概要

**1.1.1.朱老师C++课程整体介绍**

  本节整体介绍C++课程的内容规划，C++课程的前导课程和后续相关拓展的课程。

**1.1.2.为什么有了C还需要C++**

  本节讲C++和C的区别和联系，让大家理解为什么学了C之后还要继续学习C++。

**1.1.3.C++究竟是个怎样的语言**

  本节从一些宏观角度讲解C语言的特征，力求让大家对C++有个直观轮廓性的认识。

**1.1.4.C++的典型项目和优势领域**

  本节介绍几个C++写的典型项目，并且分析下C++的优势应用领域。 

**1.1.5.C++程序员发展前景分析**

  本节帮大家分析C++语言以及C++程序员的当下及未来发展前景。



## 1.1.1.朱老师C++课程整体介绍

### 1.1.1.1、为什么要讲C++

​	(1)C++很重要, C/C++不分家，面试开发都需要。

​	(2)为继续学习opencv、qt（图形界面）、android（中间层）等打基础。

​	(3)基于C高级，进一步提升自己大脑复杂度，建立面向对象和泛型等概念。



### 1.1.1.2、整套课程规划

​	(1)全套C++课程共分为5部分

​	(2)C++课程聚焦于C++语言及其标准库本身，而不延伸到C++的行业应用

​	(3)课程并非零基础，而是基于《嵌入式linux核心课程》的第4部分C语言高级专题



### 1.1.1.3、课程特点和录制风格

​	(1)系列课程，注重：全、深、实、透

​	(2)讲解和练习结合，用实战结果说话，注重理解和运用而不是记忆

​	(3)随堂写代码，现场调试

​	(4)单节10-30分钟，不再强调单节时长，短了就短了



### 1.1.1.4、相关课程和拓展课程

​	(1)前置基础：C高级专题     

​	(2)同级扩展：《朱有鹏老师热门编程语言全解》里的其他语言

​	(3)横向拓展：《朱有鹏老师数据结构与算法全解》中C++实现部分

​	(4)后置拓展：《朱有鹏老师GUI与HMI专题》中的QT和其他

​	(5)后置拓展：《朱有鹏老师opencv和AI人工智能专题》中的opencv等



### 1.1.1.5、学习成本和收益

​	(1)理念：任何学习都是一场投资，投资的关键是投入产出比

​	(2)投入：时间150+小时，成本人民币1000元左右（预售期有折扣）

​	(3)产出1：C++和面向对象技能提升，面试优势，继续学习qt和opencv等的基础

​	(4)产出2：大脑复杂度进一步增加，进一步培养架构思想，深挖个人潜力

 

## 1.1.2.为什么有了C还需要C++

### 1.1.2.1、C++是由C进化而来

​	(1)C++最早叫：带类的C，最开始只是在C上扩展了class等少量特性，后来不停发展；

​	(2)C++比C语法上复杂很多，语言特性多很多，用好C++比用好C要难；

​	(3)C++和C面向的场景不同。C更多是OS内核、底层硬件驱动等，C++是功能中间层；



### 1.1.2.2、C++为什么没有完全取代C

​	(1)C语言有大量成熟代码和成熟开发者，历史优势大；

​	(2)C++的编译器效率比C编译器低；

​	(3)C在很多场景下完全够用，没必要用C++，譬如MCU软件开发；



### 1.1.2.3、C++并不是为了取代C

​	(1)C++并不是“更好的C”，而是基于C的另一种编程语言和周边生态；

​	(2)C和C++都能很好的操作硬件，因为他们都支持指针；

​	(3)C更适合小规模控制型程序，而C++更适合大规模结构性逻辑型程序；

​	(4)C++的出现不是C推动的，而是硬件性能增强和软件要解决的功能复杂性提升推动的；

  

## 1.1.3.C++究竟是个怎样的语言

### 1.1.3.1、C++是面向对象的

​	(1)C++与C最大的不同就是面向对象；

​	(2)C++并不是纯面向对象语言；C++保留了许多C的特性，所以C++不完全是面向对象的；



### 1.1.3.2、C++兼容C语言的全部特性

​	(1)C++有指针，所以很方便直接操作硬件；

​	(2)C++是编译性语言，最终得到可执行程序是**架构相关**的二进制机器码；

​	(3)C++在语法和编程风格上和C非常类似；

​	(4)C++代码也分头文件和代码文件，只是后缀名和C有不同；

​	(5)C++比C扩展了很多特性，譬如泛型、引用等；



### 1.1.3.3、C++比C更适合复杂项目

​	(1)linux kernel如果改用C++写会更容易写，也更容易看懂；

​	(2)C++的语法很复杂，学习难度比C和java都要大；

​	(3)C++没有GC机制，对象创建和销毁要程序员管理，因此容易出错 (没有内存回收机制)；

​	(4)总结：C++适合**高手**使用在**强调性能**的**复杂**项目中；

 

## 1.1.4.C++的典型项目和优势领域

### 1.1.4.1、C++典型项目

​	(1)qt库及qtcreator （IDE）本身就那qt开发的；

​	(2)opencv（视觉）、opengl（显卡）、directX（显卡）；

​	(3)Windows和Office；

​	(4)Android中间层；



### 1.1.4.2、C++的劣势和优势分析

​	(1)C++比C更适合开发规模大、业务复杂的大型项目；

​	(2)C++比Java、python更适合开发在意性能的大型项目；

​	(3)C++适合开发后台业务逻辑而不是前台界面；

​	(4)C++当前最优势领域有：视觉和AI分析，游戏和图像引擎，网络服务引擎等；



## 1.1.5.C++程序员发展前景分析

### 1.1.5.1、C++程序员的不一样之处

​	(1)能做得下去的C++程序员工资都不低，不管做哪个方向；

​	(2)C++学习难度大，通过率极低；

​	(3)C++程序员生命周期长，中年危机不明显；

​	(4)相较java和python，C++程序员核心技能几乎不变化，更舒服；

​	(5)相较java和python，C++程序员需求量要少，但是高手一直稀缺；



### 1.1.5.2、C++在当前及以后的江湖地位

​	(1)理念：语言没有好坏之分，不同场景适合不同语言，活下来的主流语言都有过人之处

​	(2)云计算和边缘计算技术大发展，未来的软件运行场景分三种：

​		云平台：没有c++；

​		瘦客户端：MCU主要用C；

​		富客户端；个人手机，个人电脑，车载中控，在中间层用C++；

​	(3)云端开发分前后台，前台用html等，后台用java php python等，还有些全栈的； 

​	(4)瘦客户端用C为主，还有少量非主流用js、micropython、lua等；

​	(5)富客户端不管OS层和HMI层用什么，主体中间层肯定是C++最有优势；

# 第二章 C++开发环境搭建

## 1.2.0章节概要

**1.2.1.如何选择合适的开发环境**

  本节讲开发环境的主要要素，以及选择合适的开发环境的策略和考虑点。

**1.2.2.常用C++开发环境介绍**

  本节讲解当前主流的各种C++开发环境，最后告诉大家本课程使用哪种环境以及原因。

**1.2.3.Linux命令行下C++编程初体验**

  本节在虚拟机ubuntu下使用命令行工具来编译简单C++项目，这种是最简单纯粹的开发方式

**1.2.4.Linux下使用cmake管理C++工程**

  本节介绍了cmake工具，并手把手讲了如何使用cmake管理C++工程并编译。

**1.2.5.Windows下qtcreator安装和使用**

  本节讲了如何在windows系统下安装qtcreator软件并选择合适Kits组件。

**1.2.6.使用qtcreator开发纯C++项目**

  本节讲了在windows下qtcreator中使用qmake和cmake这2种方式来构建项目并编译调试。

**1.2.7.Linux下qtcreator安装和使用**

  本节讲了如何在linux下安装qtcreator并且使用qmake和cmake来开发C++项目。



## 1.2.1.如何选择合适的开发环境

### 1.2.1.1、开发环境要素

​	(1)编辑器 

​		notepad++

​		vscode

​	(2)编译器 

​		MSVC:

​			微软 MicroSoft visual C/C++

​		 MinGW:

​			windows化的GNU GNU(gcc g++)：

​		Linux底下的 其他类别

​			Clang, LLVM , 苹果底下用得比较多；

​	(3)辅助（调试器、反编译、代码提示与补全等）；



### 1.2.1.2、选择IDE的考量因素

​	(1)是否能用（满足需求），是否可用（能拿到），是否好用（顺手舒服）

​	(2)是否可跨平台

​	(3)是否需要版权和付费

​	(4)目标项目是大项目还是小项目



### 1.2.1.3、选择IDE的策略

​	(1)学习时，选最主流的，其他的最好也试试用一下体验体验

​	(2)工作时，随公司项目组

​	(3)项目规划时，根据公司惯例和项目情况、团队情况综合决策



## 1.2.2.常用C++开发环境介绍

### 1.2.2.1、命令行CommandLine

​	(1)Linux命令行：GNU g++ + Makefile/CMake 

​	(2)Windows命令行：MinGW



### 1.2.2.2、不建议使用的老旧IDE

​	(1)VC++6.0

​	(2)DevC++



### 1.2.2.3、市面主流可选C++开发IDE

​	(1)CodeBlocks        小巧、开源免费、跨平台，初学可试试

​	(2)eclipse + CDT + MinGW  推荐本来就熟悉eclipse的人偶尔开发C++使用

​	(3)VisualStudio201X    庞大、好用、不跨平台，推荐Windows上做大项目使用

​	(4)QtCreator        中等、开源免费、跨平台，推荐嵌入式开发者首选

​	(5)VSCode         扩展性强、漂亮好用、跨平台，推荐web开发者做C++    



### 1.2.2.4、对开发环境的正确心态

​	(1)不要执着于新版本，也不要执迷于很多年前的老东西

​	(2)没有最好，甚至没有最适合，工具而已，够用即可

​	(3)不要产生过度依赖，实际开发中可能会需要切换



### 1.2.2.5、本课程开发环境选择

​	(1)前期简单程序Linux命令行

​	(2)后期复杂程序Windows qtcreator

​	(3)需要开发板运行Linux qtcreator交叉编译

 

## 1.2.3.Linux命令行下C++编程初体验

### 1.2.3.1、源码编辑

​	(1)vim或gedit等

​	(2)共享文件夹或samba服务器，到windows下编辑



### 1.2.3.2、编译器基本使用

​	(1)g++ -v查看C++编译器版本号

​	(2)-std=c++xx指定编译时使用的C++标准

​	  列: g++ hello.c -std=c++11

​	(3)简单文件直接编译，复杂项目用makefile管理



### 1.2.3.3、编译和运行C++程序

​	(1)g++ hello.cpp -o hello

​	(2)写Makefile编译C++程序

 

## 1.2.4.Linux下使用cmake管理C++工程

### 1.2.4.1、cmake介绍

### 1.2.4.2、cmake安装

​	(1)https://cmake.org/download/下载源码

​	(2)解压编译安装



### 1.2.4.3、cmake初步使用

(1)安装cmake

​		进入解压得文件夹下执行：

```shell
./bootstrap
#安装出错：缺少openssl库， 下载安装opensslku
#继续执行
./bootstrap
#然后, 需要加sudo, 不然可能因为没有权限失败
sudo make install   
```



(2)创建文件名为：CMakeLists.txt

```shell
touch CMakeLists.txt
```

​	

(3)内容示例：

```cmake
CMAKE_MINIMUM_REQUIRED(VERSION 2.8)      		#最低版本要求
SET(CMAKE_CXX_COMPILER "g++")         			#设置g++编译器
PROJECT(Hello)                				    #设置工程名
MESSAGE(STATUS "test project hello world")       #打印消息
ADD_EXECUTABLE(hello hello.cpp)                  #生成可执行文件
```

(4)执行：

```shell
cmake CMakeLists.txt
```

就会自动生成Makefile；



## 1.2.5.Windows下qtcreator安装和使用

### 1.2.5.1、qtcreator安装

​	(1)qtcreator是专为qt开发而生的，但本身也是个独立的IDE

​	(2)qtcreator可以开发qt gui项目，也可以开发非qt的纯C++项目

​	(3)qtcreator完整运行需要Kits（构建套件），包括编译器、调试器、工程管理器等

​	(4)基于qtcreator的搭建可以独立搭建，也可以整体一次性搭建



### 1.2.5.2、整体搭建qtcreator开发环境

(1)下载：http://download.qt.io/official_releases

(2)安装，注意选择合适控件

 	qtcreator 这个只是个IDE，没有各种构建套件；

​	 qt 这个包含各种构建套件，我们需要用这个；



## 1.2.6.使用qtcreator开发纯C++项目

### 1.2.6.1、基于qmake

(1)创建非qt的C++项目

(2)工程管理选择qmake

(3)构建套件根据需要选择

(4)工程创建后直接编译、运行



### 1.2.6.2、qtcreator基本使用

(1)编译程序

(2)查看编译信息

(3)运行程序并查看运行信息

(4)调试程序



### 1.2.6.3、基于cmake

(1)下载并安装cmake

(2)创建cmake管理的程序

(3)编译运行测试

 

## 1.2.7.Linux下qtcreator安装和使用

### 1.2.7.1、安装linux下qt

环境：ubuntu16.04 X64的

### 1.2.7.2、创建工程并测试



# 第三章 C++基本编程体验

## 1.3.0 章节概要

**1.3.1.何为命名空间**
	本节引入命名空间的概念并且由此引入了语言特性的概念。

**1.3.2.namespace的初级定义和使用**
	本节讲了namespace的定义方法和三种使用方法，这些是C++命名空间的基础运用技巧。

**1.3.3.C++默认命名空间**
	本节重点讲了如何跨文件声明命名空间以及C++的默认/全局命令空间。

**1.3.4.C++匿名命名空间**
	本节主要讲匿名命名空间及其主要用途。

**1.3.5.嵌套命名空间**
	本节讲解C++中如何定义嵌套命名空间以及如何在内外部来引用。

**1.3.6.C++标准库介绍**
	本节介绍C++标准库的来源和概念、学习方法以及重要性。

**1.3.7.iostream的cout使用1**
	本节讲解C++标准库中的iostream的cout，主要是如何输出信息到标准输出。

**1.3.8.iostream的cout使用2**
	本节接上节继续讲解cout的使用技巧并且编程实战。

**1.3.9.iostream的cin使用**
	本节讲解C++标准库中的iostream的cin，并且编程实战cin做命令行交互。

**1.3.10.C++用fstream读写文件**
	本节讲解C++标准库的stream类及其常用方法。

**1.3.11.fstream读写文件编程实战**
	本节使用fstream类的方法手把手写代码来进行文件的创建和读写实验。

**1.3.12.C++字符串string类使用**
	本节讲解string类的常用方法，并且实际写了代码来演示和验证。

**1.3.13.C与C++混合编程1**
	本节分析C和C++混合编程的场景、原因、根本原理并通过反汇编手段来验证

**1.3.14.C与C++混合编程2**
	本节通过手写代码来实战演示C和C++混合编程中C++调用C库的情况。

**1.3.15.C调用C++库的方法**
	本节手写代码并实战演示C和C++混合编程中C调用C++库的情况。



## 1.3.1.何为命名空间

### 1.3.1.1、命名空间的引入

​	(1)命名空间namespace，是C++引入的一种解决全局变量和函数名冲突的机制;

​		在C语言中全局变量或者函数名相同会冲突；

​	(2)C语言没有namespace，但是C++及之后的java python等都有;

​	(3)namespace的关键点有2个：

​		(1)如何解决名称冲突;

​		(2)如何合法访问变量;

### 1.3.1.2、C语言如何解决名称冲突

​	(1)大项目中会有很多C文件，全局变量和函数都是extern链接属性，因此名称冲突是客观存在;

​	(2)一个项目是一个单体程序，项目中的全局变量和函数理应能互相访问，因此名称冲突是客观存在;

​	(3)C中解决名称冲突的办法是：

​		第一，同一个C文件不要太大，由一个人写；

​		第二，每个C文件（或几个C文件构成的一个模块）中所有全局变量和函数前加统一的唯一前缀；

​		第三，不需要文件外访问的全局变量和函数前面都加static;

​	(4)C语言的解决方案可行，C++早期就是这样做的，但这种方法太low;



### 1.3.1.3、命名空间如何解决问题

​	(1)为实现命名空间机制，C++引入了namespace关键字，定义格式为namespace xx{};

​	(2)一个特定名称的namespace的一对大括号内部定义的变量、函数、类等均属于该命名空间内;

​	(3)在命名空间内部互相引用时可以直接使用变量名、函数名等;

​	(4)跨命名空间互相引用时必须同时指定被引用方的命名空间名和变量名函数名才可以找到;

​	(5)命名空间看起来就好像一种前缀;

​	(6)命名空间本质上其实是对全局变量和函数在一定范围内链接属性的更改和控制;



### 1.3.1.4、关于语言特性的思考

​	(1)语言特性是语言通过关键字或符号所支持的一种功能特性，如namespace、template、运算符重载、面向对象等;

​	(2)语言特性必定对应解决某种问题，必定在某方面对程序员有帮助;

​	(3)语言特性越多或者设计越复杂，则语言本身就越难使用，但语言就越厉害;

​	(4)语言特性体现为某种语法，本质上靠编译工具链提供支持;

​	(5)C++11/14/17/20的版本变迁，无非是新增或修正某些细节语言特性;

​	(6)就事论事讨论编程语言，其实难点都在掌握和熟练运用语言特性上;



## 1.3.2.namespace的初级定义和使用

### 1.3.2.1、同一文件内定义namespace

```c++
/*定义一个名叫NS1的命名空间，这个空间里面有一个func2的函数*/
namespace NS1
{
    void func1(void)
    {
		printf("hello world!\n");
    }
}
```



### 1.3.2.2、同一文件内使用namespace

(1)namespace的三种引用方法

```c++

// 方式一： 不做任何声明直接使用
ace::Mutex;
/*示例*/
int main(void)
{
    NS1::func1();
    return 0;
}

// 方式二, 声明的方式使用，相当于把需要使用的命名空间的函数声明到当前空间，然后再使用该函数
using ace::Mutex;
Mutex mutex;
/*示例*/
using NS1::func1();
int main(void)
{
    func1();
    return 0;
}

// 方式三, 声明的方式使用，可以使用这个namespace中的任何成员
using namespace ace;
Mutex mutex;
/*示例*/
using namespace NS1;
int main(void)
{
    func1();
    return 0;
}

//实际编程当中，我们用方法一和方法二比较多
```



### 1.3.2.2、不同C文件间定义和使用namespace

​	(1)如何声明一个namespace？

```c++
/*file: 2.cpp*/
namespace NS2
{
    void func1(void)
    {
        
    }
}

/*file: 1.cpp*/
//需要先声明命名空间, 两种都可以
namespace NS2{void func1(void);}
namespace NS2{extern void func1(void);}
int main(void)
{
    NS2::func1();
    return 0;
}
```

​	(2)注意： namespace 可以定义重复相同的名字，在同意文件内，就相当于在这个命名空间内继续填充成员；在不同的文件中定义相同名字的命名空间，调用它时需要事先声明。

```c++
/*在同一个文件内*/
namespace NS1
{
  void func2(void)
  {
  }  
}

namespace NS1
{
  void func3(void)
  {
  }  
}

/*在不同的文件内*/
/**/
```

​	(3)**注意：**体会这种学习方法，核心是：第一步明确问题，第二步自我分析，第三步实验验证，总纲是形成自我知识体系，本质上站在和语言特性设计者一样的高度来看待和学习研究语言。



## 1.3.3.C++默认命名空间

### 1.3.3.1、默认命名空间

​	(1)又叫全局命名空间，没有放入namespace 中的成员，都叫默认命名空间；

​		main()函数必须放在默认命名空间；

​	(2)默认命名空间引用其他命名空间方法；

​	(3)默认命名空间引用自己的方法；

​	(4)其他命名空间引用默认命名空间中的方法

```c++
/*其他命名空间引用默认命名空间中的方法*/
::f();  		//正规做法
f();			//省略:: ，不确定，不太正规
```



## 1.3.4.C++匿名命名空间

### 1.3.4.1、std和cout的引入

​	(1)std是C++标准库定义好的一个namespace

​			这个namespace 的名字就叫 std，这个就是C++ 的标准库；

​	(2)cout是std这个namespace下的一个标准输出工具，类似于C中的printf

​	(3)用法示例

```c++
#include <iostream>

using namespace std;

int main(void)
{
    cout << "hello world!\n" << endl;
    //或者使用这种方法：std::cout << "hello world!\n" << std::endl; 

    return 0;
}
```



### 1.3.4.2、匿名命名空间的定义和使用

​	(1)定义

```c++
namespace
{
    void func1(void)
    {
        
    }
}
```

​	(2)匿名命名空间中引用其他命名空间中的方法  

```c++
namespace NS1
{
  void func(void);  
}

namespace
{
    void func1(void)
    {
        NS1::func();
    }
}
```

​	(3)匿名命名空间中引用自己命名空间中的方法

```c++
namespace
{
    void func1(void)
    {
        void func(void);
        func();
    }
} 
```

​	(4)其他命名空间中引用匿名命名空间中的方法

```c++

namespace
{
    void func1(void)
    {
        printf("func1\n");
    }
}

namespace NS1
{
    void func2(void)
    {
        func1();
    }
 // func1(); 直接使用会出错，这相当于声明了；
}
//注意：只能当前文件内使用
```



### 1.3.4.3、匿名命名空间的价值

​	(1)匿名命名空间中的符号纯文件内部使用，不需要被外部引用;

​	(2)匿名命名空间效果类似于全局变量和函数加static，但是比C中的static使用范围广;

​	(3)匿名命名空间的用法逻辑上符合整个命名空间的一贯原则;



## 1.3.5.嵌套命名空间

### 1.3.5.1、嵌套namespace的定义和使用

```c++
#include <iostream>
using namespace std;
/*定义*/
namespace NS1
{
    void func2(void)
    {
         cout << "NS1::func2." << endl;
    }
  
    namespace NS2{
        /*NS1 和NS2中的函数可以重名,优先执行NS2的func2*/
        void func2(void)
        {
            cout << "NS1::NS2::func2." << endl;
        }
        void func1(void)
        {
            func2();
            cout << "NS1::NS2::func1." << endl;
        }
    }
	
    /*引用嵌套命名空间内的符号*/
    void func3(void)
    {
        NS2::func1();
    }
}

int main()
{
    NS1::NS2::func1();  /*输出结果: NS1::func2.  NS1::NS2::func1.*/
    NS1::func2();		/*输出结果: NS1::func2.*/
    NS1::NS2::func2(); /*输出结果: NS1::NS2::func2. 说明优先执行NS2的func2*/
    NS1::func3();  	   /*输出结果: NS1::NS2::func2.  NS1::NS2::func1*/

    return 0;
}
```



### 1.3.5.2、namespace的总结

​	(1)记住最终目标：解决全局名称冲突，同时提供合法互相访问的机制;

​	(2)直接用法（语法），记住如何定义、如何声明、三种使用方法;

​	(3)特殊情况有默认/全局命名空间和匿名命名空间，均为符合一贯原则的特例用法;

​	(4)再次体会"语言特性"的含义;

​	(5)C++的语言特性多而复杂，因此学习和使用难度高，关键在于掌握方法，从本质上学;



## 1.3.6.C++标准库介绍

### 1.3.6.1、C++是C的超集

​	(1)一个典型C程序（后缀名.c）可以完全被视为C++程序来编译;

​	(2)C程序可以通过__cplusplus符号是否预定义来判断当前是gcc还是g++编译 ;__

​		__cplusplus的值是long int类型的，值表示当前编译程序的C++编译器的版本号。

​	(3)一个典型C++程序（后缀名.cpp）只能当C++程序来编译，可见C++是C的超集;

​	(4)C++文件名的常用后缀：源文件（.cpp .cxx .cc .c .c++），头文件（.hpp .hxx .h);



### 1.3.6.2、C++完全接收并兼容了C库

​	(1)典型C++程序中可以支持C的形式包含C库头文件，并直接使用C库API;

​	(2)C++更建议的头文件包含形式不是<stdio.h>这样，而是<cstdio>这样;

​		要点：C++的标准库的头文件是没有后缀名的;

​	(3)ubuntu中gcc工具链的头文件在/usr/include中，可以实际看看;



### 1.3.6.3、C++标准库介绍

​	(1)C标准库即为C++标准库的一部分，完全继承并以C++方式重写，位于std命名空间中;

​	(2)C++面向对象库，如string、iostream等，位于std命名空间中;

​	(3)C++ STL标准模板库，如vector、map等，位于std命名空间中;



### 1.3.6.4、C++标准库的地位和学习安排

​	(1)C++比C在实际工作中更依赖于库，所以学好C++标准库很重要;

​	(2)C++标准库蕴含了C++的各种语言特性的典型用法，学标准库就顺便学好了C++;

​	(3)继承C标准库的部分兼容C的玩法，不用讲了;

​	(4)C++面向对象库难度不大，本次先讲iostream和string等初步用法;

​	(5)STL部分是重难点，在《朱老师C++第3部分-STL等高阶话题》中再讲;

 

## 1.3.7_8.iostream的cout使用1_2

### 1.3.7.1、基本使用

​	(1)cout即标准输出，对应stdout;

​	(2)cout定义在std命名空间中，要按三种使用方法来用;

​	(3)结合<<(流操作符)符号进行输出，可多节连接;

​	(4)cout涉及的头文件有

```C++
<iostream> <iomanip> <bits/ios_base.h>;
```

​	(5)cout本质上是ostream（iostream的派生类）的一个对象;

​	(6)流操作符<<本质上是左移运算符在iostream中的运算符重载;



1.3.7.2、流操作符的格式化细节
(1)网络搜索C++ cout使用，大把文档详细讲
(2)cout现在主要用来输出调试信息，掌握主要用法和细节查询即可，不必去记。

1.3.9.iostream的cin使用
1.3.9.1、基本使用
1.3.9.2、注意点
(1)输入的时候不要使用引用符&				scanf("%d", &val);
(2)cin的输入会以空格为中断

1.3.10.C++用fstream读写文件
1.3.10.1、fstream介绍
(1)fstream是C++标准库中面向对象库的一个，用于操作流式文件
(2)fstream本质上是一个class，提供file操作的一众方法
(3)有核心课程中应用编程里文件操作的基础，fstream的使用很简单
1.3.10.2、C++标准库查询参考
(1)man手册：https://blog.csdn.net/u012675539/article/details/50257343
(2)http://www.cplusplus.com/reference/
(3)https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5
1.3.10.3、fstream使用举例
(1)打开/创建文件，并写入内容，保存关闭
(2)打开文件，并读取内容显示，最后关闭。

1.3.11.fstream读写文件编程实战
不要只听课不动手，拓展做练习

1.3.12.C++字符串string类使用
1.3.12.1、C++式字符串的使用
(1)参考手册文档
(2)代码实践
1.3.12.2、C++字符串和C字符串的对比
(1)C语言严格说没有字符串的概念，C字符串其实就是字符数组或字符指针
(2)C++和之后的java等都有字符串，本质是一个class
(3)C++字符串的优势是标准库自带可用于字符串的各种处理算法和方法
(4)C++实际开发中建议使用C++字符串而不是沿用C式字符串


1.3.13.C与C++混合编程1
1.3.13.1、为什么需要混合编程
(1)C有很多优秀成熟项目和库，丢了可惜，重写没必要，C++程序里要调用
(2)庞大项目划分后一部分适合用C，一部分适合用C++
(3)其他情况，如项目组一部分人习惯用C，一部分习惯用C++
1.3.13.2、为什么不同语言可以混合编程
(1)程序编译过程：源文件->目标（库）文件->可执行程序->镜像文件
(2)任何编程语言执行时都必须是可执行程序，所以都必须先被编译成目标文件
(3)混合编程的“混合”操作发生在链接这一步
1.3.13.3、C++和C混合编程的困难所在
(1)C++和C都是编译型语言，互相混合相对容易
(2)难点：C++支持函数名重载，而C不支持，因此编译器生成目标文件时，函数名在目标文件中的临时内部名称规则不同。导致链接时符号对不上
(3)解决方案：使用extern "C"{}; 让C++在对接的局部向C妥协兼容
1.3.13.3、使用objdump工具来研究函数编译后的符号
(1)写个典型的C语言库mylib.c和mylib.h，提供add和sub等几个函数
(2)使用gcc -c -o编译得到库文件，再objdump -d反汇编得到.i文件
(3)对比加不加extern "C"这2种情况下得到的.i文件的符号差异
实验第1步：证明了C语言中名称为add的函数，编译后符号表中就叫add
实验第2步：证明了C++语言中名称为add的函数，编译后符号表中叫_Z3addii
分析：同样的源码，编译后生成的二进制代码其实是一样的，所以功能其实也是一样的
所以本质上是可以混合编程的，但是生成的中间符号名称不同，所以链接器难受
实验第3步：证明了在C++的头文件中，只要把C++的函数的声明放在extern "C"{}的大括号范围之内，就可以让g++在编译这个函数时生成中间符号名时按照C的规则而不是按照C++的规则，所以这样的函数就可以和C的库进行共同链接。

1.3.14.C与C++混合编程2
1.3.14.1、C与C++混合编程的可能情况分析
(1)同一个项目全部有源码，一次编译链接。
(2)同一个项目中C是库，C++是源码，C++调用C
(3)同一个项目中C++是库，C是源码，C调用C++
1.3.14.2、第一种情况
(1)可能性1：全部使用g++编译。不推荐
(2)可能性2：在C的头文件中加extern "C"声明
1.3.14.3、第二种情况
(1)这种是最典型的常见情况
(2)通用解决方案：在C的头文件中加extern "C"声明，在C++中直接包含头文件调用即可

1.3.15.C调用C++库的方法
1.3.15.1、C调用C++的麻烦
(1)g++和gcc的编译时符号差异
(2)c++支持很多c并不支持的特性，如函数重载
(3)解决方案：添加一层封装层
1.3.15.2、代码实战：C调用C++库中的函数
(1)用cpp写一个库，mylib.cpp mylib.hpp，用g++编译成静态库
(2)objdump反编译库，查看确认符号
(3)用cpp写一个封装层，用上extern "C"，cmylib.cpp和cmylib.hpp，用g++编译成静态库
(4)objdump反编译库，查看确认符号
(5)用c写一个main.c，调用wrapper库，用gcc编译链接，运行查看结果

 