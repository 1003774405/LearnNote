[TOC]

 

# 第一章 uboot学习前传

## 2.1.0 章节概要

**2.1.1.为什么要有uboot**

​    本节从计算机系统的启动过程讲起，分析PC机、嵌入式系统等的启动过程，通过分析让大家理解uboot在系统其中中扮演的重要角色。

**2.1.2.为什么是uboot**

​    本节课讲述uboot的来源和开发者，uboot的特点和发展历程，让大家明白uboot怎么样一步步发展而来，理解它出现的必然性。

**2.1.3.uboot必须解决哪些问题**

​    本节分析uboot必须解决的一些问题，这些问题也正是uboot中的主要代码

**2.1.4.uboot的工作方式**

​    本节主要介绍uboot的命令行工作方式，重点强调了命令和环境变量这两个关键点。

**2.1.5.uboot的常用命令1**

​    本节开始介绍uboot的常用命令。首先讲了uboot命令的一些特征如行缓冲、命令别名、参数等然后讲了print命令。

**2.1.6.uboot的常用命令2**

​    本节讲述uboot常用命令中设置、保存环境变量的命令、ping命令。

**2.1.7.开发板和主机的ping通**

​    本节详细介绍开发板和主机windows、虚拟机ubuntu的ping通及设置。

**2.1.8.uboot的常用命令3**

​    本节继续介绍uboot的常用命令，主要是tftp和nfs命令，这两个命令都是uboot用来和主机进行网络连接获取文件相关的。

**2.1.9.uboot的常用命令4**

​    本节主要介绍了uboot操作iNand的movi命令和操作内存的mm、mw、md命令

**2.1.10.uboot的常用环境变量1**

​    本节总结了uboot的环境的原理和使用方法，并以bootdelay等环境变量来演示这种使用效果。

**2.1.11.uboot的常用环境变量2**

​    本节主要讲解uboot的2个重要环境变量bootcmd和bootargs。

**2.1.12.uboot中对Flash和DDR的管理**

​    本节讲述uboot对Flash和DDR的分区管理，其中最重要的是Flash的分区。

## 2.1.1.为什么要有uboot

### 2.2.1.1、计算机系统的主要部件

(1)计算机系统就是有CPU来做核心进行运行的系统。典型的计算机系统有：PC机（台式机+笔记本）、嵌入式设备（手机、平板电脑、游戏机）、单片机（家用电器像电饭锅、空调）。

(2)计算机系统的组成部件非常多，不同的计算机系统组成部件也不同。但是所有的计算机系统运行时需要的主要核心部件都是3个东西：CPU + 外部存储器（Flash/硬盘） + 内部存储器（DDR SDRAM/SDRAM/SRAM）。

 

### 2.2.1.2、PC机的启动过程

(1)典型的PC机的部署：BIOS程序部署在PC机主板上（随主板出厂时已经预制了），操作系统部署在硬盘上，内存在掉电时无作用，CPU在掉电时不工作。

(2)启动过程：PC上电后先执行BIOS程序（实际上PC的BIOS就是NorFlash），BIOS程序负责初始化DDR内存，负责初始化硬盘，然后从硬盘上将OS镜像读取到DDR中，然后跳转到DDR中去执行OS直到启动（OS启动后BIOS就无用了）。

 

### 2.2.1.3、典型嵌入式linux系统启动过程

(1)嵌入式系统的部署和启动都是参考PC机的。只是设备上有一些差别

(2)**典型嵌入式系统的部署**：uboot程序部署在Flash（能作为启动设备的Flash）上、OS部署在FLash（嵌入式系统中用Flash代替了硬盘）上、内存在掉电时无作用，CPU在掉电时不工作。

(3)**启动过程**：嵌入式系统上电后先执行uboot、然后uboot负责初始化DDR，初始化Flash，然后将OS从Flash中读取到DDR中，然后启动OS（OS启动后uboot就无用了）

 

**总结：**嵌入式系统和PC机的启动过程几乎没有两样，只是BIOS成了uboot，硬盘成了Flash。

 

### 2.2.1.4、android系统启动过程

(1)android系统的启动和linux系统（前面讲的典型的嵌入式系统启动）几乎一样。几乎一样意思就是前面完全一样，**只是在内核启动后加载根文件系统后不同了**。

(2)**可以认为启动分为2个阶段**：

第一个阶段是uboot到OS启动；

第二个阶段是OS启动后到rootfs加载到命令行执行；

现在我们主要研究第一个阶段，android的启动和linux的差别在第二阶段。

 

### 2.2.1.5、总结：uboot到底是干嘛的

(1)uboot主要作用是用来启动操作系统内核。

(2)uboot还要负责部署整个计算机系统。

(3)uboot中还有操作Flash等板子上硬盘的驱动。

(4)uboot还得提供一个命令行界面供人来操作。

 

 

## 2.1.2.为什么是uboot

### 2.1.2.1、uboot从哪里来的？

(1)uboot是SourceForge上的开源项目

(2)uboot项目的作者：一个德国人最早发起的项目

(3)uboot就是由一个人发起，然后由整个网络上所有感兴趣的人共同维护发展而来的一个bootloader。

 

### 2.1.2.2、uboot的发展历程

(1)自己使用的小开源项目。

(2)被更多人认可使用

(3)被SoC厂商默认支持。

总结：uboot经过多年发展，已经成为事实上的业内bootloader标准。现在大部分的嵌入式设备都会默认使用uboot来做为bootloader。

 

### 2.1.2.3、uboot的版本号问题

(1)早期的uboot的版本号类似于这样：uboot1.3.4。后来版本号便成了类似于uboot-2010.06。

(2)uboot的核心部分几乎没怎么变化，越新的版本支持的开发板越多而已，对于一个老版本的芯片来说，新旧版本的uboot并没有差异。

### 2.1.2.4、uboot的可移植性的正确理解

(1)uboot就是universal bootloader（通用的启动代码），通用的意思就是在各种地方都可以用。所以说uboot具有可移植性。

(2)uboot具有可移植性并不是说uboot在哪个开发板都可以随便用，而是说uboot具有在源代码级别的移植能力，可以针对多个开发板进行移植，移植后就可以在这个开发板上使用了。

 

### 2.1.2.5、总结：时势造英雄，任何牛逼的东西都是时代的产物

uboot的出现是一种必然，如果没有uboot也会有另一个bootloader来代替。

 

 

## 2.1.3.uboot必须解决哪些问题

### 2.1.3.1、自身可开机直接启动

(1)一般的SoC都支持多种启动方式，譬如SD卡启动、NorFlash启动、NandFlash启动等·····uboot要能够开机启动，必须根据具体的SoC的启动设计来设计uboot.

(2)uboot必须进行和硬件相对应的代码级别的更改和移植，才能够保证可以从相应的启动介质启动。uboot中第一阶段的start.S文件中具体处理了这一块。

 

 

### 2.1.3.2、能够引导操作系统内核启动并给内核传参

(1)uboot的终极目标就是启动内核。

(2)linux内核在设计的时候，设计为可以被传参。也就是说我们可以在uboot中事先给linux内核准备一些启动参数放在内存中特定位置然后传给内核，内核启动后会到这个特定位置去取uboot传给他的参数，然后在内核中解析这些参数，这些参数将被用来指导linux内核的启动过程。

 

### 2.1.2.3、能提供系统部署功能

(1)uboot必须能够被人借助而完成整个系统（包括uboot、kernel、rootfs等的镜像）在Flash上的烧录下载工作。

(2)裸机教程中刷机（ARM裸机第三部分）就是利用uboot中的fastboot功能将各种镜像烧录到iNand中，然后从iNand启动。

 

### 2.1.2.4、能进行soc级和板级硬件管理

(1)uboot中实现了一部分硬件的控制能力（uboot中初始化了一部分硬件），因为uboot为了完成一些任务必须让这些硬件工作。譬如uboot要实现刷机必须能驱动iNand，譬如uboot要在刷机时LCD上显示进度条就必须能驱动LCD，譬如uboot能够通过串口提供操作界面就必须驱动串口。譬如uboot要实现网络功能就必须驱动网卡芯片。

(2)SoC级（譬如串口）就是SoC内部外设，板级就是SoC外面开发板上面的硬件（譬如网卡、iNand）

 

### 2.1.2.5、uboot的“生命周期”

(1)**uboot****的生命周期**：uboot什么时候开始运行，什么时候结束运行?

(2)**uboot****本质**上是一个**裸机程序（不是操作系统）**，一旦uboot开始SoC就会单纯运行uboot（意思就是uboot运行的时候别的程序是不可能同时运行的），一旦uboot结束运行则无法再回到uboot（所以uboot启动了内核后uboot自己本身就死了，要想再次看到uboot界面只能重启系统。重启并不是复活了刚才的uboot，重启只是uboot的另一生）

(3)**uboot****的入口和出口**:uboot的入口就是开机自动启动，**uboot的唯一出口就是启动内核**。uboot还可以执行很多别的任务（譬如烧录系统），但是其他任务执行完后都可以回到uboot的命令行继续执行uboot命令，而启动内核命令一旦执行就回不来了。

总结：一切都是为了启动内核

 

 

## 2.1.4.uboot的工作方式

### 2.1.4.1、从裸机程序镜像uboot.bin说起

(1)**uboot****的本质就是一个裸机程序**，和我们裸机全集中写的那些裸机程序xx.bin并没有本质区别。如果非说要有区别，那就是：我们写的大部分小于16KB，而uboot大于16KB（一般uboot在180k-400k之间）。

(2)**uboot****本身是一个开源项目**，由若干个.c文件和.h文件组成，配置编译之后会生成一个uboot.bin，这就是uboot这个裸机程序的镜像文件。然后这个镜像文件被合理的烧录到启动介质中拿给SoC去启动。也就是说uboot在没有运行时表现为uboot.bin，一般躺在启动介质中。

(3)uboot运行时会被加载到内存中然后一条指令一条指令的拿给CPU去运行。

 

### 2.1.4.2、uboot的命令式shell界面

(1)普通的裸机程序运行起来就直接执行了，执行时效果和代码有关。

(2)有些程序需要和人进行交互，于是乎程序中就实现了一个shell（shell就是提供人机交互的一个界面，回想ARM裸机全集第十六部分），uboot就实现了一个shell。

注意：shell并不是操作系统，和操作系统一点关系都没有。linux中打开一个终端后就得到了一个shell，可以输入命令回车执行。uboot中的shell工作方式和linux中的终端shell非常像（其实几乎是一样的，只是命令集不一样。譬如linux中可以ls，uboot中ls就不识别）。

 

### 2.1.4.3、掌握uboot使用的2个关键点：命令和环境变量

(1)uboot启动后大部分时间和工作都是在shell下完成的（譬如uboot要部署系统要在shell下输命令、要设置环境变量也得在命令行地下，要启动内核也要在命令行底下敲命令）

(2)**命令**就是uboot的shell中可以识别的各种命令。uboot中有几十个命令，其中有一些常用另一些不常用（我们还可以自己给uboot添加命令），后面会用几节课时间来依次学习uboot中常用命令。

(3**)uboot****的环境变量**和操作系统的环境变量工作原理和方式几乎完全相同。uboot在设计时借助了操作系统的设计理念（命令行工作方式借鉴了linux终端命令行，环境变量借鉴了操作系统的环境变量，uboot的驱动管理几乎完全照抄了linux的驱动框架）。

(4)环境变量可以被认为是系统的全局变量，环境变量名都是系统内置的（认识就认识，不认识就不认识，这部分是系统自带的默认的环境变量，譬如PATH；但是也有一部分环境变量是自己添加的，自己添加的系统就不认识但是我们自己认识）。

**环境变量有什么用呢？**系统或者我们自己的程序在运行时可以通过读取环境变量来指导程序的运行。这样设计的好处就是灵活，譬如我们要让一个程序更改运行方法，不用去重新修改程序代码再重新编译运行，而只要修改相应的环境变量就可以了。

(5)环境变量就是运行时的配置属性。

 

### 2.1.4.4、思考：结合ARM裸机部分进行理解和印证

(1)及时复习ARM裸机中和现在讲到的相关的知识点，在复习中巩固ARM裸机中学到的。这过程中如果原来学习记了笔记，非常容易容易好，如果没有记笔记那就难办了。

(2)及时对照原来ARM裸机中讲到的相关部分，可以帮助理解当前讲到的知识点。

(3)结合ARM裸机中和现在讲的，对比分析思考，会得到更多。

 

 

## 2.1.5.uboot的常用命令1

### 2.1.5.1、类似linux终端的行缓冲命令行

(1)行缓冲的意思就是：当我们向终端命令行输入命令的时候，这些命令没有立即被系统识别，而是被缓冲到一个缓存区（也就是系统认为我们还没有输入完），当我们按下回车键（换行）后系统就认为我们输入完了，然后将缓冲区中所有刚才输入的作为命令拿去分析处理。

(2)linux终端设计有3种缓冲机制：无缓冲（输入一个字符处理一个字符）、行缓冲（按回车为命令\n）、全缓冲（缓冲区满了采取处理EOF）。

 

### 2.1.5.2、有些命令有简化的别名

(1)譬如printenv命令可以简化为print，譬如setenv可以简化为set

### 2.1.5.3、有些命令会带参数（注意格式是固定的） 

(1)uboot的每个命令都有事先规定好的各种格式。有些命令就是不带参数的，譬如printenv/print命令；

有些命令带可选的参数（可以带也可以不带，当然带不带参数的执行结果是不同的）；有些命令带必须的参数（譬如setenv/set命令）。

 

### 2.1.5.4、命令中的特殊符号（譬如单引号）

(1)uboot的有些命令带的参数非常长，为了告诉uboot这个非常长而且中间有好多个空格的东西是给他的一整个参数，所以用单引号将这个很长且中间有空格隔开的参数引起来。 

(2)别的符号也许也有，而且有特定的意义。当碰到uboot的命令行有特殊符号时要注意不是弄错了，而是可能有特别的含义。

 

### 2.1.5.5、有些命令是一个命令族（譬如movi）

(1)命令族意思就是好多个命令开头都是用同一个命令关键字的，但是后面的参数不一样，这些命令的功能和作用也不同。这就叫一个命令族。

(2)同一个命令族中所有的命令都有极大的关联，譬如movi开头的命令族都和moviNand（EMMC、iNand）操作有关。

 

### 2.1.5.5、第一个命令：printenv/print

(1)print命令不用带参数，作用是打印出系统中所有的环境变量。

(2)**环境变量就好像程序的全局变量一样**：程序中任何地方都可以根据需要去调用或者更改环境变量（一般都是调用）。

(3)**环境变量和全局变量不同之处在于：**全局变量的生命周期是在程序的一次运行当中，开始运行时诞生程序结束时死亡，下次运行程序时从头开始；但是环境变量被存储在Flash的另一块专门区域（Flash上有一个环境变量分区），一旦我们在程序中保存了该环境变量，那么下次开机时该环境变量的值将维持上一次更改保存后的值。

 

 

## 2.1.6.uboot的常用命令2

### 2.1.6.1、设置（添加/更改）环境变量：setenv/set

(1)用法：set name value

 

### 2.1.6.2、保存环境变量的更改：saveenv/save

​                                

我们更改了环境变量只是更改了DDR里的变量值，DDR断电就消失了，所以下次重启，更改过得变量的值也就消失。这时候我们需要把更改环境变量的值同步到flash（也就是SD卡）中，我们可以用save命令做到这点。

(1)saveenv/save命令不带参数，直接执行，作用是将内存中的环境变量的值同步保存到Flash中环境变量的分区。注意：环境变量的保存是整体的覆盖保存，也就是说内存中所有的环境变量都会整体的将Flash中环境变量分区中原来的内容整体覆盖。

 

总结：彻底更改一个环境变量的值，需要2步：

第一步set命令来更改内存中的环境变量，

第二步用save命令将其同步到Flash中环境变量的分区。

有时候我们只是想测试下这个环境变量，不希望影响到下一次开机，那就只set不save，这样set后当前本次运行的uboot已经起效果了，只不过没save下一次开机还是会恢复到原来的状况。

 

### 2.1.6.3、网络测试指令：ping

(1)命令用法： ping ip地址

注意：ping是测试开发板和主机之间的网络链接，注意以下步骤：

1)首先要插上网线。

2)先试图ping通主机windows。

注意Windows中有线网卡的地址设置（设置本地连接）。设置主机windows的本地连接IPv4地址为192.168.1.10。

3)第三步确认开发板中uboot里几个网络相关的环境变量的值对不对。最重要的是ipaddr（这个环境变量表示当前开发板的IP地址），这个地址必须和主机windows的IP地址在同一个网段。

 

网段的概念：一个IP地址分为2部分，一部分是网段地址，另一部分是网段内的主机地址（由子网掩码来区分哪一部分是网段地址，哪一部分是IP地址）。在子网掩码是255.255.255.0的情况下，192.168.1.10这个IP地址的前三部分（192.168.1.）属于网段地址，第4部分（10）属于主机地址。

## 2.1.7.开发板和主机的ping通 

上节课最后的结果是：uboot中的ipaddr和主机windows本地连接地址已经设置到一个网段，但是实际还ping不通。

还发现了这样的现象：

1、我把2个的网段都从192.168.1.x改到192.168.0.x时会ping通一次，第二次开始就ping不通了；

2、有同学说ping不通可能是因为uboot中gatewayip没设置，我就实际测试设置网关为同网段.1，再次测试结论是第一次ping通了，第二次开始又不通了。

### 2.1.7.1、开发板运行linux下和主机Windows的ping通

(1)先将开发板刷机成linux+QT镜像（刷机见裸机教程第三部分），然后启动进入linux命令行终端下。

(2)在linux下使用ifconfig命令将开发板中linux系统的IP地址设置为和主机windows同一网段（为了上课方便，以后就固定：主机windows地址192.168.1.10，开发板uboot或linux的地址为192.168.1.20，虚拟机ubuntu地址为192.168.1.141）

(3)此时开发板端ping windows通的。

 

(4)windows中ping开发板也是通的。

 

说明：首先开发板和主机的网络部分硬件都是好的，网络连接也是好的，主机windows中的网络软件设置是好的。

### 2.1.7.2、开发板运行linux下和虚拟机ubuntu的ping通

(1)在linux基础课中讲过：虚拟机的网卡设置可以选择好几种方式，常用的就是NAT和桥接（bridged）。

​      

 

   NAT                           桥接

**NAT** : 虚拟机相当于在windows的肚子里，通信的顺讯是通过 虚拟机发给windows在发给外部设备的，但是外部设备和虚拟机通讯的话只能看到windows看不到虚拟机。

**桥接**：windows和linux都是和外部相连的，外部网络看来是两台电脑；

(2)虚拟机要和开发板进行网络通信，只能通过桥接方式连接。

(3)虚拟机要想被开发板ping通，设置步骤如下：

第一步：虚拟机设置成桥接方式。

第二步：虚拟机的菜单中有个“虚拟网络编辑器”，这里面要设置为桥接到有线网卡。（默认是自动的，自动的一般会影响ping通。因为电脑现在一般都有2个网卡：一个有线的一个无线的。如果选了自动，那么虚拟机会自动桥接到无线网卡上，但是我们却是通过有线网卡来连接开发板的，自然ping不通）

第三步：在虚拟机ubuntu中设置IP地址为192.168.1.141（可以通过/etc/network/interfaces文件来设置静态的然后重启； 

Iface eth0 inet static

Address 192.168.1.141

Netmask 255.255.255.0

Gateway 192.168.1.1

也可以直接命令行ifconfig去设置sudo ifconfig ens33 192.168.1.141 netmask 255.255.255.0

(4)此时开发板ping虚拟机ubuntu应该就通了。

(5)此时虚拟机ubuntu中ping开发板也是通的。

 

### 2.1.7.3、开发板运行uboot下和主机Windows的ping通

(1)刚才开发板运行linux时和主机windows、虚拟机ubuntu都ping通了，说明硬件和连接和主机设置没错。

(2)此时开发板重启进入uboot，设置好ipaddr、gatewayip，然后去ping windows发现还是不通。 怀疑uboot本身网络驱动有问题。

(3)然后同样情况下尝试去ping通虚拟机ubuntu，理论分析应该也不通，但是实际发现是通的。

 

### 2.1.7.4、开发板运行uboot下和虚拟机ubuntu的ping通

(1)uboot和虚拟机ubuntu互相ping通（前提是虚拟机ubuntu设置为桥接，且桥接到有线网卡，且ip地址设置正确的情况下）

结论：开发板中运行的uboot有点小bug，ping windows就不通，ping虚拟机ubuntu就通。

 

 

## 2.1.8.uboot常用命令3

### 2.1.8.1、tftp下载指令：tftp

(1)uboot本身**主要目标是启动内核**，为了完成启动内核必须要能够部署内核，uboot为了部署内核就需要将内核镜像从主机中下载过来然后烧录到本地flash中。

uboot如何从主机（windows或者虚拟机ubuntu）下载镜像到开发板上？

有很多种方式，**主流方式是**：fastboot和tftp。

**fastboot**的方式是通过USB线进行数据传输。

**tftp**的方式是通过有线网络的。典型的方式就是通过网络，fastboot是近些年才新发展的。

(2)tftp方式下载时实际上uboot扮演的是tftp客户端程序角色，主机windows或虚拟机ubuntu中必须有一个tftp服务器，然后将要下载的镜像文件放在服务器的下载目录中，然后开发板中使用uboot的tftp命令去下载即可。

(3)有些人习惯在windows中搭建tftp服务器，一般是用一些软件来搭建（譬如tftpd32，使用起来比较简单）；有些人习惯在linux下搭建tftp服务器，可以参考网盘中的虚拟机下载目录下的一个教程《嵌入式开发环境搭建-基于14.04.pdf》，这里面有ubuntu中搭建tftp服务器的教程，也可以自己上网搜索教程尝试。（如果你直接就用我的虚拟机，那就已经搭建好了，不用再搭建了；如果是自己新装的那就参考文档搭建；如果你的版本和我的不一样那搭建过程可能不一样）。

(4)我的虚拟机搭建的时候设置的tftp下载目录是/tftpboot，将要被下载的镜像复制到这个目录下。

(5)检查开发板uboot的环境变量，注意serverip必须设置为虚拟机ubuntu的ip地址。（serverip这个环境变量的意义就是主机tftp服务器的ip地址）

(6)然后在开发板的uboot下先ping通虚拟机ubuntu，然后再尝试下载：tftp 0x30000000 zImage-qt（意思是将服务器上名为zImage-qt的文件下载到开发板内存的0x30000000地址处。）

(7)镜像下载到开发板的DDR中后，uboot就可以用movi指令进行镜像的烧写了。

注意：

1）如果你是用的windows下的tftp服务器，那uboot的serverip就要设置为和windwos下tftp服务器的ip地址一样（windows下的tftp服务器软件设置的时候就有个步骤是让你设置服务器的ip地址，这个ip地址和主机windows必须在一个网段）。

2）整个过程中间环节比较多，实际做的时候可能最后会下载不下来。这时候可能的问题非常多，不要问我，自己对照视频课程讲的思路来排查。（譬如：第一步应该先保证uboot和ubuntu可以ping通；第二步再保证ubuntu中tftp服务器搭建没错；第三步再实现tftp下载。如果第一步有问题参考网络设置部分，第二步有问题（tftp本地测试下载ok，但是开发板就是不行），有一个解决方案就是使用windows下的tftp服务器）

Tftp通信使用：**tftp 0x30008000 zImage-qt**

 

 

(8)Linux 搭建tftp服务器 Ubuntu18.4

TFTP是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，以下讲解如何在ubuntu下安装配置tftp：

 

$ sudo apt-get install tftp-hpa tftpd-hpa

 

$ mkdir ~/tftpboot

 

$ chmod 777 ~/tftpboot/

 

$ sudo gedit /etc/default/tftpd-hpa

 

修改配置文件

\# /etc/default/tftpd-hpa

 

TFTP_USERNAME="tftp"

TFTP_DIRECTORY="/home/zifeng/tftpboot"  //tftpboot绝对路径

TFTP_ADDRESS=":69"

TFTP_OPTIONS="--secure"

$ service tftpd-hpa restart

 

 //tftpboot绝对路径

**TFTP_DIRECTORY="/home/jay/tftpboot"  jay 根据自己的用户名更改**

 

 

 

**显示结果： 其中tftp 说明启动成功**

 

​           **激活Internet连接 (服务器和已建立连接的)**

​           **Proto Recv-Q Send-Q Local Address      Foreign Address     State**   

​           **udp    0   0 0.0.0.0:41911       0.0.0.0:\***             

​           **udp    0   0 localhost:domain    0.0.0.0:\***             

**udp    0   0 0.0.0.0:bootpc      0.0.0.0:\***

​           **udp    0   0 0.0.0.0:tftp        0.0.0.0:\***

**————————————————**

**版权声明：本文为CSDN博主「飞翔的荷兰人号z」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。**

**原文链接：https://blog.csdn.net/qq_41782149/article/details/89000025**

 

PS：有一些uboot的镜像烧写会用到tftp协议，例如openwrt的uboot

————————————————

版权声明：本文为CSDN博主「物联网研究室」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/fengfeng0328/article/details/83353007

### 2.1.8.2、nfs启动内核命令：nfs

(1)uboot中也支持nfs命令，但是我基本没用过。

从

## 2.1.9.uboot的常用命令4

### 2.1.9.1、SD卡/iNand操作指令movi

(1)开发板如果用SD卡/EMMC/iNand等作为Flash，则在uboot中操作flash的指令为movi（或mmc）。

(2)movi指令是一个命令集，有很多子命令，具体用法可以help movi查看。

(3)movi的指令都是movi read和movi write一组的，movi read用来读取iNand到DDR上，movi write用来将DDR中的内容写入iNand中。理解这些指令时一定要注意涉及到的2个硬件：iNand和DDR内存。

(4)movi read {u-boot | kernel} {addr}  这个命令使用了一种通用型的描述方法来描述：movi 和 read外面没有任何标记说明每一次使用这个指令都是必选的；一对大括号{}括起来的部分必选1个，大括号中的竖线表是多选一。中括号[]表示可选参数（可以有也可以没有）。

(5)指令有多种用法，譬如 movi read u-boot 0x30000000，意思就是把iNand中的u-boot分区读出到DDR的0x30000000起始的位置处。（uboot代码中将iNand分成了很多个分区，每个分区有地址范围和分区名，uboot程序操作中可以使用直接地址来操作iNand分区，也可以使用分区名来操作分区。）；注意这里的0x30000000也可以直接写作30000000，意思是一样的（uboot的命令行中所有数字都被默认当作十六进制处理，不管你加不加0x都一样）。

 

### 2.1.9.2、NandFlash操作指令nand

(1)理解方法和操作方法完全类似于movi指令

### 2.1.9.3、内存操作指令：mm、mw、md

(1)DDR中是没有分区的（只听说过对硬盘、Flash进行分区，没听说过对内存进行分区····），但是内存使用时要注意，千万不能越界踩到别人了。因为uboot是一个裸机程序，不像操作系统会由系统整体管理所有内存，系统负责分配和管理，系统会保证内存不会随便越界。然后裸机程序中uboot并不管理所有内存，内存是散的随便用的，所以如果程序员（使用uboot的人）自己不注意就可能出现自己把自己的数据给覆盖了。（所以你思考下我们为什么把uboot放在23E00000地址处）。

 

(2**)md**就是memory display，用来显示内存中的内容。

(3)**mw**就是memory write，将内容写到内存中。

(4)**mm**就是memory modify，修改内存中的某一块，说白了还是写内存（如果需要批量的逐个单元的修改内存，用mm最合适）。最后按y结束；

 

 

A代表16进制，表示打印10个l

### 2.1.9.4、启动内核指令：bootm、go

(1)uboot的终极目标就是启动内核，启动内核在uboot中表现为一个指令，uboot命令行中调用这个指令就会启动内核（不管成功与否，所以这个指令是一条死路）。

(2)差别：**bootm启动内核同时给内核传参**，**而go命令启动内核不传参**。

bootm其实才是正宗的启动内核的命令，一般情况下都用这个；

go命令本来不是专为启动内核设计的，go命令内部其实就是一个函数指针指向一个内存地址然后直接调用那个函数，go命令的实质就是PC直接跳转到一个内存地址去运行而已。go命令可以用来在uboot中执行任何的裸机程序（有一种调试裸机程序的方法就是事先启动uboot，然后在uboot中去下载裸机程序，用go命令去执行裸机程序）。

 

 

## 2.1.10.uboot的常用环境变量1

### 2.1.10.1、如何理解环境变量

### 2.1.10.2、环境变量如何参与程序运行

(1)环境变量有2份，一份在Flash中，另一份在DDR中。uboot开机时一次性从Flash中读取全部环境变量到DDR中作为环境变量的初始化值，然后使用过程中都是用DDR中这一份，用户可以用saveenv指令将DDR中的环境变量重新写入Flash中去更新Flash中环境变量。下次开机时又会从Flash中再读一次。

(2)环境变量在uboot中是用字符串表示的，也就是说uboot是按照字符匹配的方式来区分各个环境变量的。因此用的时候一定要注意不要打错字了。

 

### 2.1.10.3、自动运行倒数时间：bootdelay

 

### 2.1.10.4、网络设置：ipaddr serverip 

(1)ipaddr是开发板的本地IP地址

(2)serverip是开发板通过tftp指令去tftp服务器下载东西时，tftp服务器的IP地址。

(3)gatewayip是开发板的本地网关地址

(4)netmask是子网掩码

(5)ethaddr是开发板的本地网卡的MAC地址。

 

 

## 2.1.11.uboot的常用环境变量2

### 2.1.11.1、自动运行命令设置：bootcmd

(1)uboot启动后会开机自动倒数bootdelay秒，如果没有人按下回车打断启动，则uboot会自动执行启动命令来启动内核。

(2)uboot开机自动启动时实际就是在内部执行了bootcmd这个环境变量的值所对应的命令集。

(3)bootcmd=movi read kernel 30008000; bootm 30008000  **意思是：**将iNand的kernel分区读取到DDR内存的0x30008000地址处，然后使用bootm启动命令从内存0x30008000处去启动内核。

(4)set bootcmd printenv，然后saveenv；然后重启则会看到启动倒数后自动执行printenv命令打印出环境变量。这个小实验说明开机自动执行了bootcmd。

(5)set bootcmd 'movi read kernel 30008000; bootm 30008000'  单引号作用：表示这一句话是一体的，不然到；后面就丢失了

 

### 2.1.11.2、uboot给kernel传参：bootargs

(1)linux内核启动时可以接收uboot给他传递的启动参数，这些启动参数是uboot和内核约定好的形式、内容，linux内核在这些启动参数的指导下完成启动过程。这样的设计是为了灵活，为了内核在不重新编译的情况下可以用不同的方式启动。

(2)我们要做的事情就是：在uboot的环境变量中设置bootargs，然后bootm命令启动内核时会自动将bootargs传给内核。

(3)bootargs=console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3          

**意义解释：**

*console=ttySAC2,115200   控制台使用串口2，波特率115200.*

*root=/dev/mmcblk0p2 rw  **mmcblk0**根文件系统在SD卡端口0设备（iNand）；**p2**表示：第2分区，**rw**根文件系统是可读可写的*

*init=/linuxrc           linux的进程1（init进程）的路径*

*rootfstype=ext3          根文件系统的类型是ext3*

(4)内核传参非常重要。在内核移植的时候，新手经常因为忘记给内核传参，或者给内核传递的参数不对，造成内核启动不起来。

**注意: 设置bootargs的时候:**

​       **Set bootargs ‘console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3’**

​    这命令中的‘’千万不能忘记否则会出错

 

### 2.1.11.3、新建、更改、删除一个环境变量的方法

(1)新建一个环境变量，使用set var value

(2)更改一个环境变量，使用set var value

(3)删除一个环境变量，使用set var

### 2.1.11.4、注意：环境变量更改后的保存

(1)修改完成环境变量后一定要保存，否则下次开机更改就又没了。

 

## 2.1.12.uboot中对Flash和DDR的管理

###    2.1.12.1、uboot阶段Flash的分区

(1)所谓分区，就是说对Flash进行分块管理。

(2)PC机等产品中，因为大家都是在操作系统下使用硬盘的，整个硬盘由操作系统统一管理，操作系统会使用文件系统帮我们管理硬盘空间。（管理保证了文件之间不会互相堆叠），于是乎使用者不用自己太过在意分区问题。

(3)在uboot中是没有操作系统的，因此我们对Flash（相当于硬盘）的管理必须事先使用分区界定（实际上在uboot中和kernel中都有个分区表，分区表就是我们在做系统移植时对Flash的整体管理分配方法）。有了这个界定后，我们在部署系统时按照分区界定方法来部署，uboot和kernel的软件中也是按照这个分区界定来工作，就不会错。

(4)分区方法不是一定的，不是固定的，是可以变动的。但是在一个移植中必须事先设计好定死，一般在设计系统移植时就会定好，定的标准是：

uboot:uboot必须从Flash起始地址开始存放（也许是扇区0，也许是扇区1，也许是其他，取决于SoC的启动设计），

**uboot分区**:大小必须保证uboot肯定能放下，一般设计为512KB或者1MB（因为一般uboot肯定不足512KB，给再大其实也可以工作，但是浪费）；

**环境变量：**环境变量分区一般紧贴着uboot来存放，大小为32KB或者更多一点。

**kernel：**kernel可以紧贴环境变量存放，大小一般为3MB或5MB或其他。

**rootfs**：······

**剩下的**就是自由分区，一般kernel启动后将自由分区挂载到rootfs下使用

 

 

 

**总结：一般规律如下**：

(1)各分区彼此相连，前面一个分区的结尾就是后一个分区的开头。

(2)整个flash充分利用，从开头到结尾。

(3)uboot必须在Flash开头，其他分区相对位置是可变的。

(4)各分区的大小由系统移植工程师自己来定，一般定为合适大小（不能太小，太小了容易溢出；不能太大，太大了浪费空间）。

(5)分区在系统移植前确定好，在uboot中和kernel中使用同一个分区表。将来在系统部署时和系统代码中的分区方法也必须一样。

### 2.1.12.2、uboot阶段DDR的分区

(1)DDR的分区和Flash的分区不同，主要是因为Flash是掉电存在的，而DDR是掉电消失，因此可以说DDR是每次系统运行时才开始部署使用的。

(2)内存的分区主要是在linux内核启动起来之前，linux内核启动后内核的内存管理模块会接管整个内存空间，那时候就不用我们来管了。

(3)注意内存分区关键就在于内存中哪一块用来干什么必须分配好，以避免各个不同功能使用了同一块内存造成的互相踩踏。譬如说我们tftp 0x23E00000 zImage去下载zImage到内存的0x23E00000处就会出错，因为这个内存处实际是uboot的镜像所在。这样下载会导致下载的zImage把内存中的uboot给冲掉。

​    

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

 

 

 

 

 

 

 

# 第二章 补基础之shell和Makefile

## 2.2.0 章节概要

**2.2.1.shell介绍**

​    本节简单介绍并引入shell，讲了常用的shell语言和shell的解释执行特性

**2.2.2.动手写第一个shell**

​    本节带大家动手写第一个shell，并且对shell程序的格式做注解

**2.2.3.shell编程学习1**

​    本节主要学习了shell中变量的定义、赋值与引用，另外特别讲了shell中字符串与单引号双引号等的含义和区别

**2.2.4.shell编程学习2**

​    本节首先讲了shell中引用linux命令的方法，然后重点讲了shell中的if语句的各种常见用法。

**2.2.5.shell中的循环结构**

​    本节介绍shell的两种循环结构，while循环和for循环。我们在uboot的配置文件中会用到while循环

**2.2.6.shell中其他值得关注的知识点** 

​    本节介绍shell中剩下的几个对我们有用的语法，如switch case结构、shell执行程序时的传参等

**2.2.7.Makefile基础回顾**

​    本节课回顾裸机中使用到的一些Makefile特性，主要目的是回顾和总结。

**2.2.8.Mafile补充学习1**

​    本节学习一些新的Makefile特性，其中关键是几种赋值运算符的区别。

**2.2.9.Makefile补充学习2**

​    本节学习Makefile的自动变量和通配符规则，这些是理解常见Makefile的关键知识点。

## 2.2.1.shell介绍

### 2.2.1.1、shell是操作系统的终端命令行

(1)shell可以理解为软件系统提供给用户操作的命令行界面，可以说它是人机交互的一种方式。

(2)我们可以使用shell和操作系统、uboot等软件系统进行交互。具体来说就是我们通过shell给软件系统输入命令然后回车执行，执行完成后又会回到shell命令行可以再次输入命令执行。

(3)上述的操作方式一般情况下工作很好，但是有缺陷。譬如我们要在linux下创建一个文件a.c，可以touch a.c 但是如果我现在是用在linux下创建100个文件，分别为a1.c a2.c.....a100.c 如果这时候还是手工去命令行下执行命令创建也可以，但是很累。最好的做法就是把创建过程写成一个shell脚本程序，然后去执行这个shell脚本程序，执行这个程序的效果和手工在命令行输入那些命令效果一样的。（回忆在arm裸机中安装交叉编译工具链时，创建arm-linux-xxx的符号链接时）。

 

### 2.2.1.2、shell是一类编程语言

(1)编写shell脚本时使用的语言就是shell语言，又叫脚本语言。

(2)shell脚本其实是一类语言而不是一个语言。

 

### 2.2.1.3、常用shell语言：sh、bash、csh、ksh、perl、python等

(1)在linux下常用的脚本语言其实就是bash、sh；

(2)perl、python这样的高级shell脚本语言，常用在网络管理配置等领域，系统运维人员一般要学习这些。

(3)**脚本语言一般在嵌入式中应用，主要是用来做配置。**（一个复杂的嵌入式程序都是可配置的，配置过程就是用脚本语言来实现的）自然不会使用过于复杂的脚本语言特性，因此只需要针对性的学习即可。

(4)linux下**最常用**的脚本就是bash，我们学习也是以**bash**为主。

 

### 2.2.1.4、shell脚本的运行机制：解释运行

(1)C语言（C++）这种编写过程是：**编写出源代码（源代码是不能直接运行的）然后编译链接形成可执行二进制程序，然后才能运行；而脚本程序不同，脚本程序编写好后源代码即可直接运行（没有编译链接过程）。**

(2)shell程序是**解释运行**的，所谓解释运行就是说当我们执行一个shell程序时，shell解析器会逐行的解释shell程序代码，然后一行一行的去运行。（顺序结构）

(3)CPU实际只认识二进制代码，根本不认识源代码。脚本程序源代码其实也不是二进制代码，CPU也不认识，也不能直接执行。只不过脚本程序的编译链接过程不是以脚本程序源代码为单位进行的，而是在脚本运行过程中逐行的解释执行时才去完成脚本程序源代码转成二进制的过程（不一定是编译链接，因为这行脚本程序可能早就编译连接好了，这里我们只是调用它）的。

 

## 2.2.2.动手写第一个shell

### 2.2.2.1、编辑器、编译器、运行方法（脚本的3种执行方法）

(1)shell程序是文本格式的，只要是文本编辑器都可以。但是因为我们的shell是要在linux系统下运行的，所以换行符必须是'\n'，而windows下的换行符是"\r\n"，因此windows中的编辑器写的shell不能在linux下运行。所以我们整个课程都是在linux下使用vi编辑器（实际上是vim）进行编写调试的。

(2)编译器 不涉及，因为shell是解释性语言，直接编辑完就可以运行。

 

(3)shell程序运行的运行有多种方法，这里介绍三种方法：

**第一种：**./xx.sh，和运行二进制可执行程序方法一样。这样运行shell要求shell程序必须具有可执行权限。chmod a+x xx.sh来添加可执行权限。

**第二种：**source xx.sh，source是linux的一个命令，这个命令就是用来执行脚本程序的。这样运行不需要脚本具有可执行权限。

**第三种：**bash xx.sh，bash是一个脚本程序解释器，本质上是一个可执行程序。这样执行相当于我们执行了bash程序，然后把xx.sh作为argv[1]传给他运行。

 

### 2.2.2.2、hello world程序和解释

简单的shell程序

\#！/bin/sh

\# #開頭的是註釋

echo "hello world!"

 

(1)shell程序的第一行一般都是： #!/bin/sh      这行话以#!开始，后面加上一个pathname。这行话的意思就是指定shell程序执行时被哪个解释器解释执行。所以我们这里写上/bin/sh意思就是这个shell将来被当前机器中/bin目录下的sh可执行程序执行。

可以将第一行写为：#!/bin/bash来指定使用bash执行该脚本。

注意：在ubuntu上面默认使用的解释器sh其实不是bash，而是dash。dash是ubuntu中默认使用的脚本解释器。

(2)脚本中的注释使用#，#开头的行是注释行。如果有多行需要注释，每行前面都要加#。（#就相当于是C语言中的//）

(3)shell程序的正文，由很多行shell语句构成。

 

### 2.2.2.3、shell并不神秘

(1)shell就是把以前命令行中键入执行的命令写成了程序。shell其实就是为了避免反复的在命令行下手工输入而发明的一种把手工输入步骤记录下来，然后通过执行shell脚本程序就能再次复述原来记录的手工输入过程的一种技术。

(2)shell编辑完可以直接运行（不需编译）

 

 

## 2.2.3.shell编程学习1

### 2.2.3.1、shell中使用linux命令

(1)练习1：当前目录下创建文件a.txt

\#!/bin/sh

\# comment

 

\# test1

 

touch a.txt

 

(2)练习2：当前目录下创建文件夹dir，dir下创建文件b.txt

\#!/bin/sh

\# comment

 

\# test2

 

mkdir dir

cd dir

touch a.txt

cd ..

 

总结：以上2个练习的目的是让大家基本学会写脚本，明白脚本编程其实就是把以前在命令行下输入的命令挪到脚本程序中去然后一次执行。

### 2.2.3.2、shell中的变量定义和引用

(1)变量定义和初始化。shell是**弱类型语言**（语言中的变量如果有明确的类型则属于强类型语言；变量没有明确类型就是弱类型语言），和C语言不同。在shell编程中定义变量不需要制定类型，也没有类型这个概念。

\#!/bin/sh

\#comment

 

\#variable define and use

 

string="hello wrold"

echo $string

 

(2)**变量定义时可以初始化**：使用=进行初始化赋值。在shell中赋值的=两边是不能有空格的。

**注意：**shell对语法非常在意，非常严格。很多地方空格都是必须没有或者必须有，而且不能随意有没有空格。

(3)**变量赋值：**变量定义后可以再次赋值，新的赋值会覆盖老的赋值。shell中并不刻意区分变量的定义和赋值，反正每个变量就是一个符号，这个符号的值就是最后一个给他赋值时的值。

\#!/bin/sh

\#comment

 

\#variable define and use

 

string="hello world"

string="new world"

echo $string

 

输出：new world

 

(4)**变量引用**：shell中引用一个变量必须使用$符号，$符号就是变量解引用符号。

**注意：****$****符号后面跟一个字符串，这个字符串就会被当作变量去解析**。如果这个字符串本身没有定义，执行时并不会报错，而是把这个变量解析为空。也就是说在shell中没有被定义的变量其实就相当于是一个定义并赋值为空的变量。

**注意：**变量引用的时候可以$var，也可以${var}。这两种的区别是在某些情况下只能用${var}而不能简单的$var

var="hello"

echo "$varyou"

\#打印为空

echo "{$var}you"

\#打印为：helloyou

### 2.2.3.3、shell中无引用、单引号和双引号的区别

(1)shell中使用字符串可以不加双引号，直接使用。而且有空格时也可以，但是缺陷是不能输出"或者其他转义字符。

(2)shell中也可以使用单引号来表示字符串，也是直接使用的，不能输出转义字符。是反斜杠就反斜杠，是双引号就双引号，完全原模原样输出；

 

(3)单引号中：完全字面替换（不可包含单引号本身）

(4)双引号中：

$加变量名可以取变量的值

反引号仍表示命令替换

\$表示$的字面值        输出$符号

\`表示`的字面值

\"表示"的字面值

\\表示\的字面值

除以上情况之外，在其它字符前面的\无特殊含义，只表示字面值。

 

 

## 2.2.4.shell编程学习2

### 2.2.4.1、shell中调用linux命令

(1)**直接执行**

**示例：**

mkdir dir

cd dir

touch a.txt

cd ..

 

(2)**反引号括起来执行：**有时候我们在shell中调用linux命令是为了得到这个命令的返回值（结果值），这时候就适合用一对反引号(键盘上ESC按键下面的那个按键，和~在一个按键上)来调用执行命令。

MYPATH="`pwd`/include"

echo "MYPATH = $MYPATH"

 

输出：MYPATH = /mnt/hgfs/winshare/uboot/2.2shell_Makefile/2.2.4/include

### 2.2.4.2、shell中的选择分支结构

(1)shell的if语言用法很多，在此只介绍常用的，其他感兴趣可以自己去学

(2)典型if语言格式

if [表达式]; then

​        xxx

​        yyy

​        zzz

else

​        xxx

​        ddd

​        uuu

fi

if [ -f a.txt ]; then

  echo "yes"

else 

  echo "no"

  touch a.txt

fi

 

(3)if的典型应用

判断文件是否存在。（-f），**注意**[]里面前后都有空格，不能省略。

判断目录是否存在 （-d）

判断字符串是否相等（"str1" = "str2"），**注意**用一个等号而不是两个

判断数字是否相等（-eq）、大于（-gt）、小于（-lt）、大于等于（-ge）、小于等于（-le）      回忆一下在ARM裸机中讲述ARM汇编条件执行时，曾经用过这些条件判断的缩写。（eq就是equal，gt就是greater than，lt就是less than，ge就是greater or equal，le就是less or equal）

**判断字符串是否为空示例：**

\#第一种  

if [string = "" ]

\#第二种

string=""

if[ -z $string ]

 

 

(4)if判断式中使用“-o”表示逻辑或

if [ 12 -eq 12 -o "abcd" = "abcd"]; then

相当于C语言中在if后面的条件式中用逻辑与、逻辑或来连接2个式子，最终的if中是否成立取决于2个式子的逻辑运算结果。

 

(5)逻辑与&&和逻辑或||与简写的if表达式相结合

​    \#简写的if表达式

str="asx"

[ -z $str ] || echo "fei kong"

输出：fei kong

如果[ -2 $str ]不成立 ，执行 echo "fei kong"

​    

**注意：**判断字符串是否为空（-z）注意-z判断时如果变量本身没定义也是不成立（也就是说-z认为没定义不等于为空。

 

## 2.2.5.shell中的循环结构

### 2.2.5.1、for循环

​    for i in 1 2 3 4 5

do

​    echo $i

done

 

(1)要求：能看懂、能改即可。不要求能够完全不参考写出来。因为毕竟嵌入式并不需要完全重新手写shell，系统管理员（服务器运维人员，应用层系统级管理开发的才需要完全掌握shell）。

​    

 

### 2.2.5.2、while循环

(1)和C语言的循环在逻辑上无差别

(2)要注意很多格式要求，譬如：while后面的[]两边都有空格，[]后面有分号（如果do放在一行的话），i++的写法中有两层括号。

i=1

j=4

 

while [ $i -lt $j ]; do

​    echo $i

​    i=$(($i + 1))    #等于c语言i+=1

done 

 

输出  1

2 

3 

### 2.2.5.3、echo的创建和追加输入文件

\#创建a.txt ，再把双引号里的内容test 添加进去 

echo "test" > a.txt

 

echo "#include<stdio.h>

void main(void)

{

  return 0;

}" > a.c

 

echo "//追加内容" >> a.c

(1)在shell中可以直接使用echo指令新建一个文件，并且将一些内容传入这个文件中。创建文件并输入内容的关键就是>。

(2)还可以使用echo指令配合追加符号>> 向一个已经存在的文件末尾追加输入内容。

 

## 2.2.6.shell中其他值得关注的知识点

### 2.2.6.1、case语句

var=2

case $var in

1) echo "1" ;;

2) echo "2" ;;

esac

 

(1)shell中的case语句和C语言中的switch case语句作用一样，格式有差异

(2)shell中的case语句天生没有break，也不需要break，和C语言中的switch case不同。shell中的case默认就是匹配上哪个执行哪个，不会说执行完了还去执行后面的其他case（就好像shell中的case语言默认都带了break）。

 

### 2.2.6.2、调用shell程序的传参

(1)C语言中可以通过main函数的argc和argv给程序传参（详情参考《4.8.3.argc、argv与main函数的传参》）

(2)shell程序本身也可以在调用时传参给他。在shell程序内部使用传参也是使用的一些特定符号来表示的，包括：

$#表示调用该shell时传参的个数。（$#计数时只考虑真正的参数个数）

$0、$1、$2·····则依次表示传参的各个参数。

 

C语言：./a.out aa bb cc   argc = 4, argv[0] = ./a.out, argv[1]是第一个有效参数····

 

shell：source a.sh aa bb cc $# = 3, $0是执行这个shell程序的解析程序的名字（bash），$1是第一个有效参数的值，$2是第2个有效参数的值·····

 

**注意：**shell中的很多语法特性和C语言中是相同的，也有很多是不同的。所以大家学的越多越容易混淆（本质原因还是用的不熟悉，用的少），解决方案是：做笔记、作总结、多写代码经常用。

 

### 2.2.6.3、while循环和case语言和传参结合

 

 

(1)shell中的break关键字和C语言中意义相同（都是跳出）但是用法不同。因为shell中case语句默认不用break的，因此在shell中break只用于循环跳出。所以当while中内嵌case语句时，**case中的break是跳出外层的while循环的，不是用来跳出case语句的**。

 

echo $# $1

shift;

echo $# $1

输入：source 1.sh aa bb

输出：2 bash aa bb

2 aa

1 bb

(2)shell中的$# $1等内置变量的值不是不可变的，而是可以被改变，被shift指令改变。shift指令有点像左移运算符，把我们给shell程序的传参左移了一个移出去了，原来的$2变成了新的$1，原来的$#少了1个。

 

 

## 2.2.7.Makefile基础回顾

### 2.2.7.1、Makefile的作用和意义

(1)工程项目中c文件太多管理不方便，因此用Makefile来做项目管理，方便编译链接过程。

(2)uboot和linux kernel本质上都是C语言的项目，都由很多个文件组成，因此都需要通过Makefile来管理。所以要分析uboot必须对Makefile有所了解。

### 2.2.7.2、目标、依赖、命令

(1)目标就是我们要去make xxx的那个xxx，就是我们最终要生成的东西。

(2)依赖是用来生成目录的原材料

(3)命令就是加工方法，所以make xxx的过程其实就是使用命令将依赖加工成目标的过程。

### 2.2.7.3、通配符%和Makefile自动推导（规则）

(1)%是Makefile中的通配符，代表一个或几个字母；也就是说%.o就代表所有以.o为结尾的文件（相当于shell命令中的*.o）。

(2)所谓自动推导其实就是Makefile的规则。当Makefile需要某一个目标时，他会把这个目标去套规则说明，一旦套上了某个规则说明，则Makefile会试图寻找这个规则中的依赖，如果能找到则会执行这个规则用依赖生成目标。

 

### 2.2.7.4、Makefile中定义和使用变量

(1)**Makefile****中定义和使用变量**：和shell脚本中非常相似。相似是说：都没有变量类型，直接定义使用，引用变量时用$var。

**示例：**

objs := start.o led.o clock.o uart.o main.o int.o adc.o

objs += lib/libc.a

 

uart.bin: $(objs)

 

### 2.2.7.5、伪目标（.PHONY）

clean:

  rm *.o *.elf *.bin *.dis mkx210 -f

  cd lib; make clean; cd ..

 

(1)伪目标意思是这个目标本身不代表一个文件，执行这个目标不是为了得到某个文件或东西，而是**单纯为了执行这个目标下面的命令**。

(2)**伪目标一般都没有依赖**，因为执行伪目标就是为了执行目标下面的命令。既然一定要执行命令了那就不必加依赖，因为不加依赖意思就是无条件执行。

(3)伪目标可以直接写，不影响使用；但是有时候为了明确声明这个目标是伪目标会在伪目标的前面用**.PHONY**来明确声明它是伪目标。

 

### 2.2.7.6、Makefile的文件名

(1)Makefile的文件名合法的一般有2个：Makefile或者makefile

 

### 2.2.7.7、Makfile中引用其他Makefile（include指令）

(1)有时候Makefile总体比较复杂，因此分成好几个Makefile来写。然后在主Makefile中引用其他的，用include指令来引用。引用的效果也是原地展开，和C语言中的头文件包含非常相似。       

 

 

## 2.2.8.Mafile补充学习1

### 2.2.8.1、Makefile中的注释用#

(1)Makefile中注释使用#，和shell一样。

### 2.2.8.2、命令前面的@用来静默执行

(1)在makefile的命令行中前面的**@表示静默执行**。

all:

  echo "hello world!"

 

输出：

echo "hello world!"

hello world!

@echo “hello world!”  这就是静默执行，执行不打印echo ”hello world!” 这行；

(2)Makefile中默认情况下在执行一行命令前会先把这行命令给打印出来，然后再执行这行命令。

(3)如果你不想看到命令本身，只想看到命令执行就静默执行即可。

 

### 2.2.8.3、Makefile中几种变量赋值运算符

 

(1)=    最简单的赋值

(2):=    一般也是赋值

以上这两个大部分情况下效果是一样的，但是有时候不一样；

 

A = abc

B = $(A)def

\#A = gh

all:

  echo $(B)

**输出：**

echo abcdef

abcdef

 

A = abc

B = $(A)def

A = gh

 

all:

  echo $(B)

**输出：**

echo ghdef

ghdef

A := abc

B := $(A)def

A := gh

 

all:

  echo $(B)

**输出：**

echo abcdef

abcdef

A = abc

B := $(A)def

A = gh

 

all:

  echo $(B)

**输出：**

echo abcdef

abcdef

 

 

 

用=赋值的变量，在被解析时他的值取决于最后一次赋值时的值，所以你看变量引用的值时不能只往前面看，还要往后面看。

用:=来赋值的，则是就地直接解析，只用往前看即可。

 

 

var="abcd"

var ?= "efgh"

all : 

echo $(var)

 

输出：

echo "abcd"

abcd

 

将var=”adbc”这句去掉，则输出：

  echo "efgh"

efgh

(3)?=    如果变量前面并没有赋值过则执行这条赋值，如果前面已经赋值过了则本行被忽略。（**实验可以看出：所谓的没有赋值过其实就是这个变量没有被定义过**）。

var = abcd

var += efgh

all :

  echo $(var)

**输出：**

echo abcd efgh

abcd efgh

 

(4)+=  **用来给一个已经赋值的变量接续赋值**：意思就是把这次的值加到原来的值的后面，有点类似于strcat。（在shell makefile等文件中，可以认为所有变量都是字符串，+=就相当于给字符串stcat接续内容）（注意一个细节，+=续接的内容和原来的内容之间会自动加一个空格隔开）

 

**注意：**Makefile中并不要求赋值运算符两边一定要有空格或者无空格，这一点比shell的格式要求要松一些。

 

### 2.2.8.4、Makefile的环境变量

(1)makefile中用export导出的就是环境变量。**一般情况下要求环境变量名用大写，普通变量名用小写。**

(2)环境变量和普通变量不同，可以这样理解：**环境变量**类似于整个工程中所有Makefile之间**可以共享的全局变量**，而**普通变量**只是当前本Makefile中使用的**局部变量**。所以要注意：定义了一个环境变量会影响到工程中别的Makefile文件，因此要小心。

(3)Makefile中可能有一些环境变量可能是makefile本身自己定义的内部的环境变量或者是当前的执行环境提供的环境变量（譬如我们在make执行时给makefile传参。make CC=arm-linux-gcc，其实就是给当前Makefile传了一个环境变量CC，值是arm-linux-gcc。

 

 

CC = gcc

 

all:

  echo $(CC)

输入：make 

输出： echo gcc

​      gcc

输入：make CC=arm-linux-gcc

输出：echo arm-linux-gcc

​     arm-linux-gcc

 

**我们在make时给makefile传的环境变量值优先级最高的，可以覆盖makefile中的赋值**）。这就好像C语言中编译器预定义的宏__LINE__ __FUNCTION__等一样。

 

 

## 2.2.9.Makefile补充学习2

### 2.2.9.1、Makefile中使用通配符

 

all : 1.c 2.c 12.c test.c 1.h

   echo *.c

   echo ?.c

   echo [12].c

**输出：**

echo *.c

1.c 12.c 2.c test.c

echo ?.c

1.c 2.c

echo [12].c

1.c 2.c

 

(1)*     若干个任意字符

(2)?     1个任意字符

(3)[]    将[]中的**单个字符**依次去和外面的结合匹配

 

还有个%，也是通配符，表示任意多个字符，和*很相似，但是%一般只用于规则描述中，又叫做**规则通配符**。

 

关于通配符，Makefile还有一些wildcard等比较复杂的通配符用法，具体参考《跟我一起学Makefile》即可。

 

### 2.2.9.2、Makefile的自动变量

(1)为什么使用自动变量。在有些情况下文件集合中文件非常多，描述的时候很麻烦，所以我们Makefile就用一些特殊的符号来替代符合某种条件的文件集，这就形成了自动变量。

(2)自动变量的含义：预定义的特殊意义的符号。就类似于C语言编译器中预制的那些宏__FILE__一样。

(3)常见自动变量：

$@     规则的目标文件名

$<     规则的依赖文件名

$^     依赖的文件集合

 

%.o : %.S

  $(CC) $(CPPFLAGS) $(CFLAGS) -o $@ $< -c

$@表示%.o  $<表示%.S

 

  uart.bin:  start.o led.o clock.o uart.o main.o int.o adc.o

​    $(LD) -Tlink.lds -o uart.elf $^

  $^表示start.o led.o clock.o uart.o main.o int.o adc.o文件的集合

 

all : 1.c 2.c 12.c test.c 1.h

   echo $@

   echo $<

   echo $^

 

  输出：

echo all

all

echo 1.c

1.c

echo 1.c 2.c 12.c test.c 1.h

1.c 2.c 12.c test.c 1.h

 

 

 



 

# 第三章 零距离初体验uboot

## 2.3.0 章节概要

**2.3.1.X210官方uboot配置编译实践1**

​    本节课主要讲解了uboot的各种来源版本以及其之间的差异

**2.3.2.X210官方uboot配置编译实践2**

​    本节课使用开发板厂商发布的uboot源码进行配置编译，主要目的是让大家体验配置编译的过程，方便后续去分析。

**2.3.3.uboot的源码目录分析1**

​    本节课开始讲解uboot的目录结构，这节主要是根目录下的单个文件。

**2.3.4.uboot的源码目录分析2**

​    本节课讲述的是uboot目录结构中根目录下的文件夹。

**2.3.5.uboot的源码目录分析3**

​    本节课继续讲述uboot目录结构中根目录下的文件夹。

**2.3.6.SourceInsight的基本使用**

​    本节课介绍SourceInsight软件的基本使用，包括建立工程、添加文件、解析工程、查找文件等。

## 2.3.1.X210官方uboot配置编译实践1

### 2.3.1.1、找到官方移植好的uboot（BSP概念） 

(1)源头的源代码是uboot官网下载的。这个下载的源代码可能没有你当前使用的开发板的移植，甚至找不到当前开发板使用的SoC对应的移植版本。

(2)SoC厂商在推出一款SoC后，厂商的工程师会去uboot官网下载一个uboot，根据自己的SoC进行第一步的移植，移植的目标是厂商 推出的开发板。（譬如三星的S5PV210芯片厂商出的开发板就叫SMDKV210）.所以三星的工程师移植的uboot是根据他们自己的SMDKV210开发板移植的。

(3)具体的开发板供应商（譬如X210的生产商深圳市九鼎科技）首先购买三星的SMDKV210开发板，然后进行裁剪（把一些无用的接口功能裁剪去，配置降低一下，某些配置会被替换）。硬件替换和裁剪之后生成的新的开发板（譬如X210）和三星官方的SMDKV210有所不同，因此uboot也不同。但是因为SoC是相同的，所以相似度至少有60%以上。所以具体开发板供应商会以三星SMDKV210中移植的uboot为蓝本来移植得到自己的开发板的一个uboot移植。我们买X210开发板时厂商光盘中带的BSP中的uboot源码就是他移植过的。

总结：uboot可以有3种获取途径：uboot官方、SoC官方、具体开发板的官方。

 

 

## 2.3.2.X210官方uboot配置编译实践2

### 2.3.2.1、在linux源生目录下配置编译

(1)X210移植过的uboot在开发板光盘的BSP中。

(2)**BSP****就是board support package(板级支持包)**，一般由开发板供应商提供)，里面的内容就是这个开发板的所有相关的源代码、文档、教程等。

(3)将整个BSP打包文件弄到linux的源生目录中去解压分析，不要在windows中的共享文件夹中解压开。（除非你的代码只在windows下去分析而不去编译，如果你想编译工程就一定不要在windows共享文件夹下，否则会出错。

(4)**tar -jxvf qt_x210v3_130807.tar.bz2**

(5)我们在linux下维持一份uboot，在windows下也维持一份uboot，在我们没有开始任何工作之前，这两份uboot内容一样的，都是九鼎官方的uboot 内容。我们这样做目的是：在linux中进行编译、在windwos下进行代码分析和观看。（windwos下有SourceInsight等很好的工具辅助我们看代码、编辑代码，在linux下编译和看代码都很麻烦·····）。

 

### 2.3.2.2、配置

(1)uboot和linux kernel等复杂项目，都不能直接编译，都要先配置才能编译。

(2)uboot也要先配置，配置方法是：首先cd进入uboot源码的根目录，然后在根目录下执行**：make x210_sd_config**。执行配置命令后，如果出现：Configuring for x210_sd board...

说明配置好了，如果不是这个是别的说明配置出错了。

 

### 2.3.2.3、编译得到uboot.bin

(1)编译之前一定要注意检查arm-linux-gcc对不对，检查份2步：

第一步：检查当前编译环境中有没有安装合适的arm-linux-gcc。我们装的是arm-2009q3，因为这个是三星官方、九鼎官方开发uboot时使用的。

第二步：检查当前目录下（uboot根目录）的Makefile中编译器的设置是否正确。在工程的总Makefile中会设置交叉编译工具链的路径和名字，必须确保这个路径和名字和我们自己装的一致，否则编译会出错。

(2)确保了以上2点，即可进行编译。编译很简单，直接make即可。或者可以make -j4 (多线程编译，主机如果是多核心电脑，可以尝试多线程编译，会快一些)

 

 

 

## 2.3.3.uboot的源码目录分析1

### 2.3.3.1、九鼎官方uboot和三星原版uboot对比

(1)以九鼎官方的uboot为蓝本来学习的，以三星官方的这份为对照。

(2)不同版本的uboot或者同一版本不同人移植的uboot，可能目录结构和文件内容都有所不同。将来大家懂了后也可以自己根据需要去添加/删除/更改目录结构。

(3)九鼎在以三星的uboot为原材料进行移植时，把三星版本的uboot中很多不必要的文件夹、文件给删除掉了。这个删除把很多完全用不到的文件清除出去，减少了整体的文件数量，便于工作。

 

### 2.3.3.2、各文件介绍

(1).**gitignore**：git工具的文件，git是一个版本管理工具（类似的还有个svn），这个文件和git有关，和uboot本身无关的，不用去管。

(2)**arm_config.mk**：后缀是.mk，是一个Makefile文件，将来在某个Makefile中会去调用它。

(3)三个**Changelog****文件**，修改记录文件，该文件记录了这个uboot项目的版本变迁以及每个版本较上个版本修改的记录。正式的项目都有这些记录的。可以直接忽略，主要是给维护uboot的人用的。

(4)**config.mk**：和arm_config.mk差不多性质。

(5)**COPYING**: 版权声明，uboot本身是GPL许可证的。

(6)**CREDITS****：**鸣谢，里面记录了对uboot有贡献的人，感谢目录。

(7)**image_split**：一个脚本，看说明是用来分割uboot.bin到BL1的，暂时用不到，先不管。

(8)**MAINTAINERS**：维护者，就是当前在参与维护uboot源码的社区工作者。

(9)**MAKEALL**：一个脚本，应该是帮助编译uboot的。

(10)**Makefile**：**这个很重要**，是uboot源代码的主Makefile，将来整个uboot被编译时就是用这个Makefile管理编译的，所以我们在下个课程中研究uboot配置编译过程时就要分析这个Makefile。

(11)**mk**：快速编译的脚本，其实就是先清理然后配置然后编译而已。

(12)**mkconfig**：这个很重要，**是uboot配置阶段的主要配置脚本**。uboot的可移植性很大程度就是靠这个配置脚本在维护的。我们在下个课程中研究uboot配置编译过程时就要分析这个配置脚本。

(13)**mkmovi**：暂时不去管他，一个脚本，和iNand/SD卡启动有关

(14)**README**：所有的软件都有README，一般拿到一个东西要先读README，这个东西其实就是个简单的使用说明书。

(15**)rules.mk**：这个文件是我们uboot的Makefile使用的规则，本身非常重要，但是我们不去分析他，不去看他。

 

**总结：**以上这些文件中，对我们比较重要，需要认真看的有2个：**mkconfig**和**Makefile**。**一个负责uboot的配置，一个负责编译**。我们在第四部分的课程中会详细讲解分析这两个东西。

 

 

## 2.3.4.uboot的源码目录分析2

(1)**api** ：硬件无关的功能函数的API。uboot移植时基本不用管，这些函数是uboot本身使用的。

(2)**api_examples**：API相关的测试事例代码。

(3)**board**：board是板的意思，板就是开发板。board文件夹下每一个文件都代表一个开发板，这个文件夹下面放的文件就是用来描述这一个开发板的信息的。board目录下有多少个文件夹，就表示当前这个uboot已经被移植到多少个开发板上了（当前的uboot支持多少个开发板）。

**问题一：**思考uboot如何支持多套开发板，如何具有可移植性?(支持很多board)。

**问题二：**board下有这么多文件夹，究竟如何确定具体使用的是哪一个？uboot在配置阶段会有一些手段帮助我们来确定具体使用的是board目录下的哪一个文件夹。（想想为什么不能直接编译而要先配置）。

**问题三：**开发板越来越多，board目录下文件夹越来越多不方便管控。于是乎uboot就

**新增了一种机制**：可以在board目录下不直接放开发板目录，而是在board下放厂家目录（vendor目录，以具体芯片厂商名字命名），然后将这个IC厂商的所有芯片开发板都丢到这个（vendor）目录下面去。所以大家会发现我们X210对应的开发板目录在board/samsung/x210。

多了这层目录会影响配置阶段，在uboot的配置阶段要注意配置时的路径深度和实际存放要对应，不然配置后编译时找不到文件编译就会失败。

**注意一个细节：**就是历史原因造成的兼容性麻烦。最开始时board目录下就是开发板名字，后来才改成厂商名字的。但是因为要向前兼容，同一个厂商原来还是外面的开发板并没有挪移到厂商目录下面去。这样就造成后来的人不知道原委的感到很奇怪，感觉很混乱。

 

**注意：**强调一下，uboot的配置阶段（其实就是根目录下面的mkconfig脚本和Makefile中配置有关的部分）主要解决的问题就是在可移植性领域能够帮助我们确定具体的文件夹的路径，然后编译时可以找到应该找到的文件，才能编译成功。因此board目录下的不同会造成配置时的不同。如果移植时没注意这里肯定要失败。

 

 

## 2.3.5.uboot的源码目录分析3

(4**)common**：common是普遍的普通的，这个文件夹下放的是一些与具体硬件无关的普遍适用的一些代码。譬如控制台实现、crc校验的。但是更多的主要是两类：一类是cmd开头的，是用来实现uboot的命令系统的；另一类是env开头的，是用来实现环境变量的。

(5)**cpu**：这个目录是SoC相关的，里面存放的代码都是SoC相关初始化和控制代码（譬如CPU的、中断的、串口等SoC内部外设的，包括起始代码start.S也在这里）。里面很多子文件夹，每一个子文件夹就是一个SoC系列。

**注意：**这个问价是严格和硬件相关的，因此移植时也是要注意的。但是因为这个文件夹内都是SoC有关的，我们自己的开发板和三星的开发板虽然板子设计不同但是SoC都是同一个，因此实际移 植时这个目录几乎不用动。

(6)**disk**：磁盘有关的，没研究过，没用过。

(7)**doc**：文档目录，里面存放了很多uboot相关文档，这些文档可以帮助我们理解uboot代码。但是因为是纯英文的，而且很杂乱，所以几乎没用。

(8)**drivers**：顾名思义，驱动。这里面放的就是从linux源代码中扣出来的原封不动的linux设备驱动，主要是开发板上必须用到的一些驱动，如网卡驱动、Inand/SD卡、NandFlash等的驱动。要知道：uboot中的驱动其实就是linux中的驱动，uboot在一定程度上移植了linux的驱动给自己用。但是linux是操作系统而uboot只是个裸机程序，因此这种移植会有不同，让我说：uboot中的驱动其实是linux中的驱动的一部分。

(9)**examples**：示例代码，没用过。

(10)**fs****（filesystem）**，文件系统。这个也是从linux源代码中移植过来的，用来管理Flash等资源。

(11)**include**：头文件目录。uboot和linux kernel在管理头文件时都采用了同一个思路，就是把所有的头文件全部集中存放在include目录下，而不是头文件跟着自己对应的c文件。所以在uboot中头文件包含时路径结构要在这里去找。

(12)**lib_****开头的一坨**：典型的lib_arm和lib_generic）架构相关的库文件。譬如lib_arm里面就是arm架构使用的一些库文件。lib_generic里是所有架构通用的库文件。这类文件夹中的内容移植时基本不用管。

(13)**libfdt****：**设备树有关的。linux内核在3.4左右的版本的时候更改了启动传参的机制，改用设备树来进行启动传参，进行硬件信息的描述了。

(14)**nand_spl**：nand相关的，不讲。

(15)**net**：网络相关的代码，譬如uboot中的tftp nfs ping命令 都是在这里实现的。

(16)**onenand**：开头的，是onenand相关的代码，是三星加的，标准uboot中应该是没有的。

(17)**post**：没关注过，不知道干嘛的。

(18)**sd_fusing** ：这里面代码实现了烧录uboot镜像到SD卡的代码。后面要仔细研究的。

(19)**tools**：里面是一些工具类的代码。譬如mkimage。



 

**总结：**文件夹里面比较重要的，后面会分析涉及到的有：**board、common、cpu、drivers、include、lib_arm、lib_generic、sd_fusing**

 

 

## 2.3.6.SourceInsight的基本使用

### 2.3.6.1、为什么要使用SourceInsight

(1)对于一个真正的一个项目，往往有几十几百甚至上万个c文件、h文件，代码量非常大，代码之间关联非常复杂，就带来一个问题，代码的分析、阅读越来越难。譬如这里引用了一个函数但是这个函数可能在另外一个目录下的一个文件夹中存放，这样情况下代码查找和阅读很困难，我们希望有一个好工具能够帮助。于是乎有了SourceInsight。

### 2.3.6.2、建立工程及添加文件

(1)要使用SI看代码，首先要创建一个工程。菜单栏：Project->new project。在弹出的对话框中上面输入工程名字（自己起名字，随便写，但是一般要和工程相对应免得时间长了忘记了），下面输入工程文件存放的位置。

(2)工程项目文件和工程中管理的源代码文件目录可以不同，但是我一般习惯放在一起。放在：C:\winshare\s5pv210\uboot\uboot-jiuding\SI_Proj

点确定，进入new project setting，直接点ok进入下一步。

(3)到了向项目中添加文件的步骤。

在左侧选择uboot-jiuding这个目录，然后点右侧边栏的add tree即可添加，发现添加了1054个文件进去。

(4)本来应该已经结束了，但是有遗留问题。因为SI软件有个特点，它只能发现自己识别了的文件类型，对于它未识别的文件类型它就看不到。譬如start.S文件就未包含在内，因为SI默认不认识.S后缀的文件。

解决方案：第一种是自己配置；第二种是加载我提供的AstonSICFG。

(5)解决了4中的问题然后再次添加文件。菜单栏　Project->Add and Remove Project Files 再次浏览到uboot-jiuding目录下，再次add tree，发现添加了额外的19个文件。

 

### 2.3.6.3、解析工程文件

(1)SI工作原理就是预先把所有源代码中的所有符号全部解析存储到数据库中，然后等我们进行符号查找时，SI不是查文件而是查数据库帮我们索引符号，因此SI查找速度非常快。

(2)因此我们使用SI查阅源码前应该预先进行源码解析。在菜单栏Project->Syneronize Files，选中上面2个，然后确定。

 

### 2.3.6.4、常用技巧



 

# 第四章 uboot配置和编译过程详解

## 2.4.0 章节概要

**2.4.1.uboot主Makefile分析1**

​    本节课开始分析uboot的主Makefile，主要内容是uboot版本号的确定、HOSTARCH、HOSTOS这两个环境变量。

**2.4.2.uboot主Makefile分析2**

​    本节主要讲解uboot的静默编译的实现、本地编译和设置输出目录的编译这两种不同的编译方法。

**2.4.3.uboot主Makefile分析3**

​    本节引入include/config.mk文件，并分析了ARCH、CROSS_COMPILE这两个环境变量。

**2.4.4.uboot主Makefile分析4**

​    本节引入顶层目录下config.mk文件，并分析了autoconfig.mk文件的来源和作用。

**2.4.5.uboot主Makefile分析5**

​    本节介绍链接脚本的引入、TEXT_BASE变量及链接地址的指定、Makefile的自动推导规则等。

**2.4.6.uboot主Makefile分析6**

​    本节介绍主Makefile中剩下的部分，重点介绍了开发板配置的目标和依赖、命令等，这些是我们配置uboot时的重点。

**2.4.7.uboot配置过程详解1**

​    本节分析uboot的配置过程，主要是mkconfig脚本及传给他的6个参数。

**2.4.8.uboot配置过程详解2**

​    本节接上节来继续分析mkconfig脚本，主要是board目录下的config.mk文件的生成和include目录下config.h文件的生成。

**2.4.9.uboot的链接脚本**

​    本节介绍uboot的链接脚本。通过回顾裸机程序中的链接脚本和相关概念帮大家来深入理解uboot的整体结构。

## 2.4.1.uboot主Makefile分析1

### 2.4.1.1、uboot version确定（Makefile的24-29行）

(1)uboot的版本号分3个级别：

VERSION：主板本号

PATCHLEVEL：次版本号

SUBLEVEL：再次版本号

EXTRAVERSION:另外附加的版本信息（一般自己定义）

这4个用.分隔开共同构成了最终的版本号。

U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)

(2)Makefile中版本号最终生成了一个变量U_BOOT_VERSION，这个变量记录了Makefile中配置的版本号。

(3)include/version_autogenerated.h文件是编译过程中自动生成的一个文件，所以源目录中没有，但是编译过后的uboot中就有了。它里面的内容是一个宏定义，宏定义的值内容就是我们在Makefile中配置的uboot的版本号。

(4)验证方法：自己修改主Makefile中几个Version有关的变量，然后重新编译uboot，然后烧录到SD卡中，从SD卡启动，然后去看启动时uboot打印出来的版本信息，看看变化是不是和自己的分析一致。

 

### 2.4.1.2、HOSTARCH和HOSTOS

​    var=`pwd`

var=$(shell pwd)

​    这两种方法是一样的， 都是代表shell中的命令

 

HOSTARCH := $(shell uname -m | \

  sed -e s/i.86/i386/ \

​    -e s/sun4u/sparc64/ \

​    -e s/arm.*/arm/ \

​    -e s/sa110/arm/ \

​    -e s/powerpc/ppc/ \

​    -e s/ppc64/ppc/ \

​    -e s/macppc/ppc/)

 

(1)直接在shell中执行uname -m

得到i686，得到的值其实你当前执行这个命令的电脑的CPU的版本号。

(2)shell中的|叫做管道，管道的作用就是把管道前面一个运算式的输出作为后面一个的输入再去做处理，最终的输出才是我们整个式子的输出。

(3)HOSTARCH这个名字：HOST是主机，就是当前在做开发用的这台电脑就叫主机；ARCH是**architecture(****架构)**的缩写，表示CPU的架构。所以HOSTARCH就表示主机的CPU的架构。

 

HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \

​    sed -e 's/\(cygwin\).*/cygwin/')

 

**把输出的大写字母全部转成小写的。**sed –e‘s/CygwinCygwin.*/Cygwin/’表示寻找结果里面是否有cygwin.*字符，如果有就用cygwin替换。

 

(4)这两个环境变量是主机的操作系统和主机的CPU架构，得出后保存备用，后面自然会用到。

 

 

## 2.4.2.uboot主Makefile分析2

### 2.4.2.2、2种编译方法（原地编译和单独输出文件夹编译）

(1)**编译复杂项目，Makefile提供2种编译管理方法**：1、原地编译；2、文件夹编译

默认情况下是当前文件夹中的.c文件，编译出来的.o文件会放在同一文件夹下。这种方式叫原地编译。原地编译的好处就是处理起来简单。

(2)原地编译有一些坏处：第一，污染了源文件目录。第二的缺陷就是一套源代码只能按照一种配置和编译方法进行处理，无法同时维护2个或2个以上的配置编译方式。

(3)为了解决以上2种缺陷，uboot支持单独输出文件夹方式的编译（linux kernel也支持，而且uboot的这种技术就是从linux kernel学习来的）。基本思路就是在编译时另外指定一个输出目录，将来所有的编译生成的.o文件或生成的其他文件全部丢到那个输出目录下去。源代码目录不做任何污染，这样输出目录就承载了本次配置编译的所有结果。

(4)具体用法：默认的就是原地编译。如果需要指定具体的输出目录编译则有2种方式来指定输出目录。**（具体参考Makefile 56-76行注释内容）**

\#Uboot build supports producing a object files to the separate external

\# directory. Two use cases are supported:

\# 1) Add O= to the make command line

\# 'make O=/tmp/build all'

\# 2) Set environement variable BUILD_DIR to point to the desired location

\# 'export BUILD_DIR=/tmp/build'

\# 'make'

\# The second approach can also be used with a MAKEALL script

\# 'export BUILD_DIR=/tmp/build'

\# './MAKEALL'

\# Command line 'O=' setting overrides BUILD_DIR environent variable.

\# When none of the above methods is used the local build is performed and

\# the object files are placed in the source directory.

 

**第一种：make O=输出目录**   

**第二种：export BUILD_DIR=输出目录 然后再make**

如果两个都指定了（既有BUILD_DIR环境变量存在，又有O=xx），则O=xx具有更高优先级，听他的。

(5)**两种编译的实现代码在Makefile的78-123行**。

ifdef O                  

ifeq ("$(origin O)", "command line")     #命令行里有“O” ，这个O定义的目录 是在shell 中make -O=/output… 所定义的。

BUILD_DIR := $(O)              #BUILD_DIR指定为命令中的目录

endif

endif

 

ifneq ($(BUILD_DIR),)            #如果BUILD_DIR有定义 不等于空

saved-output := $(BUILD_DIR)        #saved-output保存$(BUILD_DIR)

 

\# Attempt to create a output directory.

$(shell [ -d ${BUILD_DIR} ] || mkdir -p ${BUILD_DIR})

\#此条命令——检测BUILD_DIR是否是一个目录，如果不存在则创建这个BUILD_DIR对应的目录

\#[]和test测试命令一样，Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试；

\#-d的作用——如果文件存在且为目录则为真；

\#||运算符——如果||左边的命令（命令1）未执行成功，那么就执行||右边的命令（命令2）；或者换句话说，“如果这个命令执行失败了||那么就执行这个命令。

\#mkdir的-p参数——需要时创建上层目录，如目录早已存在则不当作错误，例如，我们要在当前目录创建目录Projects/a/src，

\#使用命令mkdir -p Project/a/src，例如想要建立目录Project，其中含有4个文件夹a, b, c, d，且这4个文件都含有一个src文件夹。

\#使用命令mkdir -p Project/{a,b,c,d}/src

\# Verify if it was successful.

BUILD_DIR := $(shell cd $(BUILD_DIR) && /bin/pwd)  

\#如果能cd $(BUILD_DIR)，则输出这个目录的路径

\#&&运算符——左边的命令（命令1）返回真(即返回0，成功被执行）后，&&右边的命令（命令2）才能够被执行；

\#换句话说，“如果这个命令执行成功&&那么执行这个命令”。 

$(if $(BUILD_DIR),,$(error output directory "$(saved-output)" does not exist))

\#检测BUILD_DIR是否为空，如果为空则提示错误并终止make

\#if函数——$(if CONDITION,THEN-PART[,ELSE-PART]). 可见，if 函数可以包含“else”部分，或是不含。即 if 函数的参数可以是两个，也可以是三个。<condition>参数是 if 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part>会被计算。如果“CONDITION”的展开结果非空，则将第二个；参数“THEN-PART”作为函数计算表达式；“CONDITION”的展开结果为空，则执行第三个参数。  意思为： 当BUILD_DIR 不为空，什么也不执行，为空的话则执行error函数；

\#error——$(error TEXT...)产生致命错误，并提示“TEXT...”信息给用户，并退出make执行，没有返回值。

endif # ifneq ($(BUILD_DIR),)

 

OBJTREE    := $(if $(BUILD_DIR),$(BUILD_DIR),$(CURDIR)) 

\#如果定义了BUILD_DIR则OBJTREE=$(BUILD_DIR)，否则=$(CURDIR)

SRCTREE    := $(CURDIR)                 #源目录为$(CURDIR) CURDIR 本身就被定义，就是执行makefile的当前文件夹

TOPDIR    := $(SRCTREE)                 #顶层目录为$(CURDIR)

LNDIR    := $(OBJTREE)                 #链接目录为$(CURDIR)

export  TOPDIR SRCTREE OBJTREE

 

MKCONFIG  := $(SRCTREE)/mkconfig

export MKCONFIG

 

ifneq ($(OBJTREE),$(SRCTREE))

REMOTE_BUILD   := 1

export REMOTE_BUILD

endif

 

\# $(obj) and (src) are defined in config.mk but here in main Makefile

\# we also need them before config.mk is included which is the case for

\# some targets like unconfig, clean, clobber, distclean, etc.

ifneq ($(OBJTREE),$(SRCTREE)) #如果$(OBJTREE)不等于$(SRCTREE)

obj := $(OBJTREE)/

src := $(SRCTREE)/

else

obj :=

src :=

endif

export obj src

### 2.4.2.3、拓展——origin函数

 origin 函数
 origin 函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪.
 里来的？其语法是：
 $(origin <variable>)
 注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用 
 “$”字符。Origin 函数会以其返回值来告诉你这个变量的“出生情况”，下面，是 origin
 函数的返回值:
 第 51 页共 78 页 2005 年 10 月 14 日整理：祝冬华
 跟我一起写 Makefile 作者：陈皓
 “undefined”**
** 如果<variable>从来没有定义过，origin 函数返回这个值“undefined”。
 “default”**
** 如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面
 讲述。 environment” 如果<variable>是一个环境变量， 并且当 Makefile 被执行时， “-e”
 参数没有被打开。
 “file”**
** 如果<variable>这个变量被定义在 Makefile 中。
 “command line”**
** 如果<variable>这个变量是被命令行定义的。
 “override”**
** 如果<variable>是被 override 指示符重新定义的。
 “automatic”**
** 如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。
 这些信息对于我们编写 Makefile 是非常有用的，例如，假设我们有一个 Makefile 其包
 了一个定义文件 Make.def，在 Make.def 中定义了一个变量“bletch”，而我们的环境中也
 有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把
 之重定义了，如果来源于 Make.def 或是命令行等非环境的，那么我们就不重新定义它。于
 是，在我们的 Makefile 中，我们可以这样写：
 ifdef bletch
 ifeq "$(origin bletch)" "environment"
 bletch = barf, gag, etc.
 endif
 endif
 当然，你也许会说，使用 override 关键字不就可以重新定义环境中的变量了吗？为什
 么需要使用这样的步骤？是的，我们用 override 是可以达到这样的效果，可是 override
 第 52 页共 78 页 2005 年 10 月 14 日整理：祝冬华
 跟我一起写 Makefile 作者：陈皓
 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而
 不想重新定义命令行传来的。

 

### 2.4.2.1、静默编译（50-54行）

 

\# Allow for silent builds

ifeq (,$(findstring s,$(MAKEFLAGS)))

XECHO = echo

else

XECHO = :

endif

 

MAKEFLAGS 是一个make 后面跟的一个标识，findstring s找到这个标识为s。

Ifeq（）里还有个**“,”**,这个**“,”**后面得到的字符和前面的空进行比较，如果是空的话执行EXCHO =echo 

(1)平时默认编译时命令行会打印出来很多编译信息。但是有时候我们不希望看到这些编译信息，就后台编译即可。这就叫静默编译。

(2)使用方法就是编译时**make -s**，-s会作为MAKEFLAGS传给Makefile，在50-54行这段代码作用下XECHO变量就会被变成空（默认等于echo），于是实现了静默编译。

 

关于makefile知识点：

条件判断：主makefile50行 ：ifeq (,$(findstring s,$(MAKEFLAGS)))

《跟我一起学Makefile》第42页：

条件表达式的语法为：

<conditional-directive>

<text-if-true>

endif

 

以及

<conditional-directiv>

<text-if-ture>

else

<text-if-false>

endif

其中<conditional-directiv>表示条件关键字，如“ifeq”。

 

第一个关键字ifeq：

ifeq(<arg1>, <arg2>)

ifeq 'arg1' 'arg2'
 ifeq “arg1” 'arg2'

ifeq 'arg1' ”arg2”

ifeq ”arg1” “arg2”

比较参数“arg1” 和“arg2”的值是否相同。相同为真。

 

 

第二个关键字ifneq：

ifneq (<arg1>, <arg2>)

ifneq 'arg1' 'arg2'

ifneq “arg1” 'arg2'

ifneq 'arg1' ”arg2”

ifneq ”arg1” “arg2”

比较参数“arg1” 和“arg2”的值是否相同。不同为真。

 

第三个关键字ifdef:

ifdef <variable-name>

如果变量的值非空，那么表达式为真，否则为假。

 

findstring函数

函数调用语法：

$(<funciton> <arguments>)

或者

${<function> <arguments>}

 

$(findstring <find>, <in>)

功能：在字串<in>中查找<find>字串。

返回：如果找到，那么返回<find>,否则返回空字符串。

 

所以这里ifeq (,$(findstring s,$(MAKEFLAGS)))

这里的意思就是如果findstring函数的返回值为空。如果为空，那么ifeq函数的两个参数相等，条件判断为真。执行<text-if-true>.

引用：https://www.cnblogs.com/yr-linux/p/5361885.html

 

### 2.4.2.4拓展——shell中的括号（小括号，中括号，大括号）

 

**一、小括号,园括号（）**

 **1、单小括号 ()**

  ①命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。

  ②命令替换。等同于`cmd`，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。

  ③用于初始化数组。如：array=(a b c d)。

 **2、双小括号 ((  ))**

  ①整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是"假"，而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为1,假则为0。

  ②只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)

  ③单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6

  ④双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。

if ($i<5)

if [ $i -lt 5 ]

if [ $a -ne 1 -a $a != 2 ]

if [ $a -ne 1] && [ $a != 2 ]

if [[ $a != 1 && $a != 2 ]]

 

for i in $(seq 0 4);do echo $i;done

for i in `seq 0 4`;do echo $i;done

for ((i=0;i<5;i++));do echo $i;done

for i in {0..4};do echo $i;done

**二）中括号，方括号[]**

 **1****、单中括号 []**

  ①bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。

  ②Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：[ ab \< bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。

  ③字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。

  ④在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。

 **2****、双中括号[[ ]]**

  ①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。

  ②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。

  ③使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。

  ④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。

**三）大括号、花括号 {}**

 **1****、常规用法。**

  ①大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt

bogon:/home/bash # ls {ex1,ex2}.sh

ex1.sh ex2.sh

bogon:/home/bash # ls {ex{1..3},ex4}.sh

ex1.sh ex2.sh ex3.sh ex4.sh

bogon:/home/bash # ls {ex[1-3],ex4}.sh

ex1.sh ex2.sh ex3.sh ex4.sh

  ②代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。

  2）几种特殊的替换结构：${var:-string},${var:+string},${var:=string},${var:?string}

   A,${var:-string}和${var:=string}:若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}；对于${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，用string替换${var:=string}的同时，把string赋给变量var： ${var:=string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。

   B. ${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 

   C,${var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。

   补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。

 3）四种模式匹配替换结构：${var%pattern},${var%%pattern},${var#pattern},${var##pattern}

   第一种模式：${variable%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式

   第二种模式： ${variable%%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式

   第三种模式：${variable#pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式

   第四种模式： ${variable##pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式

   这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，*表示零个或多个任意字符，?表示零个或一个任意字符，[...]表示匹配中括号里面的字符，[!...]表示不匹配中括号里面的字符

bogon:/home/bash # var=testcase

bogon:/home/bash # echo $var

testcase

bogon:/home/bash # echo ${var%s*e}

testca

bogon:/home/bash # echo $var

testcase

bogon:/home/bash # echo ${var%%s*e}

te

bogon:/home/bash # echo ${var#?e}

stcase

bogon:/home/bash # echo ${var##?e}

stcase

bogon:/home/bash # echo ${var##*e}

 

bogon:/home/bash # echo ${var##*s}

e

bogon:/home/bash # echo ${var##test}

 

————————————————

版权声明：本文为CSDN博主「雪影」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/tttyd/article/details/11742241

 

 

 

## 2.4.3.uboot主Makefile分析3

### 2.4.3.1、OBJTREE、SRCTREE、TOPDIR

(1)**OBJTREE**：编译出的.o文件存放的目录的根目录。在默认编译下，OBJTREE等于当前目录；在O=xx编译下，OBJTREE就等于我们设置的那个输出目录。

(2)**SRCTREE**: 源码目录，其实就是源代码的根目录，也就是当前目录。

总结：在默认编译下，OBJTREE和SRCTREE相等；在O=xx这种编译下OBJTREE和SRCTREE不相等。Makefile中定义这两个变量，其实就是为了记录编译后的.o文件往哪里放，就是为了实现O=xx的这种编译方式的。

### 2.4.3.2、MKCONFIG（Makefile的101行）

(1)Makefile中定义的一个变量（在这里定义，在后面使用），它的值就是我们源码根目录下面的mkconfig。这个mkconfig是一个脚本，这个脚本就是uboot配置阶段的配置脚本。后面要用至少3节课详细讲这个配置脚本的工作。

### 2.4.3.3、include $(obj)include/config.mk（133行）

 

ifeq ($(ARCH),powerpc)

ARCH = ppc

endif

 

ifeq ($(obj)include/config.mk,$(wildcard $(obj)include/config.mk))

 

\# load ARCH, BOARD, and CPU configuration

include $(obj)include/config.mk

export ARCH CPU BOARD VENDOR SOC

​    

(1)include/config.mk不是源码自带的（你在没有编译过的源码目录下是找不到这个文件的），要在配置过程（make x210_sd_config）中才会生成这个文件。因此这个文件的值和我们配置过程有关，是由配置过程根据我们的配置自动生成的。

(2)我们X210在iNand情况下配置生成的config.mk内容为：

ARCH  = arm

CPU  = s5pc11x

BOARD = x210

VENDOR = samsung

SOC  = s5pc110

(3)我们在下一行（134行）export导出了这5个变量作为环境变量。所以着两行加起来其实就是为当前makefile定义了5个环境变量而已。之所以不直接给出这5个环境变量的值，是因为我们希望这5个值是可以被人很容易的、集中的配置的。

(4)这里的配置值来自于2589行那里的配置项。如果我们要更改这里的某个配置值要到2589行那里调用MKCONFIG脚本传参时的参数。

 

### 2.4.3.4、ARCH CROSS_COMPILE

(1)接下来有2个很重要的环境变量。一个是ARCH，上面导出的，值来自于我们的配置过程，它的值会影响后面的CROSS_COMPILE环境变量的值。**ARCH的意义是定义当前编译的目标CPU的架构。**

(2)**CROSS_COMPILE****是定义交叉编译工具链的前缀的**：定义这些前缀是为了在后面用（用前缀加上后缀来定义编译过程中用到的各种工具链中的工具）。我们把前缀和后缀分开还有一个原因就是：在不同CPU架构上的交叉编译工具链，只是前缀不一样，后缀都是一样的。因此定义时把前缀和后缀分开，只需要在定义前缀时区分各种架构即可实现可移植性。

 

ifndef CROSS_COMPILE

ifeq ($(HOSTARCH),$(ARCH))

CROSS_COMPILE =

else

ifeq ($(ARCH),ppc)

CROSS_COMPILE = ppc_8xx-

endif

ifeq ($(ARCH),arm)

\#CROSS_COMPILE = arm-linux-

\#CROSS_COMPILE = /usr/local/arm/4.4.1-eabi-cortex-a8/usr/bin/arm-linux-

\#CROSS_COMPILE = /usr/local/arm/4.2.2-eabi/usr/bin/arm-linux-

CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-、、gnueabi-

endif

ifeq ($(ARCH),i386)

CROSS_COMPILE = i386-linux-

endif

ifeq ($(ARCH),mips)

CROSS_COMPILE = mips_4KC-

endif

ifeq ($(ARCH),nios)

CROSS_COMPILE = nios-elf-

endif

ifeq ($(ARCH),nios2)

CROSS_COMPILE = nios2-elf-

endif

ifeq ($(ARCH),m68k)

CROSS_COMPILE = m68k-elf-

endif

ifeq ($(ARCH),microblaze)

CROSS_COMPILE = mb-

endif

ifeq ($(ARCH),blackfin)

CROSS_COMPILE = bfin-uclinux-

endif

ifeq ($(ARCH),avr32)

CROSS_COMPILE = avr32-linux-

endif

ifeq ($(ARCH),sh)

CROSS_COMPILE = sh4-linux-

endif

ifeq ($(ARCH),sparc)

CROSS_COMPILE = sparc-elf-

endif  # sparc

endif  # HOSTARCH,ARCH

endif  # CROSS_COMPILE

 

export CROSS_COMPILE

 

 

(3)**CROSS_COMPILE****在136-182行来确定**：CROSS_COMPILE是被ARCH所确定的，只要配置了ARCH=arm，那么我们就只能在ARM的那个分支去设置CROSS_COMPILE的值。这个设置值只要能保证找到那个交叉编译工具链即可，不一定非得是全路径的，相对路径也可以。（如果已经将工具链导出到环境变量，并且设置了符号链接，这样CROSS_COMPILE = arm-linux-就可以）。

(4)实际运用时，我们可以在Makefile中去更改设置CROSS_COMPILE的值，也可以在编译时用make CROSS_COMPILE=xxxx来设置，而且编译时传参的方法可以覆盖Makefile里面的设置。

 

## 2.4.4.uboot主Makefile分析4

### 2.4.4.1、$(TOPDIR)/config.mk（主Makefile的185行）

\# load other configuration

include $(TOPDIR)/config.mk

这句话相当于将 $(TOPDIR)/目录下的config.mk 中的内容导入进来

1、引用其它的 Makefile**
** 在 Makefile 使用 include 关键字可以把别的 Makefile 包含进来，这很像 C 语言的
 \#include，被包含的文件会原模原样的放在当前文件的包含位置。include 的语法是：

include <filename>
 filename 可以是当前操作系统 Shell 的文件模式（可以保含路径和通配符） 在 include
 前面可以有一些空字符，但是绝不能是[Tab]键开始。include 和<filename>可以用一个或
 多个空格隔开。举个例子，你有这样几个 Makefile：a.mk、b.mk、c.mk，还有一个文件叫
 foo.make，以及一个变量$(bar)，其包含了 e.mk 和 f.mk，那么，下面的语句：
 include foo.make *.mk $(bar)
 等价于：
 include foo.make a.mk b.mk c.mk e.mk f.mk
 make 命令开始时，会把找寻 include 所指出的其它 Makefile，并把其内容安置在当前
 的位。就好像 C/C++的#include 指令一样。如果文件都没有指定绝对路径或是相对路径的话，
 make 会在当前目录下首先寻找，如果当前目录下没有找到，那么，make 还会在下面的几个
 目录下找：
 1、如果 make 执行时，有“-I”或“--include-dir”参数，那么 make 就会在这个参数
 所指定的目录下去寻找。
 2、如果目录<prefix>/include（一般是：/usr/local/bin 或/usr/include）存在的话，
 make 也会去找。如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致
 命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找
 到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make**
** 不理那些无法读取的文件，而继续执行，你可以在 include 前加一个减号“-”。
 第 15 页共 78 页 2005 年 10 月 14 日整理：祝冬华
 跟我一起写 Makefile 作者：陈皓
 如： -include <filename>**
** 其表示，无论 include 过程中出现什么错误，都不要报错继续执行。和其它版本 make**
** 兼 容的相关命令是 sinclude，其作用和这一个是一样的。

### 2.4.4.2、编译工具定义（config.mk 94-107行）

\# Include the make variables (CC, etc...)

\#

AS = $(CROSS_COMPILE)as

LD = $(CROSS_COMPILE)ld

CC = $(CROSS_COMPILE)gcc

CPP = $(CC) -E

AR = $(CROSS_COMPILE)ar

NM = $(CROSS_COMPILE)nm

LDR = $(CROSS_COMPILE)ldr

STRIP  = $(CROSS_COMPILE)strip

OBJCOPY = $(CROSS_COMPILE)objcopy

OBJDUMP = $(CROSS_COMPILE)objdump

RANLIB = $(CROSS_COMPILE)RANLIB

 

### 2.4.4.3、包含开发板配置项目（config.mk, 112行）

\# Load generated board configuration

sinclude $(OBJTREE)/include/autoconf.mk

 

(1)**autoconfig.mk**文件不是源码提供的，是配置过程自动生成的。

(2)这个文件的作用就是用来指导整个uboot的编译过程。这个文件的内容其实就是很多CONFIG_开头的宏（可以理解为变量），这些宏/变量会影响我们uboot编译过程的走向（原理就是条件编译）。在uboot代码中有很多地方使用条件编译进行编写，这个条件编译是用来实现可移植性的。（可以说uboot的源代码在很大程度来说是拼凑起来的，同一个代码包含了各种不同开发板的适用代码，用条件编译进行区别。）

(3)这个文件不是凭空产生的，配置过程也是需要原材料来产生这个文件的。原材料在源码目录的inlcude/configs/xxx.h头文件。**（X210开发板中为include/configs/x210_sd.h）**。这个h头文件里面全都是宏定义，这些宏定义就是我们对当前开发板的移植。每一个开发板的移植都对应这个目录下的一个头文件，这个头文件里每一个宏定义都很重要，这些配置的宏定义就是我们移植uboot的关键所在。

 

 

## 2.4.5.uboot主Makefile分析5

### 2.4.5.1、链接脚本（config.mk 142-149行）

 

ifndef LDSCRIPT

\#LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds.debug

ifeq ($(CONFIG_NAND_U_BOOT),y)

LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot-nand.lds

else

LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds

endif

endif

(1)如果定义了CONFIG_NAND_U_BOOT宏，则链接脚本叫u-boot-nand.lds，如果未定义这个宏则链接脚本叫u-boot.lds。

v(2)从字面意思分析，即可知：CONFIG_NAND_U_BOOT是在Nand版本情况下才使用的，我们使用的X210都是iNand版本的，因此这个宏没有的。

(3)实际在board\samsung\x210目录下有u-boot.lds，这个就是链接脚本。我们在分析uboot的编译链接过程时就要考虑这个链接脚本。

 

### 2.4.5.2、TEXT_BASE（config.mk 156-158行）

 

ifneq ($(TEXT_BASE),)

CPPFLAGS += -DTEXT_BASE=$(TEXT_BASE)

endif

 

(1)Makefile中在配置X210开发板时，在board/samsung/x210目录下生成了一个文件config.mk，其中的内容就是：TEXT_BASE = 0xc3e00000相当于定义了一个变量。

(2)TEXT_BASE是将来我们整个uboot链接时指定的链接地址。因为uboot中启用了虚拟地址映射，因此这个C3E00000地址就等于0x23E00000(也可能是33E00000具体地址要取决于uboot中做的虚拟地址映射关系)。

(3)回顾裸机中讲的链接地址的问题，再想想dnw方式先下载x210_usb.bin然后再下载uboot.bin时为什么第二个地址是23E00000.

 

### 2.4.5.3、自动推导规则（config.mk 239-256行）

ifndef REMOTE_BUILD

 

%.s:  %.S

  $(CPP) $(AFLAGS) -o $@ $<

%.o:  %.S

  $(CC) $(AFLAGS) -c -o $@ $<

%.o:  %.c

  $(CC) $(CFLAGS) -c -o $@ $<

 

else

 

$(obj)%.s: %.S

  $(CPP) $(AFLAGS) -o $@ $<

$(obj)%.o: %.S

  $(CC) $(AFLAGS) -c -o $@ $<

$(obj)%.o: %.c

  $(CC) $(CFLAGS) -c -o $@ $<

endif

 

 

(1)我们在讲Makefile时提到过自动推导规则，具体理解可以参考《跟我一起学Makefile》

 

## 2.4.6.uboot主Makefile分析6

ALL += $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND) $(U_BOOT_ONENAND) $(obj)u-boot.dis

ifeq ($(ARCH),blackfin)

ALL += $(obj)u-boot.ldr

endif

 

all:    $(ALL)

 

(1)291行出现了整个主Makefile中第一个目标all（也就是默认目标，我们直接在uboot根目录下make其实就等于make all，就等于make这个目标）.

(2)目标中有一些比较重要的。譬如：u-boot是最终编译链接生成的elf格式的可执行文件，

 

unconfig:

  @rm -f $(obj)include/config.h $(obj)include/config.mk \

​    $(obj)board/*/config.tmp $(obj)board/*/*/config.tmp \

​    $(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep \

​    $(obj)board/$(VENDOR)/$(BOARD)/config.mk

 

(3)unconfig字面意思来理解就是未配置。这个符号用来做为我们各个开发板配置目标的依赖。目标是当我们已经配置过一个开发板后再次去配置时还可以配置。

 

x210_sd_config :  unconfig

  @$(MKCONFIG) $(@:_config=) arm s5pc11x x210 samsung s5pc110

  @echo "TEXT_BASE = 0xc3e00000" > $(obj)board/samsung/x210/config.mk

 

(4)我们配置开发板时使用：make x210_sd_config，因此分析x210_sd_config肯定是主Makefile中的一个目标。

 

 

## 2.4.7.uboot配置过程详解1

(1)mkconfig脚本的6个参数

$(@:_config=)  arm  s5pc11x x210  samsung  s5pc110

 

**x210_sd_config****里的_config部分用空替换，得到：x210_sd，这就是第一个参数，所以：**

 

 

[ "${BOARD_NAME}" ] || BOARD_NAME="$1"

 

(2)第23行：其实就是看BOARD_NAME变量是否有值，如果有值就维持不变；如果无值就给他赋值为$1，实际分析结果：BOARD_NAME=x210_sd

[ $# -lt 4 ] && exit 1

[ $# -gt 6 ] && exit 1

(3)第25行：如果$#小于4，则exit 1（mkconfig脚本返回1）

(4)第26行：如果$#大于6，则也返回1.

所以：mkconfig脚本传参只能是4、5、6，如果大于6或者小于4都不行。

\# Create link to architecture specific headers

\#

if [ "$SRCTREE" != "$OBJTREE" ] ; then

  mkdir -p ${OBJTREE}/include

  mkdir -p ${OBJTREE}/include2

  cd ${OBJTREE}/include2

  rm -f asm

  ln -s ${SRCTREE}/include/asm-$2 asm

  LNPREFIX="../../include2/asm/"

  cd ../include

  rm -rf asm-$2

  rm -f asm

  mkdir asm-$2

  ln -s asm-$2 asm

else

  cd ./include

  rm -f asm

  ln -s asm-$2 asm

fi

if [ -z "$6" -o "$6" = "NULL" ] ; then

  ln -s ${LNPREFIX}arch-$3 asm-$2/arch

else

  ln -s ${LNPREFIX}arch-$6 asm-$2/arch

fi

 

​    ………

\# create link for s5pc11x SoC

if [ "$3" = "s5pc11x" ] ; then

​    rm -f regs.h

​    ln -s $6.h regs.h

​    rm -f asm-$2/arch

​    ln -s arch-$3 asm-$2/arch

fi

​    …………

(5)从第33行到第118行，都是在创建符号链接。为什么要创建符号链接？这些符号链接文件的存在就是整个配置过程的核心，这些符号链接文件（文件夹）的主要作用是给头文件包含等过程提供指向性连接。根本目的是让uboot具有可移植性。

**uboot****可移植性的实现原理：**在uboot中有很多彼此平行的代码，各自属于各自不同的架构/CPU/开发板，我们在具体到一个开发板的编译时用符号连接的方式提供一个具体的名字的文件夹供编译时使用。这样就可以在配置的过程中通过不同的配置使用不同的文件，就可以正确的包含正确的文件。

 

(6)创建的符号链接：

**第一个：**在include目录下创建asm文件，指向asm-arm。（46-48行）

**第二个：**在inlcude/asm-arm下创建一个arch文件，指向include/asm-arm/arch-s5pc110

**第三个：**在include目录下创建regs.h文件，指向include/s5pc110.h ,**删除第二个。**

**第四个：**在inlcude/asm-arm下创建一个arch文件，指向include/asm-arm/arch-s5pc11x

**第五个：**在include/asm-arm下创建一个proc文件，指向include/asm-arm/proc-armv

 

总结：一共创建了4个符号链接。这4个符号链接将来在写代码过程中，头文件包含时非常有用。譬如一个头文件包含可能是：#include <asm/xx.h>

 

 

## 2.4.8.uboot配置过程详解2

\# Create include file for Make

\#

echo "ARCH  = $2" > config.mk #一个箭头是创建

echo "CPU  = $3" >> config.mk #两个箭头是追加

echo "BOARD = $4" >> config.mk

 

[ "$5" ] && [ "$5" != "NULL" ] && echo "VENDOR = $5" >> config.mk

 

[ "$6" ] && [ "$6" != "NULL" ] && echo "SOC  = $6" >> config.mk

 

(1)创建include/config.mk文件（mkconfig文件123-129行）

(2)创建include/config.mk文件是为了让主Makefile在第133行去包含的（详解见2.4.3.3节）。

(3)**思考：**uboot的配置和编译过程的配合。编译的时候需要ARCH=arm、CPU=xx等这些变量来指导编译，配置的时候就是为编译阶段提供这些变量。那为什么不在Makefile中直接定义这些变量去使用，而要在mkconfig脚本中创建config.mk文件然后又在Makefile中include这些文件呢？

(4)理解这些脚本时，时刻要注意自己当前所处的路径。

 

\# Create board specific header file

\#

if [ "$APPEND" = "yes" ]  # Append to existing config file

then

  echo >> config.h

else

  \> config.h   # Create new config file

fi

echo "/* Automatically generated - do not edit */" >>config.h

echo "#include <configs/$1.h>" >>config.h

 

exit 0

 

(5)创建（默认情况）/追加（make -a时追加）include/config.h文件（mkconfig文件的134-141行）。

(6)这个文件里面的内容就一行#include <configs/x210_sd.h>，这个头文件是我们移植x210开发板时，对开发板的宏定义配置文件。这个文件是我们移植x210时最主要的文件。

(7)x210_sd.h文件会被用来生成一个autoconfig.mk文件，这个文件会被主Makefile引入，指导整个编译过程。这里面的这些宏定义会影响我们对uboot中大部分.c文件中一些条件编译的选择。从而实现最终的可移植性。

 

**注意：**uboot的整个配置过程，很多文件之间是有关联的（有时候这个文件是在那个文件中创建出来的；有时候这个文件被那个文件包含进去；有时候这个文件是由那个文件的内容生成的决定的）

**注意：**uboot中配置和编译过程，所有的文件或者全局变量都是字符串形式的（不是指的C语言字符串的概念，指的是都是字符组成的序列）。**这意味着我们整个uboot的配置过程都是字符串匹配的，所以一定要细节，注意大小写，要注意不要输错字符，因为一旦错一个最后会出现一些莫名其妙的错误，很难排查，这个是uboot移植过程中新手来说最难的地方。**

 

 

## 2.4.9.uboot的链接脚本

 

OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")

/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/

OUTPUT_ARCH(arm)

ENTRY(_start)

SECTIONS

{

​    . = 0x00000000;

 

​    . = ALIGN(4);            //内存4字节对齐

​    .text   :

​    {

​     cpu/s5pc11x/start.o  (.text)

​     cpu/s5pc11x/s5pc110/cpu_init.o   (.text)

​     board/samsung/x210/lowlevel_init.o   (.text)

​     cpu/s5pc11x/onenand_cp.o   (.text)         

​     cpu/s5pc11x/nand_cp.o (.text)           

​     cpu/s5pc11x/movi.o (.text) 

​     common/secure_boot.o (.text) 

​     common/ace_sha1.o (.text)

​     cpu/s5pc11x/pmic.o (.text)

​     *(.text)

​    }

 

​    . = ALIGN(4);            

​    .rodata : { *(.rodata) }      //只读数据段

 

​    . = ALIGN(4);

​    .data : { *(.data) }         //数据段

 

​    . = ALIGN(4);

​    .got : { *(.got) }          //自定义段

​    __u_boot_cmd_start = .;       

​    .u_boot_cmd : { *(.u_boot_cmd) }    //自定义段

​    __u_boot_cmd_end = .;           //自定义段

​    . = ALIGN(4);

​    .mmudata : { *(.mmudata) }        //自定义段

​    . = ALIGN(4);

​    __bss_start = .;

​    .bss : { *(.bss) }

​    _end = .;

}

(1)uboot的链接脚本和我们之前裸机中的链接脚本并没有本质区别，只是复杂度高一些，文件多一些，使用到的技巧多一些。

(2)**ENTRY(_start)**用来指定整个程序的入口地址。所谓入口地址就是整个程序的开头地址，可以认为就是整个程序的第一句指令。有点像C语言中的main。_start相当于一个函数.

(3)之前在裸机中告诉大家，指定程序的链接地址有2种方法：

**一种:**是在Makefile中ld的flags用-Ttext 0x20000000来指定；

**第二种:**是在链接脚本的SECTIONS开头用.=0x20000000来指定。

两种都可以实现相同效果。其实，这两种技巧是可以共同配合使用的，也就是说既在链接脚本中指定也在ld flags中用-Ttext来指定。两个都指定以后以-Ttext指定的为准。

(4)uboot的最终链接起始地址就是在Makefile中用-Ttext 来指定的，具体参见2.4.5.2节，注意TEXT_BASE变量。最终来源是Makefile中配置对应的命令中，在make xxx_config时得到的。

(5)在代码段中注意文件排列的顺序。指定必须放在前面部分的那些文件就是那些必须安排在前16KB内的文件，这些文件中的函数在前16KB会被调用。在后面第二部分（16KB之后）中调用的程序，前后顺序就无所谓了。

(6)链接脚本中除了.text .data .rodata .bss段等编译工具自带的段之外，编译工具还允许我们自定义段。譬如uboot总的.u_boot_cmd段就是自定义段。自定义段很重要。

 



 

# 第五章 源码分析1-启动第一阶段

## 2.5.0 章节概要

**2.5.1.start.S引入**

​    本节首先通过分析链接脚本找到start.S文件，然后讲解了如何利用SourceInsight找到相应文件的技巧。

**2.5.2.start.S解析1**

​    本节开始分析start.S文件，主要分析了文件开头部分的几个头文件包含，通过这些头文件包含将代码和前面课程中讲到的配置过程关联起来。

**2.5.3.start.S解析2**

​    本节主要分析了uboot从SD/Nand等启动时的16字节校验头和异常向量表的建立，以及其他一些符号等。

**2.5.4.start.S解析3**

​    本节介绍了复位后设置CPU为SVC32模式、cache和mmu设置、读取OMpin以判断启动介质选择等功能代码。

**2.5.5.start.S解析4**

​    本节分析了lowlevel_init.S中的起始部分，包括检测复位状态、IO恢复、关看门狗、开发板供电锁存等。

**2.5.6.start.S解析5**

​    本节重点解析了判断当前运行地址的代码片段，这个判断方法和裸机中讲解的方式有所不同。然后简要分析了汇编初始化时钟的代码段。

**2.5.7.start.S解析6**

​    本节重点讲解低层初始化中DDR初始化和串口初始化部分的代码，并且告诉大家uboot启动时的"OK"是如何打印出来的。

**2.5.8.start.S解析7**

​    总结lowlevel_init函数中的所有工作，并且返回start.S中继续分析并引出了uboot第二阶段的重定位部分。

**2.5.9.uboot重定位详解**

​    本节讲解uboot的重定位代码copy_bl2函数，和裸机中SD卡重定位一节相对照应该是很容易理解的。

**2.5.10.start.S解析8**

​    本节开始讲解MMU和虚拟地址映射，主要是虚拟地址映射的基本理论和实现原理、cache的作用等。

**2.5.11.start.S解析9**

​    本节分析启动代码中段式页表建立的过程代码，通过简单分析让大家学会看页表表项，从中可以看出内存映射关系。

**2.5.12.start.S解析10**

​    本节完成页表的讲解和总结，清楚明白的让大家看到X210中虚拟地址映射的图标，同时结束MMU相关的部分。

**2.5.13.start.S解析11**

​    本节讲述start.S中最后的部分，包括清理bss段等，以及最终跳转到uboot第二阶段的代码。本章结束。

## 2.5.1.start.S引入

### 2.5.1.1、u-boot.lds中找到start.S入口

(1)在C语言中整个项目的入口就是main函数（这是C语言规定的），所以譬如说一个有10000个.c文件的项目，第一个要分析的文件就是包含了main函数的那个文件。

(2)在uboot中因为有汇编阶段参与，因此不能直接找main.c。整个程序的入口取决于链接脚本中ENTRY声明的地方。ENTRY(_start)因此_start符号所在的文件就是整个程序的起始文件，_start所在处的代码就是整个程序的起始代码。

 

### 2.5.1.2、SourceInsight中如何找到文件

(1)当前状况：我们知道在uboot中的1000多个文件中有一个符号叫_start，但是我们不知道这个符号在哪个文件中。这种情况下要查找一个符号在所有项目中文件中的引用，要使用SourceInsight的搜索功能。

(2)利用SI工具搜索到一共7个_start，然后分析搜索出来的7处，发现有2个是api_example，2个是onenand相关的，都不是我们要找的。剩下3个都在uboot/cpu/s5pc11x/start.S文件中。

(3)然后进入start.S文件中，发现57行中就是_start标号的定义处，于是乎我们就找到了整个uboot的入口代码，就是第57行。

 

### 2.5.1.3、SI中找文件技巧

(1)以上，找到了start.S文件，下面我们就从start.S文件开始分析uboot第一阶段。

(2)在SI中，如果我们知道我们要找的文件的名字，但是我们又不知道他在哪个目录下，我们要怎样找到并打开这个文件？方法是在SI中先打开右边的工程项目管理栏目，然后点击最左边那个（这个是以文件为单位来浏览的），然后在上面输入栏中输入要找的文件的名字。我们在输入的时候，SI在不断帮我们进行匹配，即使你不记得文件的全名只是大概记得名字，也能帮助你找到你要找的文件。

 

 

## 2.5.2.start.S解析1

### 2.5.2.1、不简单的头文件包含

(1)**#include <config.h>**。config.h是在include目录下的，这个文件不是源码中本身存在的文件，而是配置过程中自动生成的文件。（详见mkconfig脚本）。这个文件的内容其实是包含了一个头文件：#include <configs/x210_sd.h>".

(2)经过分析后，发现start.S中包含的第一个头文件就是：include/configs/x210_sd.h，这个文件是整个uboot移植时的配置文件。这里面是好多宏。因此这个头文件包含将include/configs/x210_sd.h文件和start.S文件关联了起来。因此之后在分析start.S文件时，主要要考虑的就是x210_sd.h文件。

(3**)#include <version.h>**。include/version.h中包含了include/version_autogenerated.h，这个头文件就是配置过程中自动生成的。里面就一行内容：**#define U_BOOT_VERSION "U-Boot 1.3.4"**。这里面定义的宏U_BOOT_VERSION的值是一个字符串，字符串中的版本号信息来自于Makefile中的配置值。这个宏在程序中会被调用，在uboot启动过程中会串口打印出uboot的版本号，那个版本号信息就是从这来的。

(4)**#include <asm/proc/domain.h>**。asm目录不是uboot中的原生目录，uboot中本来是没有这个目录的。asm目录是配置时创建的一个符号链接，实际指向的是就是asm-arm（详解上一章节分析mkconfig脚本时）.

(5)经过分析后发现，实际文件是：include/asm-arm/proc-armv/domain.h

(6)从这里可以看出之前配置时创建的符号链接的作用，如果没有这些符号链接则编译时根本通不过，因为找不到头文件。（所以uboot不能在windows的共享文件夹下配置编译，因为windows中没有符号链接）

思考：为什么start.S不直接包含asm-arm/proc-armv/domain.h，而要用asm/proc/domain.h。**这样的设计主要是为了可移植性**。因为如果直接包含，则start

.S文件和CPU架构（和硬件）有关了，可移植性就差了。譬如我要把uboot移植到mips架构下，则start.S源代码中所有的头文件包含全部要修改。我们用了符号链接之后，则start.S中源代码不用改，只需要在具体的硬件移植时配置不同，创建的符号链接指向的不同，则可以具有可移植性。

 

 

## 2.5.3.start.S解析2

### 2.5.3.1、启动代码的16字节头部

\#if defined(CONFIG_EVT1) && !defined(CONFIG_FUSED)

  .word 0x2000

  .word 0x0

  .word 0x0

  .word 0x0

\#endif

 

(1)裸机中讲过，在SD卡启动/Nand启动等整个镜像开头需要16字节的校验头。（mkv210image.c中就是为了计算这个校验头）。

我们以前做裸机程序时根本没考虑这16字节校验头:

1、如果我们是usb启动直接下载的方式启动的则不需要16字节校验头（irom application note）；

2、如果是SD卡启动mkv210image.c中会给原镜像前加16字节的校验头。

(2)uboot这里start.S中在开头位置放了16字节的填充占位，这个占位的16字节只是保证正式的image的头部确实有16字节，但是这16字节的内容是不对的，还是需要后面去计算校验和然后重新填充的。

 

### 2.5.3.2、异常向量表的构建

.globl _start

_start: b  reset

  ldr pc, _undefined_instruction

  ldr pc, _software_interrupt

  ldr pc, _prefetch_abort

  ldr pc, _data_abort

  ldr pc, _not_used

  ldr pc, _irq

  ldr pc, _fiq

 

_undefined_instruction:

  .word undefined_instruction

_software_interrupt:

  .word software_interrupt

_prefetch_abort:

  .word prefetch_abort

_data_abort:

  .word data_abort

_not_used:

  .word not_used

_irq:

  .word irq

_fiq:

  .word fiq

_pad:

  .word 0x12345678 /* now 16*4=64 */

 

 

(1)异常向量表是硬件决定的，软件只是参照硬件的设计来实现它。

(2)异常向量表中每种异常都应该被处理，否则真遇到了这种异常就跑飞了。但是我们在uboot中并未非常细致的处理各种异常。

(3)复位异常处的代码是：b reset，因此在CPU复位后真正去执行的有效代码是reset处的代码，**因此reset符号处才是真正的有意义的代码开始的地方**。

### 2.5.3.3.2 .word详解

我们在汇编文件中经常会见到.word指令，如下所示：

 

label:

  .word express

  这里的用法表示：在当前位置存放一个字，可能有些人会觉得就是放一个字word，这个要怎么看了，一般一个word是两个字节，跟CPU的型号有关，所以不要管word的限制，直接理解成，在当前位置存放一个字，这个字是32位的即可。

 

  上面是一般人的解释，进一步讨论下，这个地址代表什么呢？

 

 label本身是一个标识，也就是一个链接地址的别名，express，是直接在这个链接地址指向的位置放置数值

 

label:

  .word  pLinkAddress

 

ldr r0,label    ///将label指向的内容赋值给r0，label是个只是个标识，标识是链接地址的别名，cpu是不会认label的，这个label是给程序员看的。

 

 

ldr pc,label    //道理同上，不同的是pc是程序计数器，这样相当于将程序跳转到label指向地址处进行执行了。1

//其中pLinkAddress是在别的文件进行的宏定义

 我们在来查看一下u-boot的反汇编文件中的内容，来证明前面的论证：

 

/***start.S源文件中定义××××××××***/

/********************************

__TEXT_BASE

  .word  TEXT_BASE

********************************/

 

 

/***u-boot.s反汇编内容××××××××***/

33f80040 <_TEXT_BASE>:

33f80040:    33f80000    mvnscc r0, #0

 

 从上可见，这里__TEXT_BASE这个标识对应的链接地址为0x33f80040，而其指向的内容则是0x33f80000

————————————————

版权声明：本文为CSDN博主「猪哥-嵌入式」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/u012351051/article/details/81408518

### 2.5.3.3、有点意思的deadbeef

_end_vect:

 

  .balignl 16,0xdeadbeef

 

(1).balignl 16,0xdeadbeef. 这一句指令是让当前地址对齐排布，如果当前地址不对齐则自动向后走地址直到对齐，并且向后走的那些内存要用0xdeadbeef来填充。

(2)0xdeadbeef这是一个十六进制的数字，这个数字很有意思，组成这个数字的十六进制数全是abcdef之中的字母，而且这8个字母刚好组成了英文的dead beef这两个单词，字面意思是坏牛肉。

(3)为什么要对齐访问？有时候是效率的要求，有时候是硬件的特殊要求。

 

### 2.5.3.4、TEXT_BASE等

_TEXT_BASE:

  .word  TEXT_BASE

 

(1)第100行这个TEXT_BASE就是上个课程中分析Makefile时讲到的那个配置阶段的TEXT_BASE，其实就是我们链接时指定的uboot的链接地址。（值就是c3e00000）

(2)源代码中和配置Makefile中很多变量是可以互相运送的。简单来说有些符号的值可以从Makefile中传递到源代码中。

_TEXT_BASE:相当于指针, .word TEXT_BASE 相当于4字节的地址（不用深入研究）；

## 2.5.4.start.S解析3

(1)CFG_PHY_UBOOT_BASE 33e00000    uboot在DDR中的物理地址

 

### 2.5.4.1、设置CPU为SVC模式

(1)msr   cpsr_c, #0xd3 将CPU设置为禁止FIQ IRQ，ARM状态，SVC模式。

(2)其实ARM CPU在复位时默认就会进入SVC模式，但是这里还是使用软件将其置为SVC模式。整个uboot工作时CPU一直处于SVC模式。

 

### 2.5.4.2、设置L2、L1cache和MMU

(1)bl disable_l2cache      // 禁止L2 cache

(2)bl set_l2cache_auxctrl_cycle   // l2 cache相关初始化

(3)bl enable_l2cache       // 使能l2 cache

(4)刷新L1 cache的icache和dcache。

(5)关闭MMU

总结：上面这5步都是和CPU的cache和mmu有关的，不用去细看，大概知道即可。

 

**拓展：**

*b**用于不返回的跳转，比如跳到某个标号处，b  .  其中的‘.’代表当前地址，那么 b  .  就是死循环。*

*bl**用于子程序跳转，要返回地址，返回地址存于LR中。**当发生**bl**跳转前，会在寄存器* *R14* *（即**LR**）中保存当前**PC-4**，即**bl**跳转指令的下一条指令的地址。所以在返回时只要* *MOV pc,lr* *。*



 

### 2.5.4.3、识别并暂存启动介质选择

(1)从哪里启动是由SoC的OM5:OM0这6个引脚的高低电平决定的。

(2)实际上在210内部有一个寄存器（地址是0xE0000004），这个寄存器中的值是硬件根据OM引脚的设置而自动设置值的。这个值反映的就是OM引脚的接法（电平高低），也就是真正的启动介质是谁。（三星CPU数据手册上没把这个写出来）

 /* Read booting information */

​    ldr r0, =PRO_ID_BASE

​    ldr r1, [r0,#OMR_OFFSET]

​    bic r2, r1, #0xffffffc1

 

(3)我们代码中可以通过读取这个寄存器的值然后判断其值来确定当前选中的启动介质是Nand还是SD还是其他的。

 (4)start.S的225-227行执行完后，在r2寄存器中存储了一个数字，这个数字等于某个特定值时就表示SD启动，等于另一个特定值时表示从Nand启动····

  /* NAND BOOT */

  cmp r2, #0x0    @ 512B 4-cycle

  moveq  r3, #BOOT_NAND

 

  cmp r2, #0x2    @ 2KB 5-cycle

  moveq  r3, #BOOT_NAND

 

  cmp r2, #0x4    @ 4KB 5-cycle  8-bit ECC

  moveq  r3, #BOOT_NAND

 

  cmp r2, #0x6    @ 4KB 5-cycle  16-bit ECC

  moveq  r3, #BOOT_NAND

 

  cmp r2, #0x8    @ OneNAND Mux

  moveq  r3, #BOOT_ONENAND

 

  /* SD/MMC BOOT */

  cmp   r2, #0xc

  moveq  r3, #BOOT_MMCSD 

 

  /* NOR BOOT */

  cmp   r2, #0x14

  moveq  r3, #BOOT_NOR  

 

 

(5)260行中给r3中赋值#BOOT_MMCSD(0x03)，这个在SD启动时实际会被执行，因此执行完这一段代码后r3中存储了0x03，以后备用。

*arm**的条件执行指令**
 CMP r0,#0 ;**比较r0与0**
 MOVEQ r1,#0 ;**如果r0与0相等,mov r1,#0,否则跳过不执行**
 MOVGT r1,#1 ;**如果r1>0,mov r1,#1,否则跳过不执行*

 

 

### 2.5.4.4、设置栈（SRAM中的栈）并调用lowlevel_init

  ldr sp, =0xd0036000 /* end of sram dedicated to u-boot */

  sub sp, sp, #12 /* set stack */

mov fp, #0

·     *sp**寄存器在任意时刻会保存我们栈顶的地址**.*

·     *fp**寄存器也称为**x29**寄存器属于通用寄存器**,**但是在某些时刻我们利用它保存栈底的地址**!()*

 

 

(1)284-286行第一次设置栈。这次**设置栈是在SRAM中设置的**，因为当前整个代码还在SRAM中运行，此时DDR还未被初始化还不能用。栈地址0xd0036000是自己指定的，指定的原则就是这块空间只给栈用，不会被别人占用。

(2)在调用函数前初始化栈，主要原因是在被调用的函数内还有再次调用函数，而BL只会将返回地址存储到LR中，但是我们只有一个LR，所以在**第二层**(不是第二次)调用函数前要先将LR入栈，否则函数返回时第一层的返回地址就丢了。

 

 

## 2.5.5.start.S解析4

 

(1)使用SourceInsight的Reference功能，找到lowlevel_init函数真正的地方，是在uboot/board/samsumg/x210/lowlevel_init.S中。

.globl lowlevel_init

lowlevel_init:

push  {lr}

 

 (2)这里push {lr} 是将返回地址压入栈，因为在这个函数中还需调用子函数，如果不压入栈的话，第一层调用的子涵的返回地址就被覆盖了。

 

### 2.5.5.1、检查复位状态

/* check reset status */

  

  ldr r0, =(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET)

  ldr r1, [r0]

  bic r1, r1, #0xfff6ffff

  cmp r1, #0x10000

  beq wakeup_reset_pre

  cmp r1, #0x80000

  beq wakeup_reset_from_didle

 

 

(1)复杂CPU允许多种复位情况，譬如：

1、直接冷上电：本来是关机的，然后点击电源打开；

2、热启动：休眠状态的启动，这种状态下可能只有cpu在动作；

3、睡眠(低功耗)状态下的唤醒等，

这些情况都属于复位。所以我们在复位代码中要去检测复位状态，来判断到底是哪种情况。

(2)判断哪种复位的意义在于：冷上电时DDR是需要初始化才能用的；而热启动或者低功耗状态下的复位则不需要再次初始化DDR。

### 2.5.5.2、IO状态恢复

/* IO Retention release */

  ldr r0, =(ELFIN_CLOCK_POWER_BASE + OTHERS_OFFSET)

  ldr r1, [r0]

  ldr r2, =IO_RET_REL

  orr r1, r1, r2

  str r1, [r0]

 

(1)这个和上一个和主线启动代码都无关，因此不用去管他。

 

### 2.5.5.3、关看门狗

/* Disable Watchdog */

  ldr r0, =ELFIN_WATCHDOG_BASE  /* 0xE2700000 */

  mov r1, #0

  str r1, [r0]

 

(1)参考裸机中看门狗章节

 

### 2.5.5.4、一些SRAM SROM相关GPIO设置

 

(1)与主线启动代码无关，不用管

 

### 2.5.5.5、供电锁存

 

/* PS_HOLD pin(GPH0_0) set to high */

  ldr r0, =(ELFIN_CLOCK_POWER_BASE + PS_HOLD_CONTROL_OFFSET)

  ldr r1, [r0]

  orr r1, r1, #0x300 

  orr r1, r1, #0x1  

  str r1, [r0]

 

(1)lowlevel_init.S的第100-104行，开发板供电锁存。

(2)为什么用两步orr,因为涉及到非法立即数

总结：在前100行，lowlevel_init.S中并没有做太多有意义的事情（除了关看门狗、供电锁存外），然后下面从110行才开始进行有意义的操作。

 

 

 

## 2.5.6.start.S解析5

### 2.5.6.1、判断当前代码执行位置

 

/* when we already run in ram, we don't need to relocate U-Boot.

   \* and actually, memory controller must be configured before U-Boot

   \* is running in ram.  */

  ldr r0, =0xff000fff

  bic r1, pc, r0      /* r0 <- current base addr of code */

  ldr r2, _TEXT_BASE   /* r1 <- original base addr in ram */

  bic r2, r2, r0     /* r0 <- current base addr of code */

  cmp   r1, r2    /* compare r0, r1         */

  beq   1f     /* r0 == r1 then skip sdram init  */

/* 1f,这个并不是一个数,1代表一个标号,f(forward)表示向前找, 而b(backward)向后找*/

/* init system clock */

  bl system_clock_init

 

  /* Memory initialize */

  bl mem_ctrl_asm_init

  

1:

  /* for UART */

  bl uart_asm_init

 

  bl tzpc_init

 

(1)lowlevel_init.S的110-115行。下

(2)这几行代码的作用就是判定当前代码执行的位置在SRAM中还是在DDR中。为什么要做这个判定？

原因1：BL1（uboot的前一部分）在SRAM中有一份，在DDR中也有一份，因此如果是**冷启动**那么当前代码应该是在SRAM中运行的BL1，如果是**低功耗状态**的复位这时候应该就是在DDR中运行的。

原因2：我们判定当前运行代码的地址是有用的，可以指导后面代码的运行。譬如在lowlevel_init.S中判定当前代码的运行地址，就是为了确定要不要执行时钟初始化和初始化DDR的代码。如果当前代码是在SRAM中，说明冷启动，那么时钟和DDR都需要初始化；如果当前代码是在DDR中，那么说明是热启动则时钟和DDR都不用再次初始化。

(2)bic   r1, pc, r0 这句代码的意义是：将pc的值中的某些bit位清0，剩下一些特殊的bit位赋值给r1（r0中为1的那些位清零）相等于：r1 = pc & ~(ff000fff)

   ldr  r2, _TEXT_BASE   加载链接地址到r2，然后将r2的相应位清0剩下特定位。

为什么要清零呢,因为链接地址和运行地址在程序运行后,运行地址和链接地址是不可能相等的,,因为你程序运行地址是不停的向下走的,所以要抹掉地址后12个bit位.

(3)最后比较r1和r2. 

总结：这一段代码是通过读取当前运行地址和链接地址，然后处理两个地址后对比是否相等，来判定当前运行是在SRAM中（不相等）还是DDR中（相等）。从而决定是否跳过下面的时钟和DDR初始化。

 

### 2.5.6.2、system_clock_init 

system_clock_init:

 

  ldr r0, =ELFIN_CLOCK_POWER_BASE @0xe0100000

 

  /* Set Mux to FIN */

  ldr r1, =0x0

  str r1, [r0, #CLK_SRC0_OFFSET]

 

  ldr r1, =APLL_LOCKTIME_VAL

  str r1, [r0, #APLL_LOCK_OFFSET]

 

  /********lxg added*********************/

  ldr r0, =ELFIN_CLOCK_POWER_BASE @0xe0100000

 

  ldr r1, =MPLL_LOCKTIME_VAL

  str r1, [r0, #MPLL_LOCK_OFFSET]

  /********end*********************/

 

  /* Disable PLL */

\#if defined(CONFIG_CHECK_MPLL_LOCK)

retryloop:

\#endif

  ldr r1, =0x0

  str r1, [r0, #APLL_CON0_OFFSET]

  ldr r1, =0x0

  str r1, [r0, #MPLL_CON_OFFSET]

 

  ldr r1, =0x0

  str r1, [r0, #MPLL_CON_OFFSET]

 

  ldr   r1, [r0, #CLK_DIV0_OFFSET]

  ldr r2, =CLK_DIV0_MASK

  bic r1, r1, r2

 

  ldr r2, =CLK_DIV0_VAL

  orr r1, r1, r2

  str r1, [r0, #CLK_DIV0_OFFSET]

 

  ldr r1, =APLL_VAL

  str r1, [r0, #APLL_CON0_OFFSET]

 

  ldr r1, =MPLL_VAL

  str r1, [r0, #MPLL_CON_OFFSET]

 

  ldr r1, =VPLL_VAL

  str r1, [r0, #VPLL_CON_OFFSET]

 

  /*******lxg added***********************/

  ldr r1, =EPLL_VAL

  str r1, [r0, #EPLL_CON_OFFSET]

 

  /*******lxg added***********************/

  ldr   r1, [r0, #CLK_DIV1_OFFSET]

  ldr r2, =CLK_DIV1_MASK

  bic r1, r1, r2

 

  ldr r2, =CLK_DIV1_VAL

  orr r1, r1, r2

  str r1, [r0, #CLK_DIV1_OFFSET]

 

  ldr   r1, [r0, #CLK_DIV2_OFFSET]

  ldr r2, =CLK_DIV2_MASK

  bic r1, r1, r2

 

  ldr r2, =CLK_DIV2_VAL

  orr r1, r1, r2

  str r1, [r0, #CLK_DIV2_OFFSET]

 

  ldr   r1, [r0, #CLK_DIV4_OFFSET]

  ldr r2, =CLK_DIV4_MASK

  bic r1, r1, r2

 

  ldr r2, =CLK_DIV4_VAL

  orr r1, r1, r2

  str r1, [r0, #CLK_DIV4_OFFSET]

 

  ldr   r1, [r0, #CLK_DIV6_OFFSET]

  ldr r2, =CLK_DIV6_MASK

  bic r1, r1, r2

 

  ldr r2, =CLK_DIV6_VAL

  orr r1, r1, r2

  str r1, [r0, #CLK_DIV6_OFFSET]

  /*******end*****************/

  /*******end*****************/

\#if defined(CONFIG_EVT1)

  ldr r1, =AFC_ON

  str r1, [r0, #APLL_CON1_OFFSET]

\#endif

  mov r1, #0x10000

1: subs  r1, r1, #1

  bne 1b

 

\#if defined(CONFIG_CHECK_MPLL_LOCK)

  /* MPLL software workaround */

  ldr r1, [r0, #MPLL_CON_OFFSET]

  orr   r1, r1, #(1<<28)

  str r1, [r0, #MPLL_CON_OFFSET]

 

  mov r1, #0x100

1: subs  r1, r1, #1

  bne 1b

 

  ldr r1, [r0, #MPLL_CON_OFFSET]

  and r1, r1, #(1<<29)

  cmp r1, #(1<<29)

  bne   retryloop

 

  /* H/W lock detect disable */

  ldr r1, [r0, #MPLL_CON_OFFSET]

  bic   r1, r1, #(1<<28)

  str r1, [r0, #MPLL_CON_OFFSET]

\#endif

 

  ldr r1, [r0, #CLK_SRC0_OFFSET]

  //ldr  r2, =0x10001111 //lxg changed.

  ldr r2, =0x00000111

  orr r1, r1, r2

  str r1, [r0, #CLK_SRC0_OFFSET]

 

  // added by terry 2012.12.4 for camera 

  ldr r1, [r0, #CLK_SRC1_OFFSET]

  bic r1, r1, #(0xf<<12)

  orr r1, r1, #(0x1<<12) //0001 XusbXTI

  str r1, [r0, #CLK_SRC1_OFFSET]

 

\#if defined(CONFIG_MCP_AC)

 

  /* CLK_SRC6[25:24] -> OneDRAM clock sel = MPLL */

  ldr r1, [r0, #CLK_SRC6_OFFSET]

  bic r1, r1, #(0x3<<24)

  orr r1, r1, #0x01000000

  str r1, [r0, #CLK_SRC6_OFFSET]

 

  /* CLK_DIV6[31:28] -> 4=1/5, 3=1/4(166MHZ@667MHz), 2=1/3 */

  ldr r1, [r0, #CLK_DIV6_OFFSET]

  bic r1, r1, #(0xF<<28)

  bic r1, r1, #(0x7<<12) @; ONENAND_RATIO: 0

  orr r1, r1, #0x30000000

  str r1, [r0, #CLK_DIV6_OFFSET]

 

\#elif defined (CONFIG_MCP_H)

 

  /* CLK_SRC6[25:24] -> OneDRAM clock sel = 00:SCLKA2M, 01:SCLKMPLL */

  ldr r1, [r0, #CLK_SRC6_OFFSET]

  bic r1, r1, #(0x3<<24)

  orr r1, r1, #0x00000000

  str r1, [r0, #CLK_SRC6_OFFSET]

 

  /* CLK_DIV6[31:28] -> 4=1/5, 3=1/4(166MHZ@667MHz), 2=1/3 */

  ldr r1, [r0, #CLK_DIV6_OFFSET]

  bic r1, r1, #(0xF<<28)

  bic r1, r1, #(0x7<<12) @; ONENAND_RATIO: 0

  orr r1, r1, #0x00000000

  str r1, [r0, #CLK_DIV6_OFFSET] 

 

\#elif defined (CONFIG_MCP_B) || defined (CONFIG_MCP_D)

 

  /* CLK_SRC6[25:24] -> OneDRAM clock sel = 00:SCLKA2M, 01:SCLKMPLL */

  ldr r1, [r0, #CLK_SRC6_OFFSET]

  bic r1, r1, #(0x3<<24)

  orr r1, r1, #0x01000000

  str r1, [r0, #CLK_SRC6_OFFSET]

 

  /* CLK_DIV6[31:28] -> 4=1/5, 3=1/4(166MHZ@667MHz), 2=1/3 */

  ldr r1, [r0, #CLK_DIV6_OFFSET]

  bic r1, r1, #(0xF<<28)

  bic r1, r1, #(0x7<<12) @; ONENAND_RATIO: 0

  orr r1, r1, #0x30000000

  str r1, [r0, #CLK_DIV6_OFFSET]

 

\#elif defined (CONFIG_MCP_SINGLE)

 

  /* CLK_DIV6 */

  /*ldr  r1, [r0, #CLK_DIV6_OFFSET]

  bic r1, r1, #(0x7<<12) @; ONENAND_RATIO: 0

  str r1, [r0, #CLK_DIV6_OFFSET]*/ //lxg mask

 

\#endif 

 

  mov pc, lr

 

 

(1)使用SI搜索功能，确定这个函数就在当前文件的205行，一直到第385行。这个初始化时钟的过程和裸机中初始化的过程一样的，只是更加完整而且是用汇编代码写的。

(2)在x210_sd.h中300行到428行，都是和时钟相关的配置值。这些宏定义就决定了210的时钟配置是多少。也就是说代码在lowlevel_init.S中都写好了，但是代码的设置值都被宏定义在x210_sd.h中了。因此，如果移植时需要更改CPU的时钟设置，根本不需要动代码，只需要在x210_sd.h中更改配置值即可。

 

 

## 2.5.7.start.S解析6

### 2.5.7.1、mem_ctrl_asm_init

(1)该函数用来初始化DDR

(2)函数位置在uboot/cpu/s5pc11x/s5pc110/cpu_init.S文件中。

 

(3)该函数和裸机中初始化DDR代码是一样的。实际上裸机中初始化DDR的代码就是从这里抄的。配置值也可以从这里抄，但是当时我自己根据理解+抄袭整出来的一份。

(4)配置值中其他配置值参考裸机中的解释即可明白，有一个和裸机中讲的不一样。DMC0_MEMCONFIG_0，在裸机中配置值为0x20E01323；在uboot中配置为0x30F01313.这个配置不同就导致结果不同。

在 裸机中DMC0的256MB内存地址范围是0x20000000-0x2FFFFFFF; 

在uboot中DMC0的256MB内存地址范围为0x30000000-0x3FFFFFFF;

(5)之前在裸机中时配置为2开头的地址，当时并没有说可以配置为3开头。从分析九鼎移植的uboot可以看出：DMC0上允许的地址范围是20000000-3FFFFFFF（一共是512MB），而我们实际只接了256MB物理内存，SoC**允许我们给这256MB挑选地址范围**。

(6)总结一下：在uboot中，可用的物理地址范围为：0x30000000-0x4FFFFFFF。一共512MB，其中30000000-3FFFFFFF为DMC0，40000000-4FFFFFFF为DMC1。

(7)我们需要的内存配置值在x210_sd.h的438行到468行之间。分析的时候要注意条件编译的条件，配置头文件中考虑了不同时钟配置下的内存配置值，这个的主要目的是让不同时钟需求的客户都能找到合适自己的内存配置值。

(8)在uboot中DMC0和DMC1都工作了，所以在裸机中只要把uboot中的配置值和配置代码全部移植过去，应该是能够让DMC0和DMC1都工作的。

 

### 2.5.7.2、uart_asm_init

uart_asm_init:

 

  /* set GPIO(GPA) to enable UART */

  @ GPIO setting for UART

  ldr r0, =ELFIN_GPIO_BASE

  ldr r1, =0x22222222

  str   r1, [r0, #GPA0CON_OFFSET]

 

  ldr   r1, =0x2222

  str   r1, [r0, #GPA1CON_OFFSET]

 

  // HP V210 use. SMDK not use.

\#if defined(CONFIG_VOGUES)

  ldr  r1, =0x100

  str  r1, [r0, #GPC0CON_OFFSET]

 

  ldr  r1, =0x4

  str  r1, [r0, #GPC0DAT_OFFSET]

\#endif

 

  ldr r0, =ELFIN_UART_CONSOLE_BASE    @0xEC000000

  mov r1, #0x0

  str r1, [r0, #UFCON_OFFSET]

  str r1, [r0, #UMCON_OFFSET]

 

  mov r1, #0x3

  str r1, [r0, #ULCON_OFFSET]

 

  ldr r1, =0x3c5

  str r1, [r0, #UCON_OFFSET]

 

  ldr r1, =UART_UBRDIV_VAL

  str r1, [r0, #UBRDIV_OFFSET]

 

  ldr r1, =UART_UDIVSLOT_VAL

  str r1, [r0, #UDIVSLOT_OFFSET]

 

  ldr r1, =0x4f4f4f4f

  str r1, [r0, #UTXH_OFFSET]   @'O'

 

  mov pc, lr

 

(1)这个函数用来初始化串口

(2)初始化完了后通过串口发送了一个'O'

 

### 2.5.7.3、tzpc_init

(1)trust zone初始化，没搞过，不管

 

### 2.5.7.4、pop {pc}以返回

 

 push和pop是用来操作栈的2个指令。

 push寄存器：将一个寄存器中的数据入栈

 pop寄存器：出栈用一个寄存器接收数据

(1)返回前通过串口打印'K'

**分析；****lowlevel_init.S****执行完如果没错那么就会串口打印出"OK"字样。这应该是我们uboot中看到的最早的输出信息。**    

 

 

## 2.5.8.start.S解析7

总结回顾：lowlevel_init.S中总共做了哪些事情：

检查复位状态、IO恢复、关看门狗、开发板供电锁存、时钟初始化、DDR初始化、串口初始化并打印'O'、tzpc初始化、打印'K'。

其中值得关注的：关看门狗、开发板供电锁存、时钟初始化、DDR初始化、打印"OK"

### 2.5.8.1、再次设置栈（DDR中的栈）

(1)再次开发板供电锁存。第一，做2次是不会错的；第二，做2次则第2次无意义；做代码移植时有一个古怪谨慎保守策略就是尽量添加代码而不要删除代码。

/* get ready to call C functions */

  ldr sp, _TEXT_PHY_BASE /* setup temp stack pointer */

  sub sp, sp, #12

  mov fp, #0     /* no previous frame, so fp=0 */

 

(2)之前在调用lowlevel_init程序前设置过1次栈（start.S 284-287行），那时候因为DDR尚未初始化，因此程序执行都是在SRAM中，所以在SRAM中分配了一部分内存作为栈。本次因为DDR已经被初始化了，因此要把栈挪移到DDR中，所以要重新设置栈，这是第二次（start.S 297-299行）；这里实际设置的栈的地址是33E00000，刚好在uboot的代码段的下面紧挨着。

(3)为什么要再次设置栈？DDR已经初始化了，已经有大片内存可以用了，没必要再把栈放在SRAM中可怜兮兮的了；原来SRAM中内存大小空间有限，栈放在那里要注意不能使用过多的栈否则栈会溢出，我们及时将栈迁移到DDR中也是为了尽可能避免栈使用时候的小心翼翼。

感慨：uboot的启动阶段主要技巧就在于小范围内有限条件下的辗转腾挪。

 

### 2.5.8.2、再次判断当前地址以决定是否重定位

  /* when we already run in ram, we don't need to relocate U-Boot.

   \* and actually, memory controller must be configured before U-Boot

   \* is running in ram.

   */

  ldr r0, =0xff000fff

  bic r1, pc, r0       /* r0 <- current base addr of code */

  ldr r2, _TEXT_BASE     /* r1 <- original base addr in ram */

  bic r2, r2, r0      /* r0 <- current base addr of code */

  cmp   r1, r2      /* compare r0, r1         */

  beq   after_copy   /* r0 == r1 then skip flash copy  */

 

(1)再次用相同的代码判断运行地址是在SRAM中还是DDR中，不过本次判断的目的不同（上次判断是为了决定是否要执行初始化时钟和DDR的代码）这次判断是为了决定是否进行uboot的relocate。

(2)冷启动时当前情况是uboot的前一部分（16kb或者8kb）开机自动从SD卡加载到SRAM中正在运行，uboot的第二部分（其实第二部分是整个uboot）还躺在SD卡的某个扇区开头的N个扇区中。此时uboot的第一阶段已经即将结束了（第一阶段该做的事基本做完了），结束之前要把第二部分加载到DDR中链接地址处（33e00000），这个加载过程就叫重定位。

 

 

## 2.5.9.uboot重定位详解

 

(1)D0037488这个内存地址在SRAM中，这个地址中的值是被硬件自动设置的。硬件根据我们实际电路中SD卡在哪个通道中，会将这个地址中的值设置为相应的数字。譬如我们从SD0通道启动时，这个值为EB000000；从SD2通道启动时，这个值为EB200000

/* SD/MMC BOOT */

  cmp   r2, #0xc

  moveq  r3, #BOOT_MMCSD 

 

________________________________________________________

  ldr r0, =INF_REG_BASE

  str r3, [r0, #INF_REG3_OFFSET]  

 

_________________________________________________________

ldr  r0, =INF_REG_BASE

  ldr r1, [r0, #INF_REG3_OFFSET]

  cmp r1, #BOOT_NAND   /* 0x0 => boot device is nand */

  beq nand_boot

  cmp r1, #BOOT_ONENAND  /* 0x1 => boot device is onenand */

  beq onenand_boot

  cmp   r1, #BOOT_MMCSD

  beq   mmcsd_boot

  cmp   r1, #BOOT_NOR

  beq   nor_boot

  cmp   r1, #BOOT_SEC_DEV

  beq   mmcsd_boot

 

 

(2)我们在start.S的260行确定了从MMCSD启动，然后又在278行将#BOOT_MMCSD写入了INF_REG3寄存器中存储着。然后又在322行读出来，再和#BOOT_MMCSD去比较，确定是从MMCSD启动。最终跳转到mmcsd_boot函数中去执行重定位动作。

mmcsd_boot:

\#if DELETE

  ldr   sp, _TEXT_PHY_BASE   

  sub   sp, sp, #12

  mov   fp, #0

\#endif

  bl   movi_bl2_copy

  b    after_copy

 

nor_boot:

  bl   read_hword

  b    after_copy

 

(3)真正的重定位是通过调用movi_bl2_copy函数完成的，在uboot/cpu/s5pc11x/movi.c中。是一个C语言的函数

(4) 

/*

第1个  int 是通道号， 210启动只支持 0,2 ， 0通道inand占用了， 我们要用通道2

第2个  unsigned int 是起始块地址

第3个 unsigned short 你要复制多少个块

第4个  unsigned int*  你要复制到我们内存的那里去

第5个  bool   决定卡的初始化 ，给0就可以。

*/

 

typedef void(*pBL2Type)(void);

 

typedef bool(*pCopySDMMCC2Mem)(int, unsigned int, unsigned short, unsigned int*, bool);

 

_______________________________________________________

u32 ret;

  if (ch == 0xEB000000) {

​    ret = copy_bl2(0, MOVI_BL2_POS, MOVI_BL2_BLKCNT,

​      CFG_PHY_UBOOT_BASE, 0);

 

分析参数：2表示通道2；MOVI_BL2_POS是uboot的第二部分在SD卡中的开始扇区，这个扇区数字必须和烧录uboot时烧录的位置相同；MOVI_BL2_BLKCNT是uboot的长度占用的扇区数；CFG_PHY_UBOOT_BASE是重定位时将uboot的第二部分复制到DDR中的起始地址（33E00000）.

 

 

## 2.5.10.start.S解析8

### 2.5.10.1、什么是虚拟地址、物理地址

 

after_copy:

 

\#if defined(CONFIG_ENABLE_MMU)

enable_mmu:

  /* enable domain access */

  ldr r5, =0x0000ffff

  mcr p15, 0, r5, c3, c0, 0    @load domain access register

 

  /* Set the TTB register */

  ldr r0, _mmu_table_base

  ldr r1, =CFG_PHY_UBOOT_BASE

  ldr r2, =0xfff00000

  bic r0, r0, r2

  orr r1, r0, r1

  mcr p15, 0, r1, c2, c0, 0

 

  /* Enable the MMU */

mmu_on:

  mrc p15, 0, r0, c1, c0, 0

  orr r0, r0, #1

  mcr p15, 0, r0, c1, c0, 0

  nop

  nop

  nop

  nop

\#endif

 

skip_hw_init:

  /* Set up the stack             */

stack_setup:

\#if defined(CONFIG_MEMORY_UPPER_CODE)

  ldr sp, =(CFG_UBOOT_BASE + CFG_UBOOT_SIZE - 0x1000)

\#else

  ldr r0, _TEXT_BASE   /* upper 128 KiB: relocated uboot  */

  sub r0, r0, #CFG_MALLOC_LEN /* malloc area           */

  sub r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo            */

\#if defined(CONFIG_USE_IRQ)

  sub r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)

\#endif

  sub sp, r0, #12   /* leave 3 words for abort-stack  */

 

\#endif

 

clear_bss:

  ldr r0, _bss_start   /* find start of bss segment    */

  ldr r1, _bss_end    /* stop here            */

  mov   r2, #0x00000000   /* clear              */

 

clbss_l:

  str r2, [r0]    /* clear loop...          */

  add r0, r0, #4

  cmp r0, r1

  ble clbss_l

  

  ldr pc, _start_armboot

 

_start_armboot:

  .word start_armboot

 

\#if defined(CONFIG_ENABLE_MMU)

_mmu_table_base:

  .word mmu_table

\#endif

 

(1)**物理地址**: 物理设备设计生产时赋予的地址。像裸机中使用的寄存器的地址就是CPU设计时指定的，这个就是物理地址。**物理地址是硬件编码的**，是设计生产时确定好的，一旦确定了就不能改了。

(2)一个事实就是：寄存器的物理地址是无法通过编程修改的，是多少就是多少，只能通过查询数据手册获得并操作。坏处就是不够灵活。一个解决方案就是使用虚拟地址。

   (3)**虚拟地址** :就是在我们软件操作和硬件被操作之间增加一个层次，叫做虚拟地址映射层。有了虚拟地址映射后，软件操作只需要给虚拟地址，硬件操作还是用原来的物理地址，映射层建立一个虚拟地址到物理地址的映射表。当我们软件运行的时候，**软件中使用的虚拟地址在映射表中查询得到对应的物理地址再发给硬件去执行**（虚拟地址到物理地址的映射是不可能通过软件来实现的）。

 

### 2.5.10.2、MMU单元的作用

(1)**MMU****就是memory management unit**，**内存管理单元**。MMU实际上是SOC中一个硬件单元，它的主要功能就是实现虚拟地址到物理地址的映射。

(2)MMU单片在**CP15****协处理器**中进行控制，也就是说要操控MMU进行虚拟地址映射，方法就是对cp15协处理器的寄存器进行编程。

 

### 2.5.10.3、地址映射的额外收益1：访问控制

(1)**访问控制**：在管理上对内存进行分块，然后每块进行独立的虚拟地址映射，然后在每一块的映射关系中同时还实现了访问控制（对该块可读、可写、只读、只写、不可访问等控制）.

(2)回想在C语言中编程中经常会出现一个错误：Segmentation fault。实际上这个段错误就和MMU实现的访问控制有关。当前程序只能操作自己有权操作的地址范围（若干个内存块），如果当前程序指针出错访问了不该访问的内存块则就会触发段错误。

 

### 2.5.10.4、地址映射的额外收益2：cache

(1)cache的工作和虚拟地址映射有关系。

(2)cache是快速缓存，意思就是比CPU慢但是比DDR块。CPU嫌DDR太慢了，于是乎把一些DDR中常用的内容事先读取缓存在cache中，然后CPU每次需要找东西时先在cache中找。如果cache中有就直接用cache中的；如果cache中没有才会去DDR中寻找。

 

参考阅读：http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=22891521&id=2109284

 

 

## 2.5.11.start.S解析9

### 2.5.11.1、使能域访问（cp15的c3寄存器）

/* enable domain access */

  ldr r5, =0x0000ffff

  mcr p15, 0, r5, c3, c0, 0    @load domain access register

 

(1)cp15协处理器内部有c0到c15共16个寄存器，这些寄存器每一个都有自己的作用。我们通过mrc(将协处理器的寄存器中数值传送到ARM处理器的寄存器中)和mcr(相反)指令来访问这些寄存器。所谓的操作cp协处理器其实就是操作cp15的这些寄存器。

(2)c3寄存器在mmu中的作用是控制域访问。域访问是和MMU的访问控制有关的。

 

### 2.5.11.2、设置TTB（cp15的c2寄存器）

 

  /* Set the TTB register */

  ldr r0, _mmu_table_base

  ldr r1, =CFG_PHY_UBOOT_BASE

  ldr r2, =0xfff00000

  bic r0, r0, r2

  orr r1, r0, r1

  mcr p15, 0, r1, c2, c0, 0

 

(1)**TTB****就是translation table base**，转换表基地址。首先要明白什么是TT（translation table转换表），TTB其实就是转换表的基地址。

 

   (2)转换表是建立一套虚拟地址映射的关键。转换表分2部分，表索引和表项。表索引对应虚拟地址，表项对应物理地址。一对表索引和表项构成一个转换表单元，能够对一个内存块进行虚拟地址转换。（**映射中基本规定中规定了内存映射和管理是以块为单位的**，至于块有多大，要看你的MMU的支持和你自己的选择。在ARM中支持3种块大小，细表1KB、粗表4KB、段1MB）。真正的转换表就是由若干个转换表单元构成的，每个单元负责1个内存块，总体的转换表负责整个内存空间（0-4G）的映射。

(3)整个建立虚拟地址映射的主要工作就是建立这张转换表

(4)转换表放置在内存中的，放置时要求起始地址在内存中要xx位对齐。转换表不需要软件去干涉使用，而是将基地址TTB设置到cp15的c2寄存器中，然后MMU工作时会自动去查转换表。

 

### 2.5.11.3、使能MMU单元（cp15的c1寄存器）

  /* Enable the MMU */

mmu_on:

  mrc p15, 0, r0, c1, c0, 0

  orr r0, r0, #1

  mcr p15, 0, r0, c1, c0, 0

  

 

(1)cp15的c1寄存器的bit0控制MMU的开关。只要将这一个bit置1即可开启MMU。开启MMU之后上层软件层的地址就必须经过TT的转换才能发给下层物理层去执行。

 

### 2.5.11.4、找到映射表待分析

(1)通过符号查找，确定转换表在lowlevel_init.S文件的593行。

 

### 2.5.11.5、S5PV210的2种虚拟地址管理

 

 

## 2.5.12.start.S解析10

### 2.5.12.1、宏FL_SECTION_ENTRY 以及循环体

  **宏定义：**

 /* form a first-level section entry */

.macro FL_SECTION_ENTRY base,ap,d,c,b

  .word (\base << 20) | (\ap << 10) | \

​     (\d << 5) | (1<<4) | (\c << 3) | (\b << 2) | (1<<1)

. .endm

 

.macro 是宏定义的开始, .endm是宏定义的结束, .word 定义一个4字节的数字.

 

 **循环体：**

  .set __base,0

  // Access for iRAM

  .rept 0x100

  FL_SECTION_ENTRY __base,3,0,0,0

  .set __base,__base+1   

  .endr

 

.rept 是循环的开始 ，循环次数 0x100次（循环的次数也是转换表的表项索引）。.endr是结束； 

FL_SECTION_ENTRY __base,3,0,0,0 调用宏定义，映射虚拟地址到物理地址；

### 12.2、页表项各bit位含义

待学习

### 2.5.12.3、段式页表详解

 

结论: 虚拟地址映射只是把虚拟地址的c00000000开头的256MB映射到了DMC0的30000000开头的256MB物理内存上去了。其他的虚拟地址空间根本没动，还是原样的。

### 2.5.12.4、实验操作验证

 

###    2.5.12.5、总结：关于MMU和虚拟地址映射的学习

宏观上理解转换表：整个转换表可以看作是一个int类型的数组，数组中的一个元素就是一个表索引和表项的单元。数组中的元素值就是表项，这个元素的数组下标就是表索引。

ARM的段式映射中长度为1MB，因此一个映射单元只能管1MB内存，那我们整个4G范围内需要4G/1MB=4096个映射单元，也就是说这个数组的元素个数是4096.实际上我们做的时候并没有依次单个处理这4096个单元，而是把4096个分成几部分，然后每部分用for循环做相同的处理。

 

 

## 2.5.13.start.S解析11

### 2.5.13.1、再次设置栈

stack_setup:

\#if defined(CONFIG_MEMORY_UPPER_CODE)

  ldr sp, =(CFG_UBOOT_BASE + CFG_UBOOT_SIZE - 0x1000)

\#else

 

(1)第三次设置栈。这次设置栈还是在DDR中，之前虽然已经在DDR中设置过一次栈了，但是本次设置栈的目的是将栈放在比较合适（安全，紧凑而不浪费内存）的地方。

​    (2)CFG_UBOOT_SIZE = 2MB， 这个范围是包括栈的内存的，而整个uboot占整个内存0.4KB左右。

(3)我们实际将栈设置在uboot起始地址上方2MB处，这样安全的栈空间是：2MB-uboot大小-0x1000=1.2MB左右。这个空间既没有太浪费内存，又足够安全。

 

### 2.5.13.2、清理bss

clear_bss:

  ldr r0, _bss_start   /* find start of bss segment    */

  ldr r1, _bss_end    /* stop here            */

  mov   r2, #0x00000000   /* clear            */

 

clbss_l:

  str r2, [r0]    /* clear loop...          */

  add r0, r0, #4

  cmp r0, r1

  ble clbss_l

  

  

 

(1)清理bss段代码和裸机中讲的一样。注意表示bss段的开头和结尾地址的符号是从链接脚本u-boot.lds得来的。

​    

### 2.5.13.3、ldr   pc, _start_armboot

 ldr pc, _start_armboot

(1)start_armboot是uboot/lib_arm/board.c中，这是一个C语言实现的函数。这个函数就是uboot的第二阶段。这句代码的作用就是将uboot第二阶段执行的函数的地址传给pc，实际上就是使用一个远跳转直接跳转到DDR中的第二阶段开始地址处。

   (2)远跳转的含义就是这句话加载的地址和当前运行地址无关，而和链接地址有关。因此这个远跳转可以实现从SRAM中的第一阶段跳转到DDR中的第二阶段。

(3)这里这个远跳转就是uboot第一阶段和第二阶段的分界线。

 

### 2.5.13.4、总结：uboot的第一阶段做了哪些工作

   (1)构建异常向量表

(2)设置CPU为SVC模式

(3)关看门狗

(4)开发板供电置锁

(5)时钟初始化

(6)DDR初始化

(7)串口初始化并打印"OK"

(8)重定位

(9) 判断uboot在哪种设备

（ONENAND OR INAND OR…）

(9)建立映射表并开启     MMU

(10)跳转到第二阶段

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第六章 uboot源码分析2-启动第二阶段

## 2.6.0 章节概要

**2.6.1.start_armboot函数简介**

​    本节课简要介绍start_armboot函数，回顾uboot启动第一阶段的同时展望了第二阶段要做的事情，并且分析了uboot启动最终的归宿。

**2.6.2.start_armboot解析1**

​    本节开始解析start_armboot函数，主要解析了init_fnc_t和DECLARE_GLOBAL_DATA_PTR这两个表达式。

**2.6.3.内存使用排布**

​    本节接应上节讲的gd和bd，介绍uboot中设计的内存使用和排布方法。

**2.6.4.start_armboot解析2**

​    本节开始分析init_sequence，并从头开始分析其中的板级初始化函数。

**2.6.5.start_armboot解析3**

​    本节主要讲解board_init中的DDR配置和初始化部分。

**2.6.6.start_armboot解析4**

​    本节主要讲解interrupt_init和env_init，分别是定时器初始化和环境变量的初始化。

**2.6.7.start_armboot解析5**

​    本节主要讲解init_baudrate和serial_init两个函数，都是串口相关的初始化。

**2.6.8.start_armboot解析6**

​    本节主要讲解console_init_f、display_banner和print_cpuinfo这两个初始化函数，分别是控制台初始化、打印启动logo和cpu信息的函数。

**2.6.9.start_armboot解析7**

​    本节介绍了check_board函数，同时重点给大家演示了如何进行uboot的代码实践和学习。

**2.6.10.start_armboot解析8**

​    本节介绍了init_sequence中最后的2个dram相关初始化函数，并且对整个init_sequence中所有初始化函数做了总结和回顾。

**2.6.11.start_armboot解析9**

​    本节讲解flash初始化和堆管理器内存初始化两个函数，并且进行了代码实践。

**2.6.12.start_armboot解析10**

​    本节主要讲解MMC卡初始化相关代码，这是对驱动学习最好的启蒙。

**2.6.13.start_armboot解析11**

​    本节主要讲解env_relocate函数，详细介绍了环境变量在uboot的整体实现。

**2.6.14.start_armboot解析12**

​    本节主要讲解IP地址、MAC地址的获取及确定，devices_init和jumptable的初始化。

**2.6.15.start_armboot解析13**

​    本节主要讲解console_init_f、enable_interrupts、board_late_init这几个初始化函数。

**2.6.16.start_armboot解析14**

​    本节讲解剩下的几个初始化函数，并且结束了start_armboot函数。

**2.6.17.uboot启动2阶段总结**

​    本节对本课程中讲到的start_armboot函数进行整体总结回顾，帮助大家加深记忆。

## 2.6.1.start_armboot函数简介

### 2.6.1.1、一个很长的函数

(1)这个函数在uboot/lib_arm/board.c的第444行开始到908行结束。

(2)450行还不是全部，因为里面还调用了别的函数。

(3)为什么这么长的函数，怎么不分成两三个函数？主要因为这个函数整个构成了uboot启动的第二阶段。

 

### 2.6.1.2、一个函数组成uboot第二阶段

 

### 2.6.1.3、宏观分析：uboot第二阶段应该做什么

(1)概括来讲uboot第一阶段主要就是初始化了SoC内部的一些部件（譬如看门狗、时钟），然后初始化DDR并且完成重定位。

(2)由宏观分析来讲，uboot的第二阶段就是要初始化剩下的还没被初始化的硬件。主要是SoC外部硬件（譬如iNand、网卡芯片····）、uboot本身的一些东西（uboot的命令、环境变量等····）。然后最终初始化完必要的东西后进入uboot的命令行准备接受命令。

 

### 2.6.1.4、思考：uboot第二阶段完结于何处？

(1)uboot启动后自动运行打印出很多信息（这些信息就是uboot在第一和第二阶段不断进行初始化时，打印出来的信息）。然后uboot进入了倒数bootdelay秒然后执行bootcmd对应的启动命令。

(2)如果用户没有干涉则会执行bootcmd进入自动启动内核流程（uboot就死掉了）；此时用户可以按下回车键打断uboot的自动启动进入uboot的命令行下。然后uboot就一直工作在命令行下。

(3)uboot的命令行就是一个死循环，循环体内不断重复：接收命令、解析命令、执行命令。这就是uboot最终的归宿。

 

 

## 2.6.2.start_armboot解析1

### 2.6.2.1、init_fnc_t

(1) typedef int init_fnc_t(void); 这是一个函数类型

 

(2)init_fnc_ptr是一个二重函数指针，回顾高级C语言中讲过：二重指针的作用有2个（其中一个是用来指向一重指针），一个是用来指向指针数组。因此这里的init_fuc_ptr可以用来指向一个函数指针数组。

 

### 2.6.2.DECLARE_GLOBAL_DATA_PTR

(1)#define DECLARE_GLOBAL_DATA_PTR   register volatile gd_t *gd asm ("r8")

定义了一个全局变量名字叫gd,这个全局变量是一个指针类型，占4字节。用volatile修饰表示可变的，用register修饰表示这个变量要尽量放到寄存器中，后面的asm("r8")是gcc支持的一种语法，意思就是要把gd放到寄存器r8中。

(2)综合分析，DECLARE_GLOBAL_DATA_PTR就是**定义了一个要放在寄存器r8中的全局变量，名字叫gd，类型是一个指向gd_t类型变量的指针**。

(3)为什么要定义为register？因为这个全局变量gd（global data的简称）是uboot中很重要的一个全局变量（准确的说这个全局变量是一个结构体，里面有很多内容，这些内容加起来构成的结构体就是uboot中常用的所有的全局变量），这个gd在程序中经常被访问，因此放在register中提升效率。因此纯粹是运行效率方面考虑，和功能要求无关。并不是必须的。

typedef struct global_data {

  bd_t    *bd;        //存一些开发板的信息的

  unsigned long  flags;

  unsigned long  baudrate;   //通信的波特率

  unsigned long  have_console;  /* serial_init() was called */控制台（scanf,printf），基于串口；

  unsigned long  reloc_off; /* Relocation Offset */

  unsigned long  env_addr;  /* Address of Environment struct */

  unsigned long  env_valid; /* Checksum of Environment valid? */

  unsigned long  fb_base;  /* base address of frame buffer */

\#ifdef CONFIG_VFD

  unsigned char  vfd_type;  /* display type */

\#endif

\#if 0

  unsigned long  cpu_clk;  /* CPU clock in Hz!   */

  unsigned long  bus_clk;

  phys_size_t ram_size;  /* RAM size */

  unsigned long  reset_status;  /* reset status register at boot */

\#endif

  void    **jt;    /* jump table */

} gd_t;

 

 

typedef struct bd_info {

  int     bi_baudrate;  /* serial console baudrate */

  unsigned long  bi_ip_addr; /* IP Address */

  unsigned char  bi_enetaddr[6]; /* Ethernet adress */

  struct environment_s      *bi_env;

  ulong      bi_arch_number; /* unique id for this board */机器码

  ulong      bi_boot_params; /* where this board expects params */启动参数的地址

  struct       /* RAM configuration */

  {

  ulong start;

  ulong size;

  }      bi_dram[CONFIG_NR_DRAM_BANKS]; //DDR的信息（配置、分布）

\#ifdef CONFIG_HAS_ETH1

  /* second onboard ethernet port */

  unsigned char  bi_enet1addr[6];  //第二个网卡地址

\#endif

} bd_t;

 

 

(4)gd_t定义在include/asm-arm/global_data.h中。

gd_t中定义了很多全局变量，都是整个uboot使用的；其中有一个bd_t类型的指针，指向一个bd_t类型的变量，这个bd是开发板的板级信息的结构体，里面有不少硬件相关的参数，譬如波特率、IP地址、机器码、DDR内存分布。

 

 

## 2.6.3.内存使用排布

### 2.6.3.1、为什么要分配内存

(1)DECLARE_GLOBAL_DATA_PTR只能定义了一个指针，也就是说gd里的这些全局变量并没有被分配内存，我们在使用gd之前要给他分配内存，否则gd也只是一个野指针而已。

(2)gd和bd需要内存，内存当前没有被人管理（因为没有操作系统统一管理内存），大片的DDR内存散放着可以随意使用（只要使用内存地址直接去访问内存即可）。但是因为uboot中后续很多操作还需要大片的连着内存块，因此这里**使用内存要本着够用就好，紧凑排布的原则**。所以我们在uboot中需要有一个整体规划。

 

### 2.6.3.2、内存排布

 

gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_\SIZE - sizeof(gd_t);

 

   (1)uboot区  CFG_UBOOT_BASE-xx（长度为uboot的实际长度）

(2)堆区     长度为CFG_MALLOC_LEN，实际为 912KB   

(3)栈区     长度为CFG_STACK_SIZE，实际为512KB

(4)gd       长度为sizeof(gd_t)，实际36字节

(5)bd       长度为sizeof(bd_t)，实际为44字节左右

(6)内存间隔     为了防止高版本的gcc的优化造成错误。

**清理内存：**

  memset ((void*)gd, 0, sizeof (gd_t));

  gd->bd = (bd_t*)((char*)gd - sizeof(bd_t));

  memset (gd->bd, 0, sizeof (bd_t));

​    

**内存间隔：**

/* compiler optimization barrier needed for GCC >= 3.4 */

  __asm__ __volatile__("": : :"memory");

GCC>=3.4时编译器的优化墙，防止编译器优化出错；

## 2.6.4.start_armboot解析2

### 2.6.4.1、for循环执行init_sequence

for (init_fnc_ptr = init_sequence; *init_fnc_ptr!=NULL; ++init_fnc_ptr) {

​    if ((*init_fnc_ptr)() != 0) {

​      hang ();

​    }

}

 

 

init_fnc_t *init_sequence[] = {

  cpu_init,    /* basic cpu dependent setup */

\#if defined(CONFIG_SKIP_RELOCATE_UBOOT)

  reloc_init,   /* Set the relocation done flag, must

​          do this AFTER cpu_init(), but as soon

​          as possible */

\#endif

  board_init,   /* basic board dependent setup */

  interrupt_init,   /* set up exceptions */

  env_init,    /* initialize environment */

  init_baudrate,   /* initialze baudrate settings */

  serial_init,    /* serial communications setup */

  console_init_f,   /* stage 1 init of console */

  display_banner,   /* say that we are here */

\#if defined(CONFIG_DISPLAY_CPUINFO)

  print_cpuinfo,   /* display cpu info (and speed) */

\#endif

\#if defined(CONFIG_DISPLAY_BOARDINFO)

  checkboard,   /* display board info */

\#endif

\#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)

  init_func_i2c,

\#endif

  dram_init,   /* configure available RAM banks */

  display_dram_config,

  NULL,

};

 

 

void hang (void)

{

  puts ("### ERROR ### Please RESET the board ###\n");

  for (;;);

}

 

(1)init_sequence是一个函数指针数组，数组中存储了很多个函数指针，这些指向指向的函数都是init_fnc_t类型（特征是接收参数是void类型，返回值是int）。

(2)init_sequence在定义时就同时给了初始化，初始化的函数指针都是一些函数名。（C语言高级专题中讲过：函数名的实质）。

(3)init_fnc_ptr是一个二重函数指针，可以指向init_sequence这个函数指针数组。

(4)用for循环肯定是想要去遍历这个函数指针数组（遍历的目的也是去依次执行这个函数指针数组中的所有函数）。**思考**：如何遍历一个函数指针数组？

有2种方法：

第一种也是最常用的一种，用下标去遍历，用数组元素个数来截至。

第二种不常用，但是也可以。就是在数组的有效元素末尾放一个标志，依次遍历到标准处即可截至（有点类似字符串的思路）。

我们这里使用了第二种思路。因为数组中存的全是函数指针，因此我们选用了NULL来作为标志。我们遍历时从开头依次进行，直到看到NULL标志截至。这种方法的优势是不用事先统计数组有多少个元素。

(5)init_fnc_t的这些函数的返回值定义方式一样的，都是：函数执行正确时返回0，不正确时返回-1.所以我们在遍历时去检查函数返回值，如果遍历中有一个函数返回值不等于0则hang()挂起。从分析hang函数可知：uboot启动过程中初始化板级硬件时不能出任何错误，只要有一个错误整个启动就终止，除了重启开发板没有任何办法。

(6)init_sequence中的这些函数，都是board级别的各种硬件初始化。

 

### 2.6.4.2、cpu_init

int cpu_init (void)

{

  /*

   \* setup up stacks if necessary

   */

\#ifdef CONFIG_USE_IRQ

IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA\_SIZE - 4;

  FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;

\#endif

  return 0;

}

 

 

(1)看名字这个函数应该是cpu内部的初始化，所以这里是空的。

### 2.6.4.3、board_init

 

int board_init(void)

{

  DECLARE_GLOBAL_DATA_PTR; //因为后面使用了gd，所以申明一下；

\#ifdef CONFIG_DRIVER_SMC911X

  smc9115_pre_init();

\#endif

 

\#ifdef CONFIG_DRIVER_DM9000

  dm9000_pre_init();

\#endif

 

  gd->bd->bi_arch_number = MACH_TYPE;

  gd->bd->bi_boot_params = (PHYS_SDRAM_1+0x100);

 

  return 0;

}

__________________________________________________________________

\#define MACH_TYPE    2456

\#define PHYS_SDRAM_1      MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */

\#define MEMORY_BASE_ADDRESS 0x30000000

 

 

(1)board_init在uboot/board/samsung/x210/x210.c中，这个看名字就知道是x210开发板相关的初始化。

(2)DECLARE_GLOBAL_DATA_PTR在这里声明是为了后面使用gd方便。可以看出把gd的声明定义成一个宏的原因就是我们要到处去使用gd，因此就要到处声明，定义成宏比较方便。

(3)网卡初始化。CONFIG_DRIVER_DM9000这个宏是x210_sd.h中定义的，这个宏用来配置开发板的网卡的。dm9000_pre_init函数就是对应的DM9000网卡的初始化函数。开发板移植uboot时，如果要移植网卡，主要的工作就在这里。

(4)这个函数中主要是网卡的GPIO和端口的配置，而不是驱动。因为网卡的驱动都是现成的正确的，移植的时候驱动是不需要改动的，关键是这里的基本初始化。因为这些基本初始化是硬件相关的。

 

 

## 2.6.5.start_armboot解析3

背景：关于DDR的配置：

(1)board_init中除了网卡的初始化之外，剩下的2行用来初始化DDR。

(2)**注意：**这里的初始化DDR和汇编阶段lowlevel_init中初始化DDR是不同的。当时是硬件的初始化，目的是让DDR可以开始工作。现在是软件结构中一些DDR相关的属性配置、地址设置的初始化，是纯软件层面的。

(3)软件层次初始化DDR的原因：对于uboot来说，他怎么知道开发板上到底有几片DDR内存，每一片的起始地址、长度这些信息呢？在uboot的设计中采用了一种简单直接有效的方式：程序员在移植uboot到一个开发板时，程序员自己在x210_sd.h中使用宏定义去配置出来板子上DDR内存的信息，然后uboot只要读取这些信息即可。（实际上还有另外一条思路：就是uboot通过代码读取硬件信息来知道DDR配置，但是uboot没有这样。实际上PC的BIOS采用的是这种）

 

\#define CONFIG_NR_DRAM_BANKS  2     /* we have 2 bank of DRAM */

\#define SDRAM_BANK_SIZE     0x10000000  /* 512 MB lqm*/

//#define SDRAM_BANK_SIZE     0x20000000  /* 1GB lqm*/

\#define PHYS_SDRAM_1      MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */

\#define PHYS_SDRAM_1_SIZE    SDRAM_BANK_SIZE

\#define PHYS_SDRAM_2      MEMORY_BASE_ADDRESS2 /* SDRAM Bank #2 */

\#define PHYS_SDRAM_2_SIZE    SDRAM_BANK_SIZE

 

\#define CFG_FLASH_BASE   0x80000000

 

(4)x210_sd.h的496行到501行中使用了标准的宏定义来配置DDR相关的参数。主要配置了这么几个信息：有几片DDR内存、每一片DDR的起始地址、长度。这里的配置信息我们在uboot代码中使用到内存时就可以从这里提取使用（想象uboot中使用到内存的地方都不是直接用地址数字的，都是用宏定义的）

 

### 2.6.5.1、gd->bd->bi_arch_number

\#define MACH_TYPE    2456

(1)bi_arch_number是board_info中的一个元素，含义是：开发板的机器码。所谓机器码就是uboot给这个开发板定义的一个唯一编号。

(2)机器码的主要作用就是在uboot和linux内核之间进行比对和适配。

(3)嵌入式设备中每一个设备的硬件都是定制化的，不能通用。嵌入式设备的高度定制化导致硬件和软件不能随便适配使用。这就告诉我们：这个开发板移植的内核镜像绝对不能下载到另一个开发板去，否则也不能启动，就算启动也不能正常工作，有很多隐患。

**因此linux做了个设置：**给每个开发板做个唯一编号（机器码），然后在uboot、linux内核中都有一个软件维护的机器码编号。然后开发板、uboot、linux三者去比对机器码，如果机器码对上了就启动，否则就不启动（因为软件认为我和这个硬件不适配）。

(4)MACH_TYPE在x210_sd.h中定义，值是2456，并没有特殊含义，只是当前开发板对应的编号。这个编号就代表了x210这个开发板的机器码，将来这个开发板上面移植的linux内核中的机器码也必须是2456，否则就启动不起来。

(5)uboot中配置的这个机器码，会作为uboot给linux内核的传参的一部分传给linux内核，内核启动过程中会比对这个接收到的机器码，和自己本身的机器码相对比，如果相等就启动，如果不想等就不启动。

(6)理论上来说，一个开发板的机器码不能自己随便定。理论来说有权利去发放这个机器码的只有uboot官方，所以我们做好一个开发板并且移植了uboot之后，理论上应该提交给uboot官方审核并发放机器码（好像是免费的）。但是国内的开发板基本都没有申请（主要是因为国内开发者英文都不行，和国外开源社区接触比较少），都是自己随便编号的。随便编号的问题就是有可能和别人的编号冲突，但是只要保证uboot和kernel中的编号是一致的，就不影响自己的开发板启动。

 

### 2.6.5.2、gd->bd->bi_boot_params

(1)bd_info中另一个主要元素，bi_boot_params表示uboot给linux kernel**启动时的传参的内存地址**。也就是说uboot给linux内核传参的时候是这么传的：uboot事先将准备好的传参（字符串，就是bootargs）放在内存的一个地址处（就是bi_boot_params），然后uboot就启动了内核（uboot在启动内核时真正是通过寄存器r0 r1 r2来直接传递参数的，其中有一个寄存器中就是bi_boot_params）。内核启动后从寄存器中读取bi_boot_params就知道了uboot给我传递的参数到底在内存的哪里。然后自己去内存的那个地方去找bootargs。

(2)经过计算得知：X210中bi_boot_params的值为0x30000100，这个内存地址就被分配用来做内核传参了。所以在uboot的其他地方使用内存时要注意，千万不敢把这里给淹没了。

 

## 2.6.6.start_armboot解析4

### 2.6.6.1、interrupt_init

 

int interrupt_init(void)

{

 

  S5PC11X_TIMERS *const timers = S5PC11X_GetBase_TIMERS();

 

  /* use PWM Timer 4 because it has no output */

  /* prescaler for Timer 4 is 16 */

  timers->TCFG0 = 0x0f00;

  if (timer_load_val == 0) {

​    /*

​     \* for 10 ms clock period @ PCLK with 4 bit divider = 1/2

​     \* (default) and prescaler = 16. Should be 10390

​     \* @33.25MHz and @ 66 MHz

​     */

​    timer_load_val = get_PCLK() / (16 * 100);

  }

 

  /* load value for 10 ms timeout */

  lastdec = timers->TCNTB4 = timer_load_val;

  /* auto load, manual update of Timer 4 */

  timers->TCON = (timers->TCON & ~0x00700000) | TCON_4_AUTO | TCON_4_UPDATE;

  /* auto load, start Timer 4 */

  timers->TCON = (timers->TCON & ~0x00700000) | TCON_4_AUTO | COUNT_4_ON;

  timestamp = 0;

 

  return (0);

}

 

(1)看名字函数是和中断初始化有关的，但是实际上不是，实际上这个函数是用来初始化定时器的（实际使用的是Timer4）。

(2)裸机中讲过：210共有5个PWM定时器。其中Timer0-timer3都有一个对应的PWM信号输出的引脚。而Timer4没有引脚，无法输出PWM波形。Timer4在设计的时候就不是用来输出PWM波形的（没有引脚，没有TCMPB寄存器），这个定时器被设计用来做计时。

(3)Timer4用来做计时时要使用到2个寄存器：TCNTB4、TCNTO4。TCNTB中存了一个数，这个数就是定时次数（每一次时间是由时钟决定的，其实就是由2级时钟分频器决定的）。我们定时时只需要把定时时间/基准时间=数，将这个数放入TCNTB中即可；我们通过TCNTO寄存器即可读取时间有没有减到0，读取到0后就知道定的时间已经到了。

(4)使用Timer4来定时，因为没有中断支持，所以CPU不能做其他事情同时定时，CPU只能使用轮询方式来不断查看TCNTO寄存器才能知道定时时间到了没。因为Timer4的定时是不能实现微观上的并行。uboot中定时就是通过Timer4来实现定时的。所以uboot中定时时不能做其他事（考虑下，典型的就是bootdelay，bootdelay中实现定时并且检查用户输入是用轮询方式实现的，原理参考裸机中按键章节中的轮询方式处理按键）

(5)interrupt_init函数将timer4设置为定时10ms。关键部位就是get_PCLK函数获取系统设置的PCLK_PSYS时钟频率，然后设置TCFG0和TCFG1进行分频，然后计算出设置为10ms时需要向TCNTB中写入的值，将其写入TCNTB，然后设置为auto reload模式，然后开定时器开始计时就没了。

总结：在学习这个函数时，注意标准代码和之前裸机代码中的区别，重点学会：通过定义结构体的方式来访问寄存器，通过函数来自动计算设置值以设置定时器。

 

### 2.6.6.2、env_init

int env_init(void)

{

\#if defined(ENV_IS_EMBEDDED) //未定义

 ……

 ……

\#else /* ENV_IS_EMBEDDED */

  gd->env_addr = (ulong)&default_environment[0];

  gd->env_valid = 1;

\#endif /* ENV_IS_EMBEDDED */

 

  return (0);

}

 

(1)env_init，看名字就知道是和环境变量有关的初始化。

(2)为什么有很多env_init函数，主要原因是uboot支持各种不同的启动介质（譬如norflash、nandflash、inand、sd卡·····），我们一般从哪里启动就会把环境变量env放到哪里。而各种介质存取操作env的方法都是不一样的。因此uboot支持了各种不同介质中env的操作方法。所以有好多个env_xx开头的c文件。实际使用的是哪一个要根据自己开发板使用的存储介质来定（这些env_xx.c同时只有1个会起作用，其他是不能进去的，通过x210_sd.h中配置的宏来决定谁被包含的），对于x210来说，我们应该看env_movi.c中的函数。

(3)经过基本分析，这个函数只是对内存里维护的那一份uboot的env做了基本的初始化或者说是判定（判定里面有没有能用的环境变量）。当前因为我们还没进行环境变量从SD卡到DDR中的relocate，因此当前环境变量是不能用的。

(4)在start_armboot函数中（776行）调用env_relocate才进行环境变量从SD卡中到DDR中的重定位。重定位之后需要环境变量时才可以从DDR中去取，重定位之前如果要使用环境变量只能从SD卡中去读取。

 

 

## 2.6.7.start_armboot解析5

### 2.6.7.1、init_baudrate

static int init_baudrate (void)

{

  char tmp[64];  /* long enough for environment variables */

  int i = getenv_r ("baudrate", tmp, sizeof (tmp));

  gd->bd->bi_baudrate = gd->baudrate = (i > 0)

​      ? (int) simple_strtoul (tmp, NULL, 10)

​      : CONFIG_BAUDRATE;

 

  return (0);

}

 

(1)init_baudrate看名字就是初始化串口通信的波特率的。

(2)getenv_r函数用来读取环境变量的值。用getenv函数读取环境变量中“baudrate”的值（注意读取到的不是int型而是字符串类型），然后用simple_strtoul函数将字符串转成数字格式的波特率。

(3)baudrate初始化时的规则是：先去环境变量中读取"baudrate"这个环境变量的值。如果读取成功则使用这个值作为环境变量，记录在gd->baudrate和gd->bd->bi_baudrate中；如果读取不成功则使用x210_sd.h中的的CONFIG_BAUDRATE的值作为波特率。从这可以看出：环境变量的优先级是很高的。

 

### 2.6.7.2、serial_init

int serial_init(void)

{

  serial_setbrg();

 

  return (0);

}

 

 

void serial_setbrg(void)

{

  DECLARE_GLOBAL_DATA_PTR;

 

  int i;

  for (i = 0; i < 100; i++);

}

 

(1)serial_init看名字是初始化串口的。（疑问：start.S中调用的lowlevel_init.S中已经使用汇编初始化过串口了，这里怎么又初始化？这两个初始化是重复的还是各自有不同？）.

(2)SI中可以看出uboot中有很多个serial_init函数，我们使用的是uboot/cpu/s5pc11x/serial.c中的serial_init函数。

(3)进来后发现serial_init函数其实什么都没做。因为在汇编阶段串口已经被初始化过了，因此这里就不再进行硬件寄存器的初始化了。

 

 

## 2.6.8.start_armboot解析6

### 2.6.8.1、console_init_f

int console_init_f (void)

{

  gd->have_console = 1;

 

\#ifdef CONFIG_SILENT_CONSOLE

  if (getenv("silent") != NULL)

​    gd->flags |= GD_FLG_SILENT;

\#endif

 

  return (0);

}

(1)console_init_f是console（控制台）的第一阶段初始化。**_f****表示是第一阶段初始化，_r表示第二阶段初始化**。有时候初始化函数不能一次一起完成，中间必须要夹杂一些代码，因此将完整的一个模块的初始化分成了2个阶段。（我们的uboot中start_armboot的826行进行了console_init_r的初始化）

(2)console_init_f在uboot/common/console.c中，仅仅是对gd->have_console设置为1而已，其他事情都没做。

 

### 2.6.8.2、display_banner

static int display_banner (void)

{

  printf ("\n\n%s\n\n", version_string);

  debug ("U-Boot code: %08lX -> %08lX BSS: -> %08lX\n",

​      _armboot_start, _bss_start, _bss_end);

\#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */

  debug("\t\bMalloc and Stack is above the U-Boot Code.\n");

\#else

  debug("\t\bMalloc and Stack is below the U-Boot Code.\n");

\#endif

\#ifdef CONFIG_MODEM_SUPPORT

  debug ("Modem Support enabled\n");

\#endif

\#ifdef CONFIG_USE_IRQ

  debug ("IRQ Stack: %08lx\n", IRQ_STACK_START);

  debug ("FIQ Stack: %08lx\n", FIQ_STACK_START);

\#endif

  open_backlight();//lqm.

  //open_gprs();

 

  return (0);

}

 

 

 

(1)display_banner用来串口输出显示uboot的logo

(2)display_banner中使用printf函数向串口输出了version_string这个字符串。那么上面的分析表示console_init_f并没有初始化好console怎么就可以printf了呢？

(3)通过追踪printf的实现，发现printf->puts，而puts函数中会判断当前uboot中console有没有被初始化好。如果console初始化好了则调用fputs完成串口发送（这条线才是控制台）；如果console尚未初始化好则会调用serial_puts(再调用serial_putc直接操作串口寄存器进行内容发送)。

(4)控制台也是通过串口输出，非控制台也是通过串口输出。究竟什么是控制台？和不用控制台的区别？实际上分析代码会发现，控制台就是一个用软件虚拟出来的设备，这个设备有一套专用的通信函数（发送、接收···），控制台的通信函数最终会映射到硬件的通信函数中来实现。uboot中实际上控制台的通信函数是直接映射到硬件串口的通信函数中的，也就是说uboot中用没用控制器其实并没有本质差别。

(5)但是在别的体系中，控制台的通信函数映射到硬件通信函数时可以用软件来做一些中间优化，譬如说缓冲机制。（操作系统中的控制台都使用了缓冲机制，所以有时候我们printf了内容但是屏幕上并没有看到输出信息，就是因为被缓冲了。我们输出的信息只是到了console的buffer中，buffer还没有被刷新到硬件输出设备上，尤其是在输出设备是LCD屏幕时）

const char version_string[] =

  U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")"CONFIG_IDENT_STRING;

 

(6)U_BOOT_VERSION在uboot源代码中找不到定义，这个变量实际上是在makefile中定义的，然后在编译时生成的include/version_autogenerated.h中用一个宏定义来实现的。

 

### 2.6.8.3、print_cpuinfo

(1)uboot启动过程中：

CPU: S5PV210@1000MHz(OK)

​    APLL = 1000MHz, HclkMsys = 200MHz, PclkMsys = 100MHz

​    MPLL = 667MHz, EPLL = 96MHz

​            HclkDsys = 166MHz, PclkDsys = 83MHz

​            HclkPsys = 133MHz, PclkPsys = 66MHz

​            SCLKA2M = 200MHz

Serial = CLKUART 

这些信息都是print_cpuinfo打印出来的。

int print_cpuinfo(void)

{

  uint set_speed;

  uint tmp;

  uchar result_set;

 

\#if defined(CONFIG_CLK_533_133_100_100)

  set_speed = 53300;

\#elif defined(CONFIG_CLK_667_166_166_133)

  set_speed = 66700;

\#elif defined(CONFIG_CLK_800_200_166_133)

  set_speed = 80000;

\#elif defined(CONFIG_CLK_1000_200_166_133)

  set_speed = 100000;

\#elif defined(CONFIG_CLK_1200_200_166_133)

  set_speed = 120000;

\#else

  set_speed = 100000;

  printf("Any CONFIG_CLK_XXX is not enabled\n");

\#endif

  tmp = (set_speed / (get_ARMCLK()/1000000));

 

  if((tmp < 105) && (tmp > 95)){

​    result_set = 1;

  } else {

​    result_set = 0;

  }

 

\#ifdef CONFIG_MCP_SINGLE

  printf("\nCPU: S5PV210@%ldMHz(%s)\n", get_ARMCLK()/1000000, ((result_set == 1) ? "OK" : "FAIL"));

\#else

  printf("\nCPU: S5PC110@%ldMHz(%s)\n", get_ARMCLK()/1000000, ((result_set == 1) ? "OK" : "FAIL"));

\#endif

  printf("    APLL = %ldMHz, HclkMsys = %ldMHz, PclkMsys = %ldMHz\n",

​      get_FCLK()/1000000, get_HCLK()/1000000, get_PCLK()/1000000);

\#if 1

  printf("  MPLL = %ldMHz, EPLL = %ldMHz\n",

​      get_MPLL_CLK()/1000000, get_PLLCLK(EPLL)/1000000);

  printf("        HclkDsys = %ldMHz, PclkDsys = %ldMHz\n",

​      get_HCLKD()/1000000, get_PCLKD()/1000000);

  printf("        HclkPsys = %ldMHz, PclkPsys = %ldMHz\n",

​      get_HCLKP()/1000000, get_PCLKP()/1000000);

  printf("        SCLKA2M = %ldMHz\n", get_SCLKA2M()/1000000);

\#endif

  puts("Serial = CLKUART ");

 

  return 0;

}

 

(2)回顾ARM裸机中时钟配置一章的内容，比对这里调用的函数中计算各种时钟的方法，自己去慢慢分析体会这些代码的原理和实现方法。这就是学习。

 

 

## 2.6.9.start_armboot解析7

### 2.6.9.1、checkboard

int checkboard(void)

{

\#ifdef CONFIG_MCP_SINGLE

\#if defined(CONFIG_VOGUES)

  printf("\nBoard:  VOGUESV210\n");

\#else

  printf("\nBoard:  X210\n");

\#endif //CONFIG_VOGUES

\#else

  printf("\nBoard:  X210\n");

\#endif

  return (0);

   }

 

 

(1)checkboard看名字是检查、确认开发板的意思。这个函数的作用就是检查当前开发板是哪个开发板并且打印出开发板的名字。

 

### 2.6.9.2、init_func_i2c

\#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)

static int init_func_i2c (void)

{

  puts ("I2C:  ");

  i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);

  puts ("ready\n");

  return (0);

}

\#endif

 

\#undef CONFIG_S3C64XX_I2C    /* this board has H/W I2C */

\#ifdef CONFIG_S3C64XX_I2C

\#define CONFIG_HARD_I2C   1

\#define CFG_I2C_SPEED    50000

\#define CFG_I2C_SLAVE    0xFE

\#endif

 

\#undef CONFIG_S3C64XX_I2C  undef 显示是没有定义,所以下面两个宏都不成立;

 

(1)这个函数实际没有被执行，X210的uboot中并没有使用I2C。如果将来我们的开发板要扩展I2C来接外接硬件，则在x210_sd.h中配置相应的宏即可开启。

 

### 2.6.9.3、uboot学习实践

(1)对uboot源代码进行完修改（修改内容根据自己的理解和分析来修改）

(2)make distclean然后make x210_sd_config然后make

(3)编译完成得到u-boot.bin，然后去烧录。烧录方法按照裸机第三部分讲的linux下使用dd命令来烧写的方法来烧写。

(4)烧写过程：

第一步：进入sd_fusing目录下

第二步：make clean

第三步：make

第四步：插入sd卡，ls /dev/sd*得到SD卡在ubuntu中的设备号（一般是/dev/sdb，注意SD卡要连接到虚拟机ubuntu中，不要接到windows中）

第五步：./sd_fusing.sh /dev/sdb完成烧录（注意不是sd_fusing2.sh）

(5)总结：uboot就是个庞大点复杂点的裸机程序而已，我们完全可以对他进行调试。调试的方法就是按照上面步骤，根据自己对代码的分析和理解对代码进行更改，然后重新编译烧录运行，根据运行结果来学习。

 

 

## 2.6.10.start_armboot解析8

### 2.6.10.1、dram_init

int dram_init(void)

{

  DECLARE_GLOBAL_DATA_PTR;

 

  gd->bd->bi_dram[0].start = PHYS_SDRAM_1;

  gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;

 

\#if defined(PHYS_SDRAM_2)

  gd->bd->bi_dram[1].start = PHYS_SDRAM_2;

  gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;

\#endif

 

\#if defined(PHYS_SDRAM_3)

  gd->bd->bi_dram[2].start = PHYS_SDRAM_3;

  gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;

\#endif

 

  return 0;

}

 

 struct       /* RAM configuration */

  {

  ulong start;

  ulong size;

  }      bi_dram[CONFIG_NR_DRAM_BANKS];

 

 

(1)dram_init看名字是关于DDR的初始化。疑问：在汇编阶段已经初始化过DDR了否则也无法relocate到第二部分运行，怎么在这里又初始化DDR？

(2)dram_init都是在给gd->bd里面关于DDR配置部分的全局变量赋值，让gd->bd数据记录下当前开发板的DDR的配置信息，以便uboot中使用内存。

(3)从代码来看，其实就是初始化gd->bd->bi_dram这个结构体数组。

 

### 2.6.10.2、display_dram_config

static int display_dram_config (void)

{

  int i;

 

\#ifdef DEBUG

  puts ("RAM Configuration:\n");

 

  for(i=0; i<CONFIG_NR_DRAM_BANKS; i++) {

​    printf ("Bank #%d: %08lx ", i, gd->bd->bi_dram[i].start);

​    print_size (gd->bd->bi_dram[i].size, "\n");

  }

\#else

  ulong size = 0;

 

  for (i=0; i<CONFIG_NR_DRAM_BANKS; i++) {

​    size += gd->bd->bi_dram[i].size;

  }

 

  puts("DRAM:  ");

  print_size(size, "\n");

\#endif

 

  return (0);

}

 

 

(1)看名字意思就是打印显示dram的配置信息。

(2)启动信息中的：（DRAM:  512 MB）就是在这个函数中打印出来的。

(3)思考：如何在uboot运行中得知uboot的DDR配置信息？uboot中有一个命令叫**bdinfo**，这个命令可以打印出gd->bd中记录的所有硬件相关的全局变量的值，因此可以得知DDR的配置信息。

DRAM bank  = 0x00000000

-> start  = 0x30000000

-> size   = 0x10000000

DRAM bank  = 0x00000001

-> start  = 0x40000000

-> size   = 0x10000000

 

### 2.6.10.3、init_sequence总结

都是板级硬件的初始化以及gd、gd->bd中的数据结构的初始化。譬如：

(0)、网卡初始化、

(1)、机器码（gd->bd->bi_arch_number）、

(2)、内核传参DDR地址（gd->bd->bi_boot_params）、

(3)、Timer4初始化为10ms一次、

(4)、波特率设置（gd->bd->bi_baudrate和gd->baudrate）、

(5)、console第一阶段初始化（gd->have_console设置为1）、

(6)、打印uboot的启动信息、

(7)、打印cpu相关设置信息、

(8)、检查并打印当前开发板名字、

(9)、DDR配置信息初始化（gd->bd->bi_dram）、

(10)、打印DDR总容量。

 

总结回顾：本节课结束后已经到了start_armboot的第487行。下节课开始继续往下看。

 

 

## 2.6.11.start_armboot解析9

### 2.6.11.1、CFG_NO_FLASH

\#ifndef CFG_NO_FLASH

​     /* configure available FLASH banks */

  size = flash_init ();

  display_flash_config (size);

\#endif /* CFG_NO_FLASH */

 

 

 (1)虽然NandFlash和NorFlash都是Flash，但是一般NandFlash会简称为Nand而不是Flash，一般讲Flash都是指的Norflash。这里2行代码是Norflash相关的。

(2)flash_init执行的是开发板中对应的NorFlash的初始化、display_flash_config打印的也是NorFlash的配置信息（Flash:  8 MB就是这里打印出来的）。但是实际上X210中是没有Norflash的。所以着两行代码是可以去掉的（我也不知道为什么没去掉？猜测原因有可能是去掉着两行代码会导致别的地方工作不正常，需要花时间去移植调试，然后移植的人就懒得弄。实际上不去掉除了显示有8MB Flash实际没用之外也没有别的影响）

 

CONFIG_VFD和CONFIG_LCD是显示相关的，这个是uboot中自带的LCD显示的软件架构。但是实际上我们用LCD而没有使用uboot中设置的这套软件架构，我们自己在后面自己添加了一个LCD显示的部分。

 

### 2.6.11.2、mem_malloc_init

 

  /* armboot_start is defined in the board-specific linker script */

\#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */

  mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE);

\#else

  mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);

\#endif

 

static void mem_malloc_init (ulong dest_addr)

{

  mem_malloc_start = dest_addr;

  mem_malloc_end = dest_addr + CFG_MALLOC_LEN;

  mem_malloc_brk = mem_malloc_start;

 

  memset ((void *) mem_malloc_start, 0,

​      mem_malloc_end - mem_malloc_start);

}

 

 

(1)mem_malloc_init函数用来初始化uboot的堆管理器。

(2)uboot中自己维护了一段堆内存，肯定自己就有一套代码来管理这个堆内存。有了这些东西uboot中你也可以malloc、free这套机制来申请内存和释放内存。我们在DDR内存中给堆预留了896KB的内存。

 

### 2.6.11.3、代码实践，去掉Flash看会不会出错。

结论：加上CONFIG_NOFLASH宏之后编译出错，说明代码移植的不好，那个文件的包含没有被这个宏控制。于是乎移植的人就直接放这没管。

 

 

## 2.6.12.start_armboot解析10

### 2.6.12.1、开发板独有初始化：mmc初始化

(1)从536到768行为开发板独有的初始化。意思是三星用一套uboot同时满足了好多个系列型号的开发板，然后在这里把不同开发板自己独有的一些初始化写到了这里。用#if条件编译配合CONFIG_xxx宏来选定特定的开发板。

\#if defined(CONFIG_X210)

 

  \#if defined(CONFIG_GENERIC_MMC)

​    puts ("SD/MMC: ");

​    mmc_exist = mmc_initialize(gd->bd);

​    if (mmc_exist != 0)

​    {

​      puts ("0 MB\n");

\#ifdef CONFIG_CHECK_X210CV3

​      check_flash_flag=0;//check inand error!

\#endif

​    }

\#ifdef CONFIG_CHECK_X210CV3

​    else

​    {

​      check_flash_flag=1;//check inand ok! 

​    }

\#endif

\#endif

 

\#endif /* CONFIG_X210 */

 

__________________________________________________________________-

int mmc_initialize(bd_t *bis)

{

  struct mmc *mmc;

  int err;

 

  INIT_LIST_HEAD(&mmc_devices);

  cur_dev_num = 0;

 

  if (board_mmc_init(bis) < 0)

​    cpu_mmc_init(bis);

 

\#if defined(DEBUG_S3C_HSMMC)

  print_mmc_devices(',');

\#endif

 

\#ifdef CONFIG_CHECK_X210CV3

  mmc = find_mmc_device(1);//lqm

\#else

  mmc = find_mmc_device(0);

\#endif

  if (mmc) {

​    err = mmc_init(mmc);

​    if (err)

​      err = mmc_init(mmc);

​    if (err) {

​      printf("Card init fail!\n");

​      return err;

​    }

  }

  printf("%ldMB\n", (mmc->capacity/(1024*1024/(1<<9))));

  return 0;

}

 

 

(2)X210相关的配置在599行到632行。

 

(3)mmc_initialize看名字就应该是MMC相关的一些基础的初始化，其实就是用来初始化SoC内部的SD/MMC控制器的。函数在uboot/drivers/mmc/mmc.c里。

(4)uboot中对硬件的操作（譬如网卡、SD卡···）都是借用的linux内核中的驱动来实现的，uboot根目录底下有个drivers文件夹，这里面放的全都是从linux内核中移植过来的各种驱动源文件。

(5)mmc_initialize是具体硬件架构无关的一个MMC初始化函数，所有的使用了这套架构的代码都掉用这个函数来完成MMC的初始化。mmc_initialize中再调用board_mmc_init和cpu_mmc_init来完成具体的硬件的MMC控制器初始化工作。

 

/*

 \* Initializes on-chip MMC controllers.

 \* to override, implement board_mmc_init()

 */

int cpu_mmc_init(bd_t *bis)

{

\#ifdef CONFIG_S3C_HSMMC

  setup_hsmmc_clock();

  setup_hsmmc_cfg_gpio();

  return smdk_s3c_hsmmc_init();

\#else

  return 0;

\#endif

}

 

(6)cpu_mmc_init在uboot/cpu/s5pc11x/cpu.c中，这里面又间接的调用了drivers/mmc/s3c_mmcxxx.c中的驱动代码来初始化硬件MMC控制器。这里面分层很多，分层的思想一定要有，否则完全就糊涂了。

 

 

## 2.6.13.start_armboot解析11

### 2.6.13.1、env_relocate()

void env_relocate (void)

{

 

\#ifdef ENV_IS_EMBEDDED   //未定义

  ……

  ……

\#else

  /*

   \* We must allocate a buffer for the environment

​    申请了16KB（CFG_ENV_SIZE）大小的内存

   */

  env_ptr = (env_t *)malloc (CFG_ENV_SIZE);

\#endif

 

  if (gd->env_valid == 0) {

  ……

  ……

  }

  else {

​    env_relocate_spec (); // 

  }

  gd->env_addr = (ulong)&(env_ptr->data);

 

}

 

​    （Sheridan）因为armboot 函数前面的env_init()；已经将gd->env_vail 初始化为1；并且将default_environment 默认环境变量赋值给gd->env_addr;

所以这里执行的是env_relocate_spec();这个函数；但是env_relocata_spec();这个函数在很多个文件当中都有，我们的板子使用的inand，但是没有inand相关的.c文件。以为inand(闪迪)和movinand（三星）都是通用（都在nand的内部加入了MCU的控制单元），所以应该执行env_movi.c。但是因为可移植行其实执行的是envi_auto.c 中的 void env_relocate_spec_movinand(void)函数：

 

void env_relocate_spec_movinand(void)

{

\#if !defined(ENV_IS_EMBEDDED)

\#if defined(CONFIG_CMD_MOVINAND)

  uint *magic = (uint*)(PHYS_SDRAM_1);

 

  if ((0x24564236 != magic[0]) || (0x20764316 != magic[1])) {

​    movi_read_env(virt_to_phys((ulong)env_ptr));

  }

  //经过测试，crc32校验成功，不执行，use_default;

if (crc32(0, env_ptr->data, ENV_SIZE) != env_ptr->crc)  

 

​    return use_default();

\#endif /* CONFIG_CMD_MOVINAND */

\#endif /* ! ENV_IS_EMBEDDED */

}

 

(1)env_relocate是环境变量的重定位，完成从SD卡中将环境变量读取到DDR中的任务。

(2)环境变量到底从哪里来？SD卡中有一些（8个）独立的扇区作为环境变量存储区域的。但是我们烧录/部署系统时，我们只是烧录了uboot分区、kernel分区和rootfs分区，根本不曾烧录env分区。所以当我们烧录完系统第一次启动时ENV分区是空的，本次启动uboot尝试去SD卡的ENV分区读取环境变量时失败（读取回来后进行CRC校验时失败），**我们uboot选择从uboot内部代码中设置的一套默认的环境变量出发来使用（这就是默认环境变量）**；

**这套默认的环境变量在本次运行时会被读取到DDR中的环境变量中，然后被写入（也可能是你saveenv时写入，也可能是uboot设计了第一次读取默认环境变量后就写入）SD卡的ENV分区**。然后下次再次开机时uboot就会从SD卡的ENV分区读取环境变量到DDR中，这次读取就不会失败了。

 (3)真正的从SD卡到DDR中重定位ENV的代码是在env_relocate_spec内部的movi_read_env完成的。

​    movi_read_env(virt_to_phys((ulong)env_ptr));

  

三个函数： movi_read_env把sd卡中的uboot的环境变量分区复制到env_ptr中；

　　　　　crc32 计算内存中环境变量的crc的值，如果不相等则执行

　　　　　use_default函数　

static void use_default()

{

  puts ("*** Warning - bad CRC or moviNAND, using default environment\n\n");

 

  if (default_environment_size > CFG_ENV_SIZE){

​    puts ("*** Error - default environment is too large\n\n");

​    return;

  }

 

  memset (env_ptr, 0, sizeof(env_t));

  memcpy (env_ptr->data,

​      default_environment,

​      default_environment_size);

  env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);

  gd->env_valid = 1;

}

 

use_default CRC校验失败，一位置函数就是movi_rad_env函数从SD卡环境变量分区失败，将default_environment 中的环境变量重定位到DDR中；

## 2.6.14.start_armboot解析12

### 2.6.14.1、IP地址、MAC地址的确定

/* IP Address */

gd->bd->bi_ip_addr = getenv_IPaddr ("ipaddr");

 

 

IPaddr_t getenv_IPaddr (char *var)

{

  return (string_to_ip(getenv(var)));

}

 

 

(1)开发板的IP地址是在gd->bd中维护的，来源于环境变量ipaddr。getenv函数用来获取字符串格式的IP地址，然后用**string_to_ip**将字符串格式的IP地址转成字符串格式的点分十进制格式。

(2)IP地址由4个0-255之间的数字组成，因此一个IP地址在程序中最简单的存储方法就是一个**unsigend int**。但是人类容易看懂的并不是这种类型，而是**点分十进制类型**（192.168.1.2）。这两种类型可以互相转换。

​    

  /* MAC Address */

  {

​    int i;

​    ulong reg;

​    char *s, *e;

​    char tmp[64];

 

​    i = getenv_r ("ethaddr", tmp, sizeof (tmp));

​    s = (i > 0) ? tmp : NULL;

 

​    for (reg = 0; reg < 6; ++reg) {

​      gd->bd->bi_enetaddr[reg] = s ? simple_strtoul (s, &e, 16) : 0;

​      if (s)

​        s = (*e) ? e + 1 : e;

​    }

 

### 2.6.14.2、devices_init

int devices_init (void)

{

\#ifndef CONFIG_ARM   /* already relocated for current ARM implementation */

  ulong relocation_offset = gd->reloc_off;

  int i;

 

  /* relocate device name pointers */

  for (i = 0; i < (sizeof (stdio_names) / sizeof (char *)); ++i) {

​    stdio_names[i] = (char *) (((ulong) stdio_names[i]) +

​            relocation_offset);

  }

\#endif

 

  /* Initialize the list */

  devlist = ListCreate (sizeof (device_t));

 

  if (devlist == NULL) {

​    eputs ("Cannot initialize the list of devices!\n");

​    return -1;

  }

\#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)

  i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);

\#endif

\#ifdef CONFIG_LCD

  drv_lcd_init ();

\#endif

\#if defined(CONFIG_VIDEO) || defined(CONFIG_CFB_CONSOLE)

  drv_video_init ();

\#endif

\#ifdef CONFIG_KEYBOARD

  drv_keyboard_init ();

\#endif

\#ifdef CONFIG_LOGBUFFER

  drv_logbuff_init ();

\#endif

  drv_system_init ();

\#ifdef CONFIG_SERIAL_MULTI

  serial_devices_init ();

\#endif

\#ifdef CONFIG_USB_TTY

  drv_usbtty_init ();

\#endif

\#ifdef CONFIG_NETCONSOLE

  drv_nc_init ();

\#endif

 

  return (0);

}

 

(1)devices_init看名字就是设备的初始化。这里的设备指的就是开发板上的硬件设备。放在这里初始化的设备都是驱动设备，这个函数本来就是从驱动框架中衍生出来的。uboot中很多设备的驱动是直接移植linux内核的（譬如网卡、SD卡），linux内核中的驱动都有相应的设备初始化函数。linux内核在启动过程中就有一个devices_init(名字不一定完全对，但是差不多)，作用就是集中执行各种硬件驱动的init函数。

(2)uboot的这个函数其实就是从linux内核中移植过来的，它的作用也是去执行所有的从linux内核中继承来的那些硬件驱动的初始化函数。

 

### 2.6.14.3、jumptable_init

 

(1)jumptable跳转表，本身是一个函数指针数组，里面记录了很多函数的函数名。看这阵势是要实现一个函数指针到具体函数的映射关系，将来通过跳转表中的函数指针就可以执行具体的函数。这个其实就是在用C语言实现面向对象编程。在linux内核中有很多这种技巧。

(2)通过分析发现跳转表只是被赋值从未被引用，因此跳转表在uboot中根本就没使用。

 

 

## 2.6.15.start_armboot解析13

### 2.6.15.1、console_init_r

 

 

(1)console_init_f是控制台的第一阶段初始化，console_init_r是第二阶段初始化。实际上第一阶段初始化并没有实质性工作，第二阶段初始化才进行了实质性工作。

(2)uboot中有很多同名函数，使用SI工具去索引时经常索引到不对的函数处（回忆下当时start.S中找lowlevel_init.S时，自动索引找到的是错误的，真正的反而根本没找到。）

(3)console_init_r就是console的纯软件架构方面的初始化（说白了就是去给console相关的数据结构中填充相应的值），所以属于纯软件配置类型的初始化。

(4)uboot的console实际上并没有干有意义的转化，它就是直接调用的串口通信的函数。所以用不用console实际并没有什么分别。（在linux内console就可以提供缓冲机制等不用console不能实现的东西）。

 

### 2.6.15.2、enable_interrupts

(1)看名字应该是中断初始化代码。这里指的是CPSR中总中断标志位的使能。

(2)因为我们uboot中没有使用中断，因此没有定义CONFIG_USE_IRQ宏，因此我们这里这个函数是个空壳子。

(3)uboot中经常出现一种情况就是根据一个宏是否定义了来条件编译决定是否调用一个函数内部的代码。

uboot中有2种解决方案来处理这种情况：

方案一：在调用函数处使用条件编译，然后函数体实际完全提供代码。

方案二：在调用函数处直接调用，然后在函数体处提供2个函数体，一个是有实体的一个是空壳子，用宏定义条件编译来决定实际编译时编译哪个函数进去。

 

### 2.6.15.3、loadaddr、bootfile两个环境变量

  /* Initialize from environment */

  if ((s = getenv ("loadaddr")) != NULL) {

​    load_addr = simple_strtoul (s, NULL, 16);

  }

\#if defined(CONFIG_CMD_NET)

  if ((s = getenv ("bootfile")) != NULL) {

​    copy_filename (BootFile, s, sizeof (BootFile));

  }    

\#endif

 

(1)这两个环境变量都是内核启动有关的，在启动linux内核时会参考这两个环境变量的值。

 

### 2.6.15.4、board_late_init

(1)看名字这个函数就是开发板级别的一些初始化里比较晚的了，就是晚期初始化。所以晚期就是前面该初始化的都初始化过了，剩下的一些必须放在后面初始化的就在这里了。侧面说明了开发板级别的硬件软件初始化告一段落了。    

(2)对于X210来说，这个函数是空的。

​    

 

## 2.6.16.start_armboot解析14

### 2.6.16.1、eth_initialize

(1)看名字应该是网卡相关的初始化。这里不是SoC与网卡芯片连接时SoC这边的初始化，而是网卡芯片本身的一些初始化。

(2)对于X210（DM9000）来说，这个函数是空的。X210的网卡初始化在board_init函数中，网卡芯片的初始化在驱动中。

 

### 2.6.16.2、x210_preboot_init（LCD和logo显示）

(1)x210开发板在启动起来之前的一些初始化，以及LCD屏幕上的logo显示。

 

### 2.6.16.3、check menukey to update from sd

  /* check menukey to update from sd */

  extern void update_all(void);

  if(check_menu_update_from_sd()==0)//update mode

  {

​    puts ("[LEFT DOWN] update mode\n");

​    run_command("fdisk -c 0",0);

​    update_all();

  }

  else

​    puts ("[LEFT UP] boot mode\n");

 

  /* main_loop() can return to retry autoboot, if so just run it again. */

  for (;;) {

​    main_loop ();

  }

 

  /* NOTREACHED - no way out of command loop except booting */

}

 

 

(1)uboot启动的最后阶段设计了一个自动更新的功能。就是：我们可以将要升级的镜像放到SD卡的固定目录中，然后开机时在uboot启动的最后阶段检查升级标志（是一个按键。按键中标志为"LEFT"的那个按键，这个按键如果按下则表示update mode，如果启动时未按下则表示boot mode）。如果进入update mode则uboot会自动从SD卡中读取镜像文件然后烧录到iNand中；如果进入boot mode则uboot不执行update，直接启动正常运行。

(2)这种机制能够帮助我们快速烧录系统，常用于量产时用SD卡进行系统烧录部署。

 

### 2.6.16.4、死循环

(1)解析器

(2)开机倒数自动执行

(3)命令补全

 

## 2.6.17.uboot启动2阶段总结

### 2.6.17.1、启动流程回顾、重点函数标出

(1)第二阶段主要是对开发板级别的硬件、软件数据结构进行初始化。

(2)

​    init_sequence

​       cpu_init  空的

​       board_init   网卡、机器码、内存传参地址

​           dm9000_pre_init         网卡

​           gd->bd->bi_arch_number 机器码

​           gd->bd->bi_boot_params 内存传参地址

​       interrupt_init 定时器

​       env_init

​       init_baudrate gd数据结构中波特率

​       serial_init    空的

​       console_init_f 空的

​       display_banner   打印启动信息

​       print_cpuinfo 打印CPU时钟设置信息

​       checkboard      检验开发板名字

​       dram_init    gd数据结构中DDR信息

​       display_dram_config  打印DDR配置信息表

​    mem_malloc_init     初始化uboot自己维护的堆管理器的内存

​    mmc_initialize       inand/SD卡的SoC控制器和卡的初始化

​    env_relocate     环境变量重定位

​    gd->bd->bi_ip_addr  gd数据结构赋值

​    gd->bd->bi_enetaddr gd数据结构赋值

​    devices_init      空的

​      jumptable_init       不用关注的

​    console_init_r    真正的控制台初始化

​    enable_interrupts 空的

​    loadaddr、bootfile    环境变量读出初始化全局变量

​    board_late_init       空的

​    eth_initialize     空的

​    x210_preboot_init LCD初始化和显示logo

​    check_menu_update_from_sd   检查自动更新

​    main_loop          主循环

 

 

### 2.6.17.2、启动过程特征总结

(1)第一阶段为汇编阶段、第二阶段为C阶段

(2)第一阶段在SRAM中、第二阶段在DRAM中。

(3)第一阶段注重SoC内部、第二阶段注重SoC外部Board内部

 

### 2.6.17.3、移植时的注意点

(1)x210_sd.h头文件中的宏定义

(2)特定硬件的初始化函数位置（譬如网卡）

 

 

 

 

 

 

 

 

 



 

# 第七章 uboot源码分析3-uboot如何启动内核

## 2.7.0 章节概要

**2.7.1.uboot和内核到底是什么**

​    本节先从宏观上讲述uboot和内核的实质，他们的静态部署和运行时的加载运行过程等，目的是从不同角度让大家理解OS启动过程。

**2.7.2.启动内核第一步：加载内核到DDR中**

​    本节讲述系统部署细节参数和启动介质中的分区，这些是内核启动的第一阶段，目的是将内核镜像从启动介质中搬移到ddr中适当位置处。

**2.7.3.zImage和uImage的区别联系**

​    本节开始介绍bootm命令，该命令实现从DDR内存中的内核镜像处启动。

**2.7.4.zImage启动细节** 

​    本节详细结束zImage镜像启动时do_bootm函数中对镜像头的校验

**2.7.5.uImage启动**

​    本节讲解uImage启动和FDT方式启动，主要在于uImage启动时打印信息的流程讲解，通过分析让大家了解函数运行轨迹。

**2.7.6.do_bootm_linux函数** 

​    本节开始讲解uboot启动内核第三阶段，即do_bootm_linux函数。

**2.7.7.传参详解**

​    本节详细介绍do_bootm_linux函数中的传参设计，目的是让大家进一步了解uboot向内核传递启动参数的技术细节。

**2.7.8.uboot启动内核的总结**

​    本节对本课程做总结，重点是uboot启动内核的4个步骤。目的是让大家再次回顾整个启动过程，加深理解和印象。

​    

## 2.7.1.uboot和内核到底是什么

### 2.7.1.1、uboot是一个裸机程序

(1)uboot的本质就是一个复杂点的裸机程序。和我们在ARM裸机全集中学习的每一个裸机程序并没有本质区别。

(2)ARM裸机第十六部分写了个简单的shell，这东西其实就是个mini型的uboot。

### 2.7.1.2、内核本身也是一个"裸机程序"

(1)操作系统内核本身就是一个裸机程序，和uboot、和其他裸机程序并没有本质区别。

(2)**区别**：就是操作系统运行起来后在软件上分为内核层和应用层，分层后两层的权限不同，内存访问和设备操作的管理上更加精细（内核可以随便访问各种硬件，而应用程序只能被限制的访问硬件和内存地址）。

 

直观来看：uboot的镜像是u-boot.bin，linux系统的镜像是zImage，这两个东西其实都是两个裸机程序镜像。从系统的启动角度来讲，内核其实就是一个大的复杂点裸机程序。

 

### 2.7.1.3、部署在SD卡中特定分区内

(1)一个完整的软件+硬件的嵌入式系统，

**静止时**（未上电时）bootloader、kernel、rootfs等必须的软件都以镜像的形式存储在启动介质中（X210中是iNand/SD卡）；

**运行时**都是在DDR内存中运行的，与存储介质无关。上面2个状态都是稳定状态，

第3个状态是**动态过程**，即从静止态到运行态的过程，也就是启动过程。

(2)动态启动过程就是一个从SD卡逐步搬移到DDR内存，并且运行启动代码进行相关的硬件初始化和软件架构的建立，最终达到运行时稳定状态。

(3)静止时u-boot.bin zImage rootfs都在SD卡中，他们不可能随意存在SD卡的任意位置，因此需要对SD卡进行一个分区，然后将各种镜像各自存在各自的分区中，这样在启动过程中uboot、内核等就知道到哪里去找谁。（uboot和kernel中的分区表必须一致，同时和SD卡的实际使用的分区要一致）。

 

### 2.7.1.4、运行时必须先加载到DDR中链接地址处

(1)uboot在第一阶段中进行重定位时将第二阶段（整个uboot镜像）加载到DDR的0xc3e00000地址处，这个地址就是uboot的链接地址。

(2)内核也有类似要求，uboot启动内核时将内存从SD卡读取放到DDR中（其实就是个重定位的过程），不能随意放置，必须放在内核的链接地址处，否则启动不起来。譬如我们使用的内核链接地址是0x30008000。

 

### 2.7.1.5、内核启动需要必要的启动参数

(1)uboot是无条件启动的，从零开始启动的。

(2)内核是不能开机自动完全从零开始启动的，内核启动要别人帮忙。uboot要帮助内核实现重定位（从SD卡到DDR），uboot还要给内核提供启动参数。

 

 

## 2.7.2.启动内核第一步：加载内核到DDR中 

(1)uboot要启动内核，分为2个步骤：

第一步是将内核镜像从启动介质中加载到DDR中；

第二步是去DDR中启动内核镜像。（内核代码根本就没考虑重定位，因为内核知道会有uboot之类的把自己加载到DDR中链接地址处的，所以内核直接就是从链接地址处开始运行的）。

 

### 2.7.2.1、静态内核镜像在哪里？

(1)SD卡/iNand/Nand/NorFlash等：raw分区

常规启动时各种镜像都在SD卡中，因此uboot只需要从SD卡的kernel分区去读取内核镜像到DDR中即可。读取要使用uboot的命令来读取（譬如X210的iNand版本是movi命令，X210的Nand版本就是Nand命令）。

(2)这种启动方式来加载ddr，使用命令：movi read kernel 30008000。其中kernel指的是uboot中的kernel分区（就是uboot中规定的SD卡中的一个区域范围，这个区域范围被设计来存放kernel镜像，就是所谓的kernel分区）。

 

复制到 ddr中 ，movi read kernel 0x30008000

启动命令  bootm 0x30008000

Bootcomd= movi read kernel 0x30008000；bootm 0x30008000 所以开机会自己启动；

(2)tftp、nfs等网络下载方式从远端服务器获取镜像

uboot还支持远程启动，也就是内核镜像不烧录到开发板的SD卡中，而是放在主机的服务器中，然后需要启动时uboot通过网络从服务器中下载镜像到开发板的DDR中。

 

分析总结：最终结果要的是内核镜像到DDR中特定地址即可，不管内核镜像是怎么到DDR中的。以上2种方式各有优劣。产品出厂时会设置为从SD卡中启动（客户不会还要搭建tftp服务器才能用···）；tftp下载远程启动这种方式一般用来开发。

 

### 2.7.2.2、镜像要放在DDR的什么地址？

(1)内核一定要放在链接地址处，链接地址去内核源代码的链接脚本或者Makefile中去查找。X210中是0x30008000。

 

 

## 2.7.3.zImage和uImage的区别联系

### 2.7.3.1、bootm命令对应do_bootm函数

(1)命令名前加do_即可构成这个命令对应的函数，因此当我们bootm命令执行时，uboot实际执行的函数叫do_bootm函数，在cmd_bootm.c。

(2)do_bootm刚开始定义了一些变量，然后用宏来条件编译执行了secureboot的一些代码（主要进行签名认证），先不管他；然后进行了一些一些细节部分操作，也不管他。然后到了CONFIG_ZIMAGE_BOOT，用这个宏来控制进行条件编译一段代码，这段代码是用来支持zImage格式的内核启动的。

 

### 2.7.3.2、vmlinuz和zImage和uImage

(1)uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是可以直接执行的。但是这种格式不能用来烧录下载。我们用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的）得到的。这个u-boot.bin就叫镜像（image），镜像就是用来烧录到iNand中执行的。

(2)linux内核经过编译后也会生成一个elf格式的可执行程序，叫vmlinux或vmlinuz，这个就是原始的未经任何处理加工的原版内核elf文件；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫Image（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。

(3)原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，**并且在image压缩后的文件的前端附加了一部分解压缩代码**（未经压缩解压缩代码，自己解压自己）。构成了一个压缩格式的镜像就叫**zImage**。（因为当年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。

(4)uboot为了启动linux内核，还发明了一种内核格式叫**uImage**。uImage是由zImage加工得到的，uboot中有一个工具，可以将zImage加工生成uImage**。**

**注意：**uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。**这个加工过程其实就是在zImage前面加上64字节的uImage的头信息即可**。

(4)原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持，但是所有的uboot肯定都支持uImage启动。

 

### 2.7.3.3、编译内核得到uImage去启动

(1)如果直接在kernel 底下去make uImage会提供mkimage command not found。解决方案是去uboot/tools下cp mkimage /usr/local/bin/，复制mkimage工具到系统目录下。再去make uImage即可。

 

### 2.7.3.4、编译内核遇到的错误及解决方法

 

 

把 arch/arm/configs/210ii_initrd_defconfig 复制到 kernel 目录下改名为 .config ,之后再make uImage

 

 

 

 

然后又出现了这个错误Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at kernel/  timeconst.pl line 373. 

百度找到原因修改 kernel/kernel/timeconst.pl 372 行中的 

  if（！define（@val））{   为   if（!@val）{ 

编译成功；

 

 

 

## 2.7.4.zImage启动细节

(1)do_bootm函数中一直到397行的after_header_check这个符号处，都是在进行镜像的头部信息校验。校验时就要根据不同种类的image类型进行不同的校验。所以do_bootm函数的核心就是去分辨传进来的image到底是什么类型，然后按照这种类型的头信息格式去校验。校验通过则进入下一步准备启动内核；如果校验失败则认为镜像有问题，所以不能启动。

 

### 2.7.4.1、LINUX_ZIMAGE_MAGIC

\#ifdef CONFIG_ZIMAGE_BOOT

\#define LINUX_ZIMAGE_MAGIC 0x016f2818

 

(1)这个是一个定义的魔数，这个数等于0x016f2818，表示这个镜像是一个zImage。也就是说zImage格式的镜像中在头部的一个固定位置存放了这个数作为格式标记。如果我们拿到了一个image，去他的那个位置去取4字节判断它是否等于LINUX_ZIMAGE_MAGIC，则可以知道这个镜像是不是一个zImage。

(2)命令 bootm 0x30008000，所以do_boom的argc=2，argv[0]=bootm argv[1]=0x30008000。但是实际bootm命令还可以不带参数执行。**如果不带参数直接bootm，则会从CFG_LOAD_ADDR地址去执行（定义在x210_sd.h中）。**

 

  if (*(ulong *)(addr + 9*4) == LINUX_ZIMAGE_MAGIC) {

(3)zImage头部开始的第36-39（0x24-0x27）字节处存放着zImage标志魔数，从这个位置取出然后对比LINUX_ZIMAGE_MAGIC。可以用二进制阅读软件来打开zImage查看，就可以证明。很多软件都可以打开二进制文件，如winhex、UltraEditor。

**启动时候的打印信息：**

 

### 2.7.4.2、image_header_t

 

\#ifdef CONFIG_ZIMAGE_BOOT

\#define LINUX_ZIMAGE_MAGIC 0x016f2818

  /* find out kernel image address */

  if (argc < 2) {

​    addr = load_addr;

​    debug ("* kernel: default image load address = 0x%08lx\n",

​        load_addr);

  } else {

​    addr = simple_strtoul(argv[1], NULL, 16);

​    debug ("* kernel: cmdline image address = 0x%08lx\n", img_addr);

  }

 

  if (*(ulong *)(addr + 9*4) == LINUX_ZIMAGE_MAGIC) {

​    printf("Boot with zImage\n");

​    addr = virt_to_phys(addr);

​    hdr = (image_header_t *)addr;

​    hdr->ih_os = IH_OS_LINUX;

​    hdr->ih_ep = ntohl(addr);

 

​    memmove (&images.legacy_hdr_os_copy, hdr, sizeof(image_header_t));

 

​    /* save pointer to image header */

​    images.legacy_hdr_os = hdr;

 

​    images.legacy_hdr_valid = 1;

 

​    goto after_header_check;

  }

\#endif

 

 

typedef struct image_header {

  uint32_t  ih_magic;  /* Image Header Magic Number  */

  uint32_t  ih_hcrc;  /* Image Header CRC Checksum  */

  uint32_t  ih_time;  /* Image Creation Timestamp */

  uint32_t  ih_size;  /* Image Data Size   */

  uint32_t  ih_load;  /* Data Load Address   */

  uint32_t  ih_ep;   /* Entry Point Address   */

  uint32_t  ih_dcrc;  /* Image Data CRC Checksum */

  uint8_t   ih_os;   /* Operating System   */

  uint8_t   ih_arch;  /* CPU architecture   */

  uint8_t   ih_type;  /* Image Type      */

  uint8_t   ih_comp;  /* Compression Type   */

  uint8_t   ih_name[IH_NMLEN]; /* Image Name    */

} image_header_t;

 

(1)这个数据结构是我们uboot启动内核使用的一个标准启动数据结构，zImage头信息也是一个image_header_t，但是在实际启动之前需要进行一些改造。

hdr->ih_os = IH_OS_LINUX;

hdr->ih_ep = ntohl(addr);这两句就是在进行改造。

(2)images全局变量是do_bootm函数中使用，用来完成启动过程的。**zImage****的校验过程其实就是先确认是不是zImage，确认后再修改zImage的头信息到合适**，修改后用头信息去初始化images这个全局变量，然后就完成了校验。

 

问题：为何  if (*(ulong *)(addr + 9*4) == LINUX_ZIMAGE_MAGIC) {

 为什么 MAGIC NUMBER 要存放在addr+9*4 这个位置？看image_header_t的头应该是在addr 这个地址才是啊？

以我目前的水平认知只能这么想， zImage的头信息就是在这里放着的，我们在确定是zImage 类型镜像后重新构建了image_header_t 结构体，并修改了其中的一些参数；

## 2.7.5.uImage启动

### 2.7.5.1、uImage启动

(1)LEGACY(遗留的)，在do_bootm函数中，这种方式指的就是uImage的方式。

(2)uImage方式是uboot本身发明的支持linux启动的镜像格式，但是后来这种方式被一种新的方式替代，这个新的方式就是**设备树方式**（在do_bootm方式中叫**FIT**）

(3)uImage的启动校验主要在boot_get_kernel函数中，主要任务就是校验uImage的头信息，并且得到真正的kernel的起始位置去启动。

 

 

### 2.7.5.2、设备树方式内核启动

(1)设备树方式启动暂时不讲，课程结束后会用补充专题的方式来讲解（很多类似的知识点都会这样处理，譬如前面讲的MMU）。

 

 

 

 

image_print_contents (hdr);

打印

 

总结1：uboot本身设计时只支持uImage启动，原来uboot的代码也是这样写的。后来有了fdt方式之后，就把uImage方式命令为LEGACY方式，fdt方式命令为FIT方式，于是乎多了写#if #endif添加的代码。后来移植的人又为了省事添加了zImage启动的方式，又为了省事把zImage启动方式直接写在了uImage和fdt启动方式之前，于是乎又有了一对#if #endif。于是乎整天的代码看起来很恶心。

总结2：第二阶段校验头信息结束，下面进入第三阶段，第三阶段主要任务是启动linux内核，调用do_bootm_linux函数来完成。

 

 

## 2.7.6.do_bootm_linux函数

### 2.7.6.1、找到do_bootm_linux函数

(1)函数在uboot/lib_arm/bootm.c中。

(2)SI找不到（是黑色的）不代表就没有，要搜索一下才能确定；搜索不到也不能代表就没有，因为我们在向SI工程中添加文件时，SI只会添加它能识别的文件格式的文件，有一些像Makefile、xx.conf等Makefile不识别的文件是没有被添加的。所以如果要搜索的关键字在makefile中或者脚本中，可能就是搜索不到的。（譬如TEXT_BASE）

 

### 2.7.6.2、镜像的entrypoint

/* find kernel entry point */

  if (images->legacy_hdr_valid) {

​    ep = image_get_ep (&images->legacy_hdr_os_copy);

 

(1)ep就是entrypoint的缩写，就是程序入口。一个镜像文件的起始执行部分不是在镜像的开头（镜像开头有n个字节的头信息），真正的镜像文件执行时第一句代码在镜像的中部某个字节处，相当于头是有一定的偏移量的。**这个偏移量记录在头信息中**。

(2)一般执行一个镜像都是：

**第一步**：先读取头信息，然后在头信息的特定地址找MAGIC_NUM，由此来确定镜像种类；

**第二步**：对镜像进行校验；

**第三步**：再次读取头信息，由特定地址知道这个镜像的各种信息（镜像长度、镜像种类、入口地址）；

**第四步**：就去entrypoint处开始执行镜像。

(3)theKernel = (void (*)(int, int, uint))ep;将ep赋值给theKernel，则这个函数指向就指向了内存中加载的OS镜像的真正入口地址（就是操作系统的第一句执行的代码）。

 

**2.7.6.3****、机器码的再次确定**

(1)uboot在启动内核时，机器码要传给内核。uboot传给内核的机器码是怎么确定的？第一顺序备选是环境变量machid，第二顺序备选是gd->bd->bi_arch_num（x210_sd.h中硬编码（认为手动到x210_sd.h中添加机器码）配置的）

 

**2.7.6.4****、传参并启动概述**

(1)从110行到144行就是uboot在给linux内核准备传递的参数处理。

(2)Starting kernel ... 这个是uboot中最后一句打印出来的东西。这句如果能出现，说明uboot整个是成功的，也成功的加载了内核镜像，也校验通过了，也找到入口地址了，也试图去执行了。如果这句后串口就没输出了，说明内核并没有被成功执行。**原因一般是：传参（80%）、内核在DDR中的加载地址·······**

 

 

## 2.7.7.传参详解

### 2.7.7.1、tag方式传参

(1)struct tag，tag是一个数据结构，在uboot和linux kernel中都有定义tag数据机构，而且定义是一样的。

(2)tag_header和tag_xxx。tag_header中有这个tag的size和类型编码，kernel拿到一个tag后先分析tag_header得到tag的类型和大小，然后将tag中剩余部分当作一个tag_xxx来处理。因为tag_xxx是union类型的原因，所以tag_xxx这那个类型当中只有一个。但是传参又有多个，所以tag_start最有一句有

params = tag_next (params);

 

\#define tag_next(t) ((struct tag *)((u32 *)(t) + (t)->hdr.size))

相当于params 的地址加了一个tag 类型的大小，所以后面在调用其他的union里其他的tag_xxx 不会将start里的tag_xxx类型给覆盖掉。

(3)tag_start与tag_end。kernel接收到的传参是若干个tag构成的，这些tag由tag_start起始，到tag_end结束。

(4)tag传参的方式是由linux kernel发明的，kernel定义了这种向我传参的方式，uboot只是实现了这种传参方式从而可以支持给kernel传参。

 

### 2.7.7.2、x210_sd.h中配置传参宏

(1)CONFIG_SETUP_MEMORY_TAGS，tag_mem，传参内容是内存配置信息。

(2)CONFIG_CMDLINE_TAG，tag_cmdline，传参内容是启动命令行参数，也就是uboot环境变量的bootargs.

(3)CONFIG_INITRD_TAG

(4)CONFIG_MTDPARTITION，传参内容是iNand/SD卡的分区表。

(5)起始tag是ATAG_CORE、结束tag是ATAG_NONE，其他的ATAG_XXX都是有效信息tag。

思考：内核如何拿到这些tag？

theKernel (0, machid, bd->bi_boot_params);

uboot最终是调用theKernel函数来执行linux内核的，uboot调用这个函数（其实就是linux内核）时传递了3个参数。这3个参数就是uboot直接传递给linux内核的3个参数，通过寄存器来实现传参的。（第1个参数就放在r0中，第二个参数放在r1中，第3个参数放在r2中）第1个参数固定为0，第2个参数是机器码，第3个参数传递的就是大片传参tag的首地址。

 

### 2.7.7.3、移植时注意事项

(1)uboot移植时一般只需要配置相应的宏即可

(2)kernel启动不成功，注意传参是否成功。传参不成功首先看uboot中bootargs设置是否正确，其次看uboot是否开启了相应宏以支持传参。

 

### 2.7.7.4、union共用体的讲解及其使用

通过前面的讲解，我们知道结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做**共用体（Union）**，它的定义格式为：

union 共用体名{
   成员列表
 };

共用体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。

结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。

 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

 共用体也是一种自定义类型，可以通过它来创建变量，例如：

```
1.  union data{
2.      int n;
3.      char ch;
4.      double f;
5.  };
6.  union data a, b, c;
```

上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量：

```
1.  union data{
2.      int n;
3.      char ch;
4.      double f;
5.  } a, b, c;
```

如果不再定义新的变量，也可以将共用体的名字省略：

```
1.  union{
2.      int n;
3.      char ch;
4.      double f;
5.  } a, b, c;
```

共用体 data 中，成员 f 占用的内存最多，为 8 个字节，所以 data 类型的变量（也就是 a、b、c）也占用 8 个字节的内存，请看下面的演示：

```
1.  #include <stdio.h>
2.   
3.  union data{
4.      int n;
5.      char ch;
6.      short m;
7.  };
8.   
9.  int main(){
10.     union data a;
11.     printf("%d, %d\n", sizeof(a), sizeof(union data) );
12.     a.n = 0x40;
13.     printf("%X, %c, %hX\n", a.n, a.ch, a.m);
14.     a.ch = '9';
15.     printf("%X, %c, %hX\n", a.n, a.ch, a.m);
16.     a.m = 0x2059;
17.     printf("%X, %c, %hX\n", a.n, a.ch, a.m);
18.     a.n = 0x3E25AD54;
19.     printf("%X, %c, %hX\n", a.n, a.ch, a.m);
20.    
21.     return 0;
22. }
```

运行结果：

```
4, 4
40, @, 40
39, 9, 39
2059, Y, 2059
3E25AD54, T, AD54
```

这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。

 要想理解上面的输出结果，弄清成员之间究竟是如何相互影响的，就得了解各个成员在内存中的分布。以上面的 data 为例，各个成员在内存中的分布如下：

 成员 n、ch、m 在内存中“对齐”到一头，对 ch 赋值修改的是前一个字节，对 m 赋值修改的是前两个字节，对 n 赋值修改的是全部字节。也就是说，ch、m 会影响到 n 的一部分数据，而 n 会影响到 ch、m 的全部数据。

 上图是在绝大多数 PC 机上的内存分布情况，如果是 51 单片机，情况就会有所不同：

 为什么不同的机器会有不同的分布情况呢？这跟机器的存储模式有关，我们将在VIP教程《[大端小端以及判别方式](http://c.biancheng.net/view/vip_2036.html)》一节中展开探讨。

共用体的应用

共用体在一般的编程中应用较少，在单片机中应用较多。对于 PC 机，经常使用到的一个实例是： 现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：

| **Name**    | **Num** | **Sex** | **Profession** | **Score / Course** |
| ----------- | ------- | ------- | -------------- | ------------------ |
| HanXiaoXiao | 501     | f       | s              | 89.5               |
| YanWeiMin   | 1011    | m       | t              | math               |
| LiuZhenTao  | 109     | f       | t              | English            |
| ZhaoFeiYan  | 982     | m       | s              | 95.0               |


 f 和 m 分别表示女性和男性，s 表示学生，t 表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。

 如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前 4 个成员变量是一样的，第 5 个成员变量可能是 score 或者 course。当第 4 个成员变量的值是 s 的时候，第 5 个成员变量就是 score；当第 4 个成员变量的值是 t 的时候，第 5 个成员变量就是 course。

 经过上面的分析，我们可以设计一个包含共用体的结构体，请看下面的代码：

```
1.  #include <stdio.h>
2.  #include <stdlib.h>
3.   
4.  #define TOTAL 4  //人员总数
5.   
6.  struct{
7.      char name[20];
8.      int num;
9.      char sex;
10.     char profession;
11.     union{
12.         float score;
13.         char course[20];
14.     } sc;
15. } bodys[TOTAL];
16.  
17. int main(){
18.     int i;
19.     //输入人员信息
20.     for(i=0; i<TOTAL; i++){
21.         printf("Input info: ");
22.         scanf("%s %d %c %c", bodys[i].name, &(bodys[i].num), &(bodys[i].sex), &(bodys[i].profession));
23.         if(bodys[i].profession == 's'){  //如果是学生
24.             scanf("%f", &bodys[i].sc.score);
25.         }else{  //如果是老师
26.             scanf("%s", bodys[i].sc.course);
27.         }
28.         fflush(stdin);
29.     }
30.  
31.     //输出人员信息
32.     printf("\nName\t\tNum\tSex\tProfession\tScore / Course\n");
33.     for(i=0; i<TOTAL; i++){
34.         if(bodys[i].profession == 's'){  //如果是学生
35.             printf("%s\t%d\t%c\t%c\t\t%f\n", bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.score);
36.         }else{  //如果是老师
37.             printf("%s\t%d\t%c\t%c\t\t%s\n", bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.course);
38.         }
39.     }
40.     return 0;
41. }
```

运行结果：

```
Input info: HanXiaoXiao 501 f s 89.5↙
Input info: YanWeiMin 1011 m t math↙
Input info: LiuZhenTao 109 f t English↙
Input info: ZhaoFeiYan 982 m s 95.0↙
 
Name            Num     Sex     Profession      Score / Course
HanXiaoXiao     501     f       s               89.500000
YanWeiMin       1011    m       t               math
LiuZhenTao      109     f       t               English
ZhaoFeiYan      982     m       s               95.000000
```

**总结：这样在结构体用uion结构体可以达到节约内存的作用，因为共用体只占最长成员的内存（course），这样就节约了比这小的成员的内存（score）；**

**引用**http://c.biancheng.net/view/2035.html

## 2.7.8.uboot启动内核的总结

**2.7.8.1****、启动4步骤**

第一步：将内核搬移到DDR中

第二步：校验内核格式、CRC等

第三步：准备传参

第四步：跳转执行内核

涉及到的主要函数是：do_boom和do_bootm_linux

uboot能启动的内核格式：zImage uImage fdt方式

跳转与函数指针的方式运行内核

### 2.7.8.1、uboot启动Linux内核过程分为4大步骤（图解）

 

 

**uboot****启动Linux内核过程分为4大步骤：**

 

 

问题2： uboot阶段DDR的分区的问题

上述步骤2和步骤4中，有将uboot/kernel拷贝纸DDR的步骤，具体要拷贝到DDR的什么位置呢？

**分清楚这两个概念**：

**链接地址**：链接时指定的地址（指定方式为：Makefile中用-Ttext，或者链接脚本）

**运行地址**：程序实际运行时地址（指定方式：由实际运行时被加载到内存的哪个位置说了算）

此问题中的提及的位置是链接地址，在由Makefile中用**-Ttext**，或者**链接脚本**指定的。

 

Uboot放在DDR中的什么位置？

是用Makefile中的-Ttext指定的。查看code:

 

 

TEXT_BASE是将来我们整个uboot链接时指定的链接地址。因为uboot中启用了**虚拟地址映射**，这个**虚拟地址**0xC3E0 0000地址对应的**物理地址**就等于0x33E0 0000，所以我们会将uboot加载到DDR中的起始位置是0x33E0 0000，加载调用的code 如下：

 

0表示通道0；MOVI_BL2_POS是uboot的第二部分在SD卡中的开始扇区，这个扇区数字必须和烧录uboot时烧录的位置相同；MOVI_BL2_BLKCNT是uboot的长度占用的扇区数；CFG_PHY_UBOOT_BASE是重定位时将uboot的第二部分复制到DDR中的起始地址（0x33E00000）.

 

**Kernel** **镜像要放在DDR的什么地址？**

内核一定要放在**链接地址处**，链接地址去内核源代码的链接脚本或者Makefile中去查找。X210中是0x30008000。

**遗留问题**: 内核的链接脚本后续要截屏放在这里

在uboot中通过执行如下命令将kernel加载到DDR中：

movi read kernel 30008000

(其中kernel指的是uboot中的kernel分区)

 

总结

Uboot/kernel要拷贝到DDR中的物理地址；

链接脚本或-Ttext 指定的是程序运行的虚拟地址；

 

 

 

————————————————

版权声明：本文为CSDN博主「wowRicky」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/wowricky/article/details/83218356

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第八章 源码分析4-uboot的命令体系

## 2.8.0、章节概要

**2.8.1.uboot命令体系基础**

​    本节讲述uboot的命令体系的基础知识，包括uboot命令的实现代码寻找，命令背后对应的执行函数等。

**2.8.2.uboot命令解析和执行过程分析**

​    本节分析uboot中获取、解析和执行命令的过程，从代码角度来追溯一个命令执行的流程。

**2.8.3.uboot如何处理命令集1**

​    本节讲解uboot的命令数据结构和使用链接段属性的方式将命令集中存放并查找的技巧，这种技巧在linux内核中同样有广泛使用。

**2.8.4.uboot如何处理命令集2**  

​    本节通过分析find_cmd函数和version命令的实现函数do_version来进一步分析uboot命令集。

**2.8.5.uboot中增加自定义命令**  

​    本节进行代码实践，动手向uboot中添加自定义命令，并且总结uboot中命令体系的优势就是便于命令的添加和扩展。

## 2.8.1、uboot命令体系基础

### 2.8.1.1、使用uboot命令

(1)uboot启动后进入命令行环境下，在此输入命令按回车结束，uboot会收取这个命令然后解析，然后执行。

### 2.8.1.2、uboot命令体系实现代码在哪里

(1)uboot命令体系的实现代码在uboot/common/cmd_xxx.c中。有若干个.c文件和命令体系有关。（还有command.c main.c也是和命令有关的）。

 

### 2.8.1.3、每个命令对应一个函数

(1)每一个uboot的命令背后都对应一个函数。这就是uboot实现命令体系的一种思路和方法。这个东西和我们在裸机第十六部分shell中实现shell命令的方法是一样的。

(2)我们要找到每一个命令背后所对应的那个函数，而且要分析这个函数和这个命令是怎样对应起来的。

 

### 2.8.1.4、命令参数以argc&argv传给函数

(1)有些uboot的命令还支持传递参数。也就是说命令背后对应的函数接收的参数列表中有argc和argv，然后命令体系会把我们执行命令时的命令+参数（md 30000000 10）以argc（3）和argv（argv[0]=md, argv[1]=30000000 argv[2]=10）的方式传递给执行命令的函数

举例分析，以help命令为例：

help命令背后对应的函数名叫：do_help。在uboot/common/command.c的236行。int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])

 

 

## 2.8.2.uboot命令解析和执行过程分析

### 2.8.2.1、从main_loop说起

(1)uboot启动的第二阶段，在初始化了所有该初始化的东西后，进入了一个死循环，死循环的循环体就是main_loop。

(2)main_loop函数执行一遍，就是一个获取命令、解析命令、执行命令的过程。

(3)run_command函数就是用来执行命令的函数。

（4）clear_ctrlc(); 这个是用来终止命令的，就是在命令的执行过程中，你不想执行了

在控制台按下ctrl+c 来终止命令；、

 

### 2.8.2.2、run_command函数详解

### 2.8.2.3、关键点分析

(1)控制台命令获取

(2)命令解析。parse_line函数把"md 30000000 10"解析成argv[0]=md, argv[1]=30000000 argv[2]=10;

(3)命令集中查找命令。find_cmd(argv[0])函数去uboot的命令集合当中搜索有没有argv[0]这个命令，

(4)执行命令。最后用函数指针的方式调用执行了对应函数。

 

思考：关键点就在于find_cmd函数如何查找到这个命令是不是uboot的合法支持的命令？这取决于uboot的命令体系机制（uboot是如何完成命令的这一套设计的，命令如何去注册、存储、管理、索引。）。

 

 

## 2.8.3.uboot如何处理命令集1

### 2.8.3.1、可能的管理方式

(1)数组。结构体数组，数组中每一个结构体成员就是一个命令的所有信息。

(2)链表。链表的每个节点data段就是一个命令结构体，所有的命令都放在一条链表上。这样就解决了数组方式的不灵活。坏处是需要额外的内存开销，然后各种算法（遍历、插入、删除等）需要一定复杂度的代码执行。

(3)有第三种吗？uboot没有使用数组或者链表，而是使用了一种新的方式来实现这个功能。

### 2.8.3.2、命令结构体cmd_tbl_t

struct cmd_tbl_s {

  char    *name;   /* Command Name     */

  int   maxargs;  /* maximum number of arguments */

  int   repeatable; /* autorepeat allowed?   */

​          /* Implementation function */

  int   (*cmd)(struct cmd_tbl_s *, int, int, char *[]);

  char    *usage;   /* Usage message  (short) */

\#ifdef CFG_LONGHELP

  char    *help;   /* Help message  (long) */

\#endif

\#ifdef CONFIG_AUTO_COMPLETE

  /* do auto completion on the arguments */

  int   (*complete)(int argc, char *argv[], char last_char, int maxv, char *cmdv[]);

\#endif

};

typedef struct cmd_tbl_s  cmd_tbl_t;

 

 

 (1)**name**：命令名称，字符串格式。

(2)**maxargs**：命令最多可以接收多少个参数

(3)**repeatable**：指示这个命令是否可重复执行。重复执行是uboot命令行的一种工作机制，就是直接按回车则执行上一条执行的命令。

(4)**cmd**：函数指针，命令对应的函数的函数指针，将来执行这个命令的函数时使用这个函数指针来调用。

(5)**usage**：命令的短帮助信息。对命令的简单描述。

(6)**help**：命令的长帮助信息。细节的帮助信息。

(7)**complete**：函数指针，指向这个命令的自动补全的函数。

总结：uboot的命令体系在工作时，一个命令对应一个cmd_tbl_t结构体的一个实例，然后uboot支持多少个命令，就需要多少个结构体实例。uboot的命令体系把这些结构体实例管理起来，当用户输入了一个命令时，uboot会去这些结构体实例中查找（查找方法和存储管理的方法有关）。如果找到则执行命令，如果未找到则提示命令未知。

 

### 2.8.3.3、uboot实现命令管理的思路

(1)填充1个结构体实例构成一个命令

(2)给命令结构体实例附加特定**段属性**（用户自定义段），链接时将带有该段属性的内容链接在一起排列（挨着的，不会夹杂其他东西，也不会丢掉一个带有这种段属性的，但是顺序是乱序的）。

(3)uboot重定位时将该段整体加载到DDR中。加载到DDR中的uboot镜像中带有特定段属性的这一段其实就是命令结构体的集合，有点像一个命令结构体数组。

(4)段起始地址和结束地址（链接地址、定义在u-boot.lds中）决定了这些命令集的开始和结束地址。我们有了起始地址和结束地址，这样通过一些手段，就可以和用数组一样遍历它；

​    为什么不用链表呢？使用链表，链表的遍历比较消耗资源；

 

 

## 2.8.4.uboot如何处理命令集2

### 2.8.4.1、uboot命令定义具体实现分析

(1)U_BOOT_CMD宏基本分析

这个宏定义在uboot/common/command.h中。

U_BOOT_CMD(

  version,  1,   1, do_version,

  "version - print monitor version\n",

  NULL

);

 

**这个宏替换后变成：**

\#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \

cmd_tbl_t __u_boot_cmd_##name Struct_Section = {#name, maxargs, rep, cmd, usage, help}

\##name 这个的意识就是在__u_boot_com_这后面加上U_BOOT_CMD 传参name中的字符串，比如说name是version ，传进来后就是__u_boot_com_version

 \#name和##name含义是不一样的， #name只是将原本传进来的那个命令变为字符串

 

\#define Struct_Section __attribute__ ((unused,section (".u_boot_cmd")))

  **用这个宏展开后：**

 cmd_tbl_t __u_boot_cmd_##name __attribute__ ((unused,section (".u_boot_cmd"))) = {#name, maxargs, rep, cmd, usage, help}

 

 __attribute__ ((unused,section (".u_boot_cmd"))) 这个宏是用来添加段属性的，这个段就是.u_boot_cmd 段；

 

总结：这个U_BOOT_CMD宏的理解，关键在于结构体变量的名字和段属性。名字使用##作为连字符，附加了用户自定义段属性，以保证链接时将这些数据结构链接在一起排布。

(2)链接脚本：

​    __u_boot_cmd_start = .;    //起始地址

​    .u_boot_cmd : { *(.u_boot_cmd) }

​    __u_boot_cmd_end = .;    //结束地址

### 2.8.4.2、find_cmd函数详解

cmd_tbl_t *find_cmd (const char *cmd)

{

  cmd_tbl_t *cmdtp;

  cmd_tbl_t *cmdtp_temp = &__u_boot_cmd_start;  /*Init value */

  const char *p;

  int len;

  int n_found = 0;

 

  /*

   \* Some commands allow length modifiers (like "cp.b");

   \* compare command name only until first dot.

   */

  len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

 // 有些命令带点，这句意思就是如果命令有点的话，只算点前面的长度；

 

  for (cmdtp = &__u_boot_cmd_start;

​     cmdtp != &__u_boot_cmd_end;

​     cmdtp++) {

​    if (strncmp (cmd, cmdtp->name, len) == 0) {

​      if (len == strlen (cmdtp->name))

​        return cmdtp;  /* full match */

 

​      cmdtp_temp = cmdtp; /* abbreviated command ? */

​      n_found++;

​    }

  }

  if (n_found == 1) {     /* exactly one match */

​    return cmdtp_temp;

  }

 

  return NULL;  /* not found or ambiguous command */

}

 

(1)find_cmd函数的任务是从当前uboot的命令集中查找是否有某个命令。如果找到则返回这个命令结构体的指针，如果未找到返回NULL。

(2)函数的实现思路很简单，如果不考虑命令带点的情况（md.b md.w这种）就更简单了。查找命令的思路其实就是for循环遍历数组的思路，不同的是数组的起始地址和结束地址是用地址值来给定的，数组中的元素个数是结构体变量类型。

 

### 2.8.4.3、U_BOOT_CMD宏详解

(1)这个宏其实就是定义了一个命令对应的结构体变量，这个变量名和宏的第一个参数有关，因此只要宏调用时传参的第一个参数不同则定义的结构体变量不会重名。

 

### 2.8.4.4、命令举例：version命令

 

 

## 2.8.5.uboot中增加自定义命令

### 2.8.5.1、在已有的c文件中直接添加命令

(1)在uboot/common/command.c中添加一个命令，叫：mycmd

(2)在已有的.c文件中添加命令比较简单，直接使用U_BOOT_CMD宏即可添加命令，给命令提供一个do_xxx的对应的函数这个命令就齐活了。

(3)添加完成后要重新编译工程（make distclean; make x210_sd_config; make），然后烧录新的uboot去运行即可体验新命令。

(4)还可以在函数中使用argc和argv来验证传参。

 

### 2.8.5.2、自建一个c文件并添加命令

(1)在uboot/common目录下新建一个命令文件，叫cmd_aston.c（对应的命令名就叫aston，对应的函数就叫do_aston函数），然后在c文件中添加命令对应的U_BOOT_CMD宏和函数。注意头文件包含不要漏掉。

(2)在uboot/common/Makefile中添加上aston.o，目的是让Make在编译时能否把cmd_aston.c编译链接进去。

(3)重新编译烧录。重新编译步骤是：make distclean; make x210_sd_config; make

(4)uboot/common/Makefile 中的条件添加

 

-y表示一定会被添加；

$(CONFIG_CMD_AMBAPP) 如果定义了这个宏则添加 cmd_ambapp.o，反则不添加；

### 2.8.5.3、体会：uboot命令体系的优点

(1)uboot的命令体系本身稍微复杂，但是他写好之后就不用动了。我们后面在移植uboot时也不会去动uboot的命令体系。我们最多就是向uboot中去添加命令，就像本节课所做的这样。

(2)向uboot中添加命令非常简单。

 

 

 

 

 

 

 

 

 



 

 

# 第九章 uboot源码分析5-uboot的环境变量

## 2.9.0 章节概要

**2.9.1.uboot的环境变量基础**

​    本节总结和回顾之前零星讲过的uboot的环境变量相关的基础知识。

**2.9.2.环境变量相关命令源码解析1**

​    本节分析printenv命令的实现代码，目的是通过分析让大家对uboot中环境变量的管理和保存方法有更加深入的理解。

**2.9.3.环境变量相关命令源码解析2**

​    本节分析setenv命令的实现代码，让大家认识到环境变量在内存中的设置方法。

**2.9.4.环境变量相关命令源码解析3**

​    本节分析saveenv命令的实现代码，让大家认识到环境变量在SD卡中的保存方法。

**2.9.5.uboot内部获取环境变量**

​    本节分析getenv函数，uboot自身使用该函数来获取各环境变量的值。

## 2.9.1.uboot的环境变量基础

### 2.9.1.1、环境变量的作用

(1)让我们可以不用修改uboot的源代码，而是通过修改环境变量来影响uboot运行时的一些数据和特性。譬如说通过修改bootdelay环境变量就可以更改系统开机自动启动时倒数的秒数。

 

### 2.9.1.2、环境变量的优先级      

(1)uboot代码当中有一个值，环境变量中也有一个值。uboot程序实际运行时规则是：如果环境变量为空则使用代码中的值；如果环境变量不为空则优先使用环境变量对应的值。

(2)譬如machid（机器码）。uboot中在x210_sd.h中定义了一个机器码2456，写死在程序中的不能更改。如果要修改uboot中配置的机器码，可以修改x210_sd.h中的机器码，但是修改源代码后需要重新编译烧录，很麻烦；比较简单的方法就是使用环境变量machid。set machid 0x998类似这样，有了machid环境变量后，系统启动时会优先使用machid对应的环境变量，这就是优先级问题。

 

### 2.9.1.3、环境变量在uboot中工作方式

\#if defined(CONFIG_S3C6410) || defined(CONFIG_S3C6430) || defined(CONFIG_S5P6440) || defined(CONFIG_S5PC100) || defined(CONFIG_S5PC110) || defined(CONFIG_S5P6442)

uchar default_environment[CFG_ENV_SIZE] = {

\#else

uchar default_environment[] = {

\#endif

\#ifdef CONFIG_BOOTARGS

  "bootargs=" CONFIG_BOOTARGS     "\0"

\#endif

\#ifdef CONFIG_BOOTCOMMAND

  "bootcmd=" CONFIG_BOOTCOMMAND   "\0"

\#endif

"bootargs=" CONFIG_BOOTARGS     "\0"  

 

(1**)****默认环境变量**：在uboot/common/env_common.c中default_environment，这东西本质是一个字符数组，大小为CFG_ENV_SIZE（16kb），里面内容就是很多个环境变量连续分布组成的，每个环境变量最末端以'\0'结束。

 

(2)**SD****卡中环境变量分区**：在uboot的raw分区中。SD卡中其实就是给了个分区，专门用来存储而已。存储时其实是把DDR中的环境变量整体的写入SD卡中分区里。**所以当我们saveenv时其实整个所有的环境变量都被保存了一遍，而不是只保存更改了的**。

 

(3)**DDR****中环境变量**：在default_environment中，实质是字符数组。在uboot中其实是一个全局变量，链接时在数据段，重定位时default_environment就被重定位到DDR中一个内存地址处了。这个地址处这个全局字符数组就是我们uboot运行时的DDR中的环境变量了。

 

总结：刚烧录的系统中环境变量分区是空白的，uboot第一次运行时加载的是uboot代码中自带的一份环境变量，叫默认环境变量。我们在saveenv时DDR中的环境变量会被更新到SD卡中的环境变量中，就可以被保存下来，下次开机会在环境变量relocate时会SD卡中的环境变量会被加载到DDR中去。

 

default_environment中的内容虽然被uboot源代码初始化为一定的值（这个值就是我们的默认环境变量），但是在uboot启动的第二阶段，env_relocate时代码会去判断SD卡中的env分区的crc是否通过。如果crc校验通过说明SD卡中有正确的环境变量存储，则relocate函数会从SD卡中读取环境变量来覆盖default_environment字符数组，从而每次开机可以保持上一次更改过的环境变量。

 

第一次启动时会把defult_environment 里的环境变量加载到DDR（CRC校验没通过），如果你更改过环境变量的话并且save，这时候就会把DDR把环境变量写入到SD卡的raw分区。 再次启动时，env_relocate时代码会去判断SD卡中的env分区的crc是否通过。如果crc校验通过说明SD卡中有正确的环境变量存储，则relocate函数会从SD卡中读取环境变量来覆盖default_environment字符数组，从而每次开机可以保持上一次更改过的环境变量。

 

 

### 2.9.1.1.1、默认环境变量 default_environment 数组相关问题解答

 \#include<stdio.h>

 

\#define CONFIG_BOOTARGS "love"

\#define CONFIG_BOOTCOMMAND "You"

 

int envprint(char* default_environment)

{  

  char *p;

  p = default_environment;

  while(1){

 

​    printf("%c", *p++);

​    if(*p=='\0'){

​      printf("\n");

​      if(*(p+1 )== '\0')

​        break;

​    }

  }

}

int main()

{

  unsigned char default_environment[] = {

  "bootargs="  CONFIG_BOOTARGS    "\0" 

  "bootcmd=" CONFIG_BOOTCOMMAND   "\0"

  "\0"

  };

 

  envprint(default_environment);

 

  return 0;

}

 

**输出：**

PS C:\Users\xiesh\Desktop\Linux\c语言课程练习> ./a.exe

bootargs=love

bootcmd=You

**注意：**

 default_environment 是普通字符数组，并不是字符串数组指针（char * p[]）。

 

## 2.9.2.环境变量相关命令源码解析1

### 2.9.2.1、printenv

/************************************************************************

 \* Command interface: print one or all environment variables

 */

 

int do_printenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])

{

  int i, j, k, nxt;

  int rcode = 0;

 

  if (argc == 1) {    /* Print all env variables */

​    for (i=0; env_get_char(i) != '\0'; i=nxt+1) {

​      for (nxt=i; env_get_char(nxt) != '\0'; ++nxt)

​        ;

​      for (k=i; k<nxt; ++k)

​        putc(env_get_char(k));

​      putc ('\n');

 

​      if (ctrlc()) {

​        puts ("\n ** Abort\n");

​        return 1;

​      }

​    }

 

​    printf("\nEnvironment size: %d/%ld bytes\n",

​      i, (ulong)ENV_SIZE);

 

​    return 0;

  }

 

  for (i=1; i<argc; ++i) {  /* print single env variables  */

​    char *name = argv[i];

 

​    k = -1;

 

​    for (j=0; env_get_char(j) != '\0'; j=nxt+1) {

 

​      for (nxt=j; env_get_char(nxt) != '\0'; ++nxt)

​        ;

​      k = envmatch((uchar *)name, j);

​      if (k < 0) {

​        continue;

​      }

​      puts (name);

​      putc ('=');

​      while (k < nxt)

​        putc(env_get_char(k++));

​      putc ('\n');

​      break;

​    }

​    if (k < 0) {

​      printf ("## Error: \"%s\" not defined\n", name);

​      rcode ++;

​    }

  }

  return rcode;

}

 

(1)找到printenv命令所对应的函数。通过printenv的help可以看出，这个命令有2种使用方法。第一种直接使用不加参数则打印所有的环境变量；第二种是printenv name则只打印出name这个环境变量的值。

(2)分析do_printenv函数。

(3)do_printenv函数首先区分argc=1还是不等于1的情况，若argc=1那么就循环打印所有的环境变量出来；如果argc不等于1，则后面的参数就是要打印的环境变量，给哪个就打印哪个。

(4)argc=1时用双重for循环来依次处理所有的环境变量的打印。第一重for循环就是处理各个环境变量。所以有多少个环境变量则第一重就执行循环多少圈。

(5)这个函数要看懂，首先要明白整个环境变量在内存中如何存储的问题。

(6)关键点：第一要明白环境变量在内存中存储的方式；第二要C语言处理字符串的功底要好。

 

 

## 2.9.3.环境变量相关命令源码解析2

### 2.9.3.1、setenv

int do_setenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])

{

  if (argc < 2) {

​    printf ("Usage:\n%s\n", cmdtp->usage);

​    return 1;

  }

 

  return _do_setenv (flag, argc, argv);

}

 

 

 

(1)命令定义和对应的函数在uboot/common/cmd_nvedit.c中，对应的函数为do_setenv。

(2)setenv的思路就是：先去DDR中的环境变量处寻找原来有没有这个环境变量，如果原来就有则需要覆盖原来的环境变量，如果原来没有则在最后新增一个环境变量即可。

第1步：遍历DDR中环境变量的数组，找到原来就有的那个环境变量对应的地址。168-174行。

第2步：擦除原来的环境变量，259-265行

第3步：写入新的环境变量，266-273行。

(3)本来setenv做完上面的就完了，但是还要考虑一些附加的问题。

问题一：环境变量太多超出DDR中的字符数组，溢出的解决方法。

问题二：有些环境变量如baudrate、ipaddr等，在gd中有对应的全局变量。这种环境变量在set更新的时候要同时去更新对应的全局变量，否则就会出现在本次运行中环境变量和全局变量不一致的情况。

 

 

## 2.9.4.环境变量相关命令源码解析2

### 2.9.4.1、saveenv

int do_saveenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])

{

  extern char * env_name_spec;

 

  printf ("Saving Environment to %s...\n", env_name_spec);

 

  return (saveenv() ? 1 : 0);

}

 

(1)在uboot/common/cmd_nvedit.c中，对应函数为do_saveenv

(2)从uboot实际执行saveenv命令的输出，和x210_sd.h中的配置（#define CFG_ENV_IS_IN_AUTO）可以分析出：我们实际使用的是env_auto.c中相关的内容。没有一种芯片叫auto的，env_auto.c中是使用宏定义的方式去条件编译了各种常见的flash芯片（如movinand、norflash、nand等）。然后在程序中读取INF_REG（OMpin内部对应的寄存器）从而知道我们的启动介质，然后调用这种启动介质对应的操作函数来操作。

(3)do_saveenv内部调用env_auto.c中的saveenv函数来执行实际的环境变量保存操作。

 

\#define INF_REG3_REG      __REG(INF_REG_BASE+INF_REG3_OFFSET)

(4)寄存器地址：E010F000+0C=E010_F00C，含义是用户自定义数据。我们在start.S中判断启动介质后将#BOOT_MMCSD（就是3，定义在x210_sd.h）写入了这个寄存器，所以这里读出的肯定是3，经过判断就是movinand。所以实际执行的函数是：saveenv_movinand。

(5)真正执行保存环境变量操作的是：cpu/s5pc11x/movi.c中的**movi_write_env**函数，这个函数肯定是写sd卡，将DDR中的环境变量数组（其实就是default_environment这个数组，大小16kb，刚好32个扇区）写入iNand中的ENV分区中。

(6)raw_area_control是uboot中规划iNnad/SD卡的原始分区表，这个里面记录了我们对iNand的分区，env分区也在这里，下标是2.追到这一层就够了，再里面就是调用驱动部分的写SD卡/iNand的底层函数了。

 

 

## 2.9.5.uboot内部获取环境变量

### 2.9.5.1、getenv

char *getenv (char *name)

{

  int i, nxt;

 

  WATCHDOG_RESET();

 

  for (i=0; env_get_char(i) != '\0'; i=nxt+1) {

​    int val;

 

​    for (nxt=i; env_get_char(nxt) != '\0'; ++nxt) {

​      if (nxt >= CFG_ENV_SIZE) {

​        return (NULL);

​      }

​    }

​    if ((val=envmatch((uchar *)name, i)) < 0)

​      continue;

​    return ((char *)env_get_addr(val));

  }

 

  return (NULL);

}

 

(1)应该是不可重入的。

(2)实现方式就是去遍历default_environment数组，挨个拿出所有的环境变量比对name，找到相等的直接返回这个环境变量的首地址即可。

 

### 2.9.5.2、getenv_r

int getenv_r (char *name, char *buf, unsigned len)

{

  int i, nxt;

 

  for (i=0; env_get_char(i) != '\0'; i=nxt+1) {

​    int val, n;

 

​    for (nxt=i; env_get_char(nxt) != '\0'; ++nxt) {

​      if (nxt >= CFG_ENV_SIZE) {

​        return (-1);

​      }

​    }

​    if ((val=envmatch((uchar *)name, i)) < 0)

​      continue;

​    /* found; copy out ，可重入加了个buff*/

​    n = 0;

​    while ((len > n++) && (*buf++ = env_get_char(val++)) != '\0')

​      ;

​    if (len == n)

​      *buf = '\0';

​    return (n);

  }

  return (-1);

}

 

(1)可重入版本。（可自行搜索补充可重入函数的概念）

(2)getenv函数是直接返回这个找到的环境变量在DDR中环境变量处的地址，而getenv_r函数的做法是找到了DDR中环境变量地址后，将这个环境变量复制一份到提供的buf中，而不动原来DDR中环境变量。

所以差别就是：getenv中返回的地址只能读不能随便乱写，而getenv_r中返回的环境变量是在自己提供的buf中，是可以随便改写加工的。

 

### 2.9.5.3、什么是可重入函数

在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。如果有一个函数不幸被设计成为这样：那么不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。**这样的函数是不安全的函数，也叫不可重入函数**。

相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？所谓可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。

一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。

**也可以这样理解，重入即表示重复进入**，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括 static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括 static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。
 编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。
 说明：若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态。

示例：假设 Exam 是 int 型全局变量，函数 Squre_Exam 返回 Exam 平方值。那么如下函数不具有可重入性。

```
1.  int Exam = 0;  
2.  unsigned int example( int para )   
3.  {   
4.      unsigned int temp;  
5.      Exam = para; // （**）  
6.      temp = Square_Exam( );  
7.      return temp;  
8.  }  
```

此函数若被多个进程调用的话，其结果可能是未知的，因为当（**）语句刚执行完后，另外一个使用本函数的进程可能正好被激活，那么当新激活的进程执行到此函数时，将使 Exam 赋与另一个不同的 para 值，所以当控制重新回到 “temp = Square_Exam( )” 后，计算出的temp很可能不是预想中的结果。此函数应如下改进。

```
1.  int Exam = 0;  
2.  unsigned int example( int para )   
3.  {  
4.      unsigned int temp;  
5.      [申请信号量操作] //(1)  加锁  
6.      Exam = para;  
7.      temp = Square_Exam( );  
8.      [释放信号量操作] //     解锁   
9.      return temp;  
10. }  
```

申请不到“信号量”，说明另外的进程正处于给 Exam 赋值并计算其平方过程中（即正在使用此信号），本进程必须等待其释放信号后，才可继续执行。若申请到信号，则可继续执行，但其它进程必须等待本进程释放信号量后，才能再使用本信号。

保证函数的可重入性的方法：

1）在写函数时候尽量使用局部变量（例如寄存器、堆栈中的变量）；

2）对于要使用的全局变量要加以保护（如采取关中断、信号量等互斥方法），这样构成的函数就一定是一个可重入的函数。

满足下列条件的函数多数是不可重入（不安全）的：

1）函数体内使用了静态的数据结构；

2）函数体内调用了malloc() 或者 free() 函数；

3）函数体内调用了标准 I/O 函数。

如何将一个不可重入的函数改写成可重入函数呢？把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写它。其实很简单，只要遵守了几条很容易理解的规则，那么写出来的函数就是可重入的：

1）不要使用全局变量。因为别的代码很可能改变这些变量值。

2）在和硬件发生交互的时候，切记执行类似 disinterrupt() 之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/ 退出核心”。

3）不能调用其它任何不可重入的函数。

4）谨慎使用堆栈。

Linux常见的可重入函数

 

 

### 2.9.5.4、总结

(1)功能是一样的，但是可重入版本会比较安全一些，建议使用。

(2)有关于环境变量的所有操作，主要理解了环境变量在DDR中的存储方法，理解了环境变量和gd全局变量的关联和优先级，理解了环境变量在存储介质中的存储方式（专用raw分区），整个环境变量相关的都清楚了。

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第十章 uboot源码分析6-uboot的硬件驱动部分

## 2.10.0 章节概要

**2.10.1.uboot与linux驱动**

​    本节从框架上分析了uboot中操控硬件的方法，并且讲述了这种从linux驱动移植而来的硬件操作方法的特点。

**2.10.2.iNand/SD驱动解析1**

​    本节开始分析uboot中驱动SD卡/iNand的整体框架，从SD卡的初始化函数开始依次追溯。

**2.10.3.iNand/SD驱动解析2**

​    本节继续分析SD卡/iNand的驱动程序

**2.10.4.iNand/SD驱动解析3**

​    本节对SD卡/iNand的驱动程序框架进行总结，并且初步提出驱动中方法与数据分离以及分层的思想，这是linux驱动框架设计的关键。

## 2.10.1.uboot与linux驱动

### 2.10.1.1、uboot本身是裸机程序

(1)裸机本来是没有驱动的概念的（狭义的驱动的概念就是操作系统中用来具体操控硬件的那部分代码叫驱动）。

(2)裸机程序中是直接操控硬件的，操作系统中必须通过驱动来操控硬件。这两个有什么区别？

**本质区别就是分层。**

 

### 2.10.1.2、uboot的虚拟地址对硬件操作的影响

(1)操作系统（指的是linux）下MMU肯定是开启的，也就是说linux驱动中肯定都使用的是虚拟地址。而纯裸机程序中根本不会开MMU，全部使用的是物理地址。这是裸机下和驱动中操控硬件的一个重要区别。

(2)uboot早期也是纯物理地址工作的，但是现在的uboot开启了MMU做了虚拟地址映射，这个东西驱动也必须考虑。查uboot中的虚拟地址映射表，发现除了0xC0000000-0xCFFFFFFF映射到了0x30000000-0x3FFFFFFF之外，其余的虚拟地址空间全是原样映射的。而我们驱动中主要是操控硬件寄存器，而S5PV210的SFR都在0xExxxxxx地址空间，因此驱动中不必考虑虚拟地址。

 

### 2.10.1.3、uboot借用（移植）了linux驱动

(1)linux驱动本身做了模块化设计。linux驱动本身和linux内核不是强耦合的，这是linux驱动可以被uboot借用（移植）的关键。

(2)uboot移植了linux驱动源代码。uboot是从源代码级别去移植linux驱动的，这就是linux系统的开源性。

(3)uboot中的硬件驱动比linux简单。linux驱动本身有更复杂的框架，需要实现更多的附带功能，而uboot本质上只是个裸机程序，uboot移植linux驱动时只是借用了linux驱动的一部分而已。

 

 

## 2.10.2.iNand/SD驱动解析1

### 2.10.2.1、从start_armboot开始

(1)驱动整体比较庞大，涉及很多个文件夹下的很多文件，函数更多，贸然插入根本不知道看哪里。学习时必须有顺序。

 

### 2.10.2.2、mmc_initialize

int mmc_initialize(bd_t *bis)

{

  struct mmc *mmc;

  int err;

 

  INIT_LIST_HEAD(&mmc_devices);

  cur_dev_num = 0;

 

  if (board_mmc_init(bis) < 0)

​    cpu_mmc_init(bis);

  ……

  ……

 

(1)函数位于：uboot/drivers/mmc/mmc.c。

(2)从名字可以看出，这个函数的作用就是初始化开发板上MMC系统。MMC系统的初始化应该包含这么几部分：SoC里的MMC控制器初始化（MMC系统时钟的初始化、SFR初始化）、SoC里MMC相关的GPIO的初始化、SD卡/iNand芯片的初始化。

(3)mmc_devices链表全局变量，用来记录系统中所有已经注册的SD/iNand设备。所以向系统中插入一个SD卡/iNand设备，则系统驱动就会向mmc_devices链表中插入一个数据结构表示这个设备。

​    (4)  if (board_mmc_init(bis) < 0) 这个函数展开：

 

  int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));

___________________________________________________________________________

  static int __def_mmc_init(bd_t *bis)

{

  return -1;

}

  __attribut__可以查看gcc的attribut属性，这里的意思是弱属性，表示给__def_mmc_init 起一个别称叫 board_mmc_init;

 

   

### 2.10.2.3、cpu_mmc_init

 

int cpu_mmc_init(bd_t *bis)

{

\#ifdef CONFIG_S3C_HSMMC  //已定义

  setup_hsmmc_clock();

  setup_hsmmc_cfg_gpio();

  return smdk_s3c_hsmmc_init();

\#else

  return 0;

\#endif

}

 

(1)函数位于：uboot/cpu/s5pc11x/cpu.c中。实质是通过调用3个函数来完成的。

(1)setup_hsmmc_clock，在uboot/cpu/s5pc11x/setup_hsmmc.c中。看名字函数是用来初始化SoC中MMC控制器中的时钟部分的。

void setup_hsmmc_clock(void)

{

  u32 tmp;

  u32 clock;

  u32 i;

 

  /* MMC0 clock src = SCLKMPLL */

  tmp = CLK_SRC4_REG & ~(0x0000000f);

  CLK_SRC4_REG = tmp | 0x00000006;

 

  /* MMC0 clock div */

  tmp = CLK_DIV4_REG & ~(0x0000000f);

  clock = get_MPLL_CLK()/1000000;

  for(i=0; i<0xf; i++)  //自动计算clock 设置为多少MHz

  {

​    if((clock / (i+1)) <= 50) {

​      CLK_DIV4_REG = tmp | i<<0;

​      break;

​    }

  }

 

 

(2)setup_hsmmc_cfg_gpio，在uboot/cpu/s5pc11x/setup_hsmmc.c中。看名字函数是用来配置SoC中MMC控制器相关的GPIO的。

void setup_hsmmc_cfg_gpio(void)

{

  ulong reg;

 

  /* MMC channel 0 */

  /* 7 pins will be assigned - GPG0[0:6] = CLK, CMD, CDn, DAT[0:3] */

  reg = readl(GPG0CON) & 0xf0000000;

  writel(reg | 0x02222222, GPG0CON);

  reg = readl(GPG0PUD) & 0xffffc000;

  writel(reg | 0x00002aaa, GPG0PUD);

  writel(0x00003fff, GPG0DRV);

 

 

## 2.10.3.iNand/SD驱动解析2

### 2.10.3.1、smdk_s3c_hsmmc_init

 

int smdk_s3c_hsmmc_init(void)

{

  int err;

 

\#ifdef USE_MMC0

  err = s3c_hsmmc_initialize(0);

  if(err)

​    return err;

\#endif

 

\#ifdef USE_MMC1

  err = s3c_hsmmc_initialize(1);

  if(err)

​    return err;

\#endif 

 

(1)函数位于：uboot/drivers/mmc/s3c_hsmmc.c中。

(2)函数内部通过宏定义USE_MMCx来决定是否调用s3c_hsmmc_initialize来进行具体的初始化操作。

### 2.10.3.2、s3c_hsmmc_initialize

static int s3c_hsmmc_initialize(int channel)

{

  struct mmc *mmc;

 

  mmc = &mmc_channel[channel];

 

  sprintf(mmc->name, "S3C_HSMMC%d", channel);

  mmc->priv = &mmc_host[channel];

  mmc->send_cmd = s3c_hsmmc_send_command;

  mmc->set_ios = s3c_hsmmc_set_ios;

  mmc->init = s3c_hsmmc_init;

 

  mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;

  mmc->host_caps = MMC_MODE_4BIT | MMC_MODE_HS_52MHz | MMC_MODE_HS;

\#if defined(USE_MMC0_8BIT) || defined(USE_MMC2_8BIT)

  mmc->host_caps |= MMC_MODE_8BIT;

\#endif

 

  mmc->f_min = 400000;

  mmc->f_max = 52000000;

 

  mmc_host[channel].clock = 0;

 

  switch(channel) {

  case 0:

​    mmc_host[channel].ioaddr = (void *)ELFIN_HSMMC_0_BASE;

​    break;

  case 1:

​    mmc_host[channel].ioaddr = (void *)ELFIN_HSMMC_1_BASE;

​    break;

  case 2:

​    mmc_host[channel].ioaddr = (void *)ELFIN_HSMMC_2_BASE;

​    break;

\#ifdef USE_MMC3

  case 3:

​    mmc_host[channel].ioaddr = (void *)ELFIN_HSMMC_3_BASE;

​    break;

\#endif

  default:

​    printk("mmc err: not supported channel %d\n", channel);

  }

  

  return mmc_register(mmc);

}

 

(1)函数位于：uboot/drivers/mmc/s3c_hsmmc.c中。

(2)定义并且实例化一个struct mmc类型的对象（定义了一个指针，并且给指针指向有意义的内存，或者说给指针分配内存），然后填充它的各种成员，最后调用mmc_register函数来向驱动框架注册这个mmc设备驱动。

  INIT_LIST_HEAD(&mmc->link);

  list_add_tail(&mmc->link, &mmc_devices);

 

(3)mmc_register功能是进行mmc设备的注册，注册方法其实就是将当前这个struct mmc使用链表连接到mmc_devices这个全局变量中去。

(4)我们在X210中定义了USE_MMC0和USE_MMC2，因此在我们的uboot初始化时会调用2次s3c_hsmmc_initialize函数，传递参数分别是0和2，因此完成之后系统中会注册上2个mmc设备，表示当前系统中有2个mmc通道在工作。

(5)至此cpu_mmc_init函数分析完成。

 

### 2.10.3.3、find_mmc_device

 

struct mmc *find_mmc_device(int dev_num)

{

  struct mmc *m;

  struct list_head *entry;

 

  list_for_each(entry, &mmc_devices) {

​    m = list_entry(entry, struct mmc, link);

 

​    if (m->block_dev.dev == dev_num)

​      return m;

  }

 

  printf("MMC Device %d not found\n", dev_num);

 

  return NULL;

}

 

 

(1)这个函数位于：uboot/drivers/mmc/mmc.c中。

(2)这个函数其实就是通过mmc设备编号来在系统中查找对应的mmc设备（struct mmc的对象，根据上面分析系统中有2个，编号分别是0和2）。

(3)函数工作原理就是通过遍历mmc_devices链表，去依次寻找系统中注册的mmc设备，然后对比其设备编号和我们当前要查找的设备编号，如果相同则就找到了要找的设备。找到了后调用mmc_init函数来初始化它。

### 2.10.3.4、mmc_init

(1)函数位于：drivers/mmc/mmc.c中。

(2)分析猜测这个函数应该要进行mmc卡的初始化了（前面已经进行了SoC端控制器的初始化）

(3)函数的调用关系为：

mmc_init

​    mmc_go_idle

​       mmc_send_cmd

​    mmc_send_if_cond

​       mmc_send_cmd

​    ······

具体分析可以看出，mmc_init函数内部就是依次通过向mmc卡发送命令码（CMD0、CMD2那些）来初始化SD卡/iNand内部的控制器，以达到初始化SD卡的目的。

 

### 2.10.3.3、总结

(1)至此整个MMC系统初始化结束。

(2)整个MMC系统初始化分为2大部分：SoC这一端的MMC控制器的初始化，SD卡这一端卡本身的初始化。前一步主要是在cpu_mmc_init函数中完成，后一部分主要是在mmc_init函数中完成。

(3)整个初始化完成后去使用sd卡/iNand时，操作方法和mmc_init函数中初始化SD卡的操作一样的方式。读写sd卡时也是通过总线向SD卡发送命令、读取/写入数据来完成的。

(4)顺着操作追下去，到了mmc_send_cmd函数处就断了，真正的向SD卡发送命令的硬件操作的函数找不到。这就是学习驱动的麻烦之处。

(5)struct mmc结构体是关键。两部分初始化之间用mmc结构体来链接的，初始化完了后对mmc卡的常规读写操作也是通过mmc结构体来链接的。

 

 

## 2.10.4.iNand/SD驱动解析3

### 2.10.4.1、struct mmc

(1)驱动的设计中有一个关键数据结构。譬如MMC驱动的结构体就是struct mmc这些结构体中包含一些变量和一些函数指针，变量用来记录驱动相关的一些属性，函数指针用来记录驱动相关的操作方法。这些变量和函数指针加起来就构成了驱动。驱动就被抽象为这个结构体。

(2)一个驱动工作时主要就分几部分：驱动构建（构建一个struct mmc然后填充它）、驱动运行时（调用这些函数指针指针的函数和变量）

 

### 2.10.4.2、分离思想

(1)分离思想就是说在驱动中将操作方法和数据分开。

(2)操作方法就是函数，数据就是变量。所谓操作方法和数据分离的意思就是：在不同的地方来存储和管理驱动的操作方法和变量，这样的优势就是驱动便于移植。

 

### 2.10.4.3、分层思想

(1)分层思想是指一个整个的驱动分为好多个层次。简单理解就是驱动分为很多个源文件，放在很多个文件夹中。譬如本课程讲的mmc的驱动涉及到drivers/mmc下面的2个文件和cpu/s5pc11x下的好几个文件。

(2)以mmc驱动为例来分析各个文件的作用：

uboot/drivers/mmc/mmc.c：本文件的主要内容是和MMC卡操作有关的方法，譬如MMC卡设置空闲状态的、卡读写数据等。但是本文件中并没有具体的硬件操作函数，操作最终指向的是struct mmc结构体中的函数指针，这些函数指针是在驱动构建的时候和真正硬件操作的函数挂接的（真正的硬件操作的函数在别的文件中）。

uboot/drivers/mmc/s3c_hsmmc.c:本文件中是SoC内部MMC控制器的硬件操作的方法，譬如向SD卡发送命令的函数（s3c_hsmmc_send_command），譬如和SD卡读写数据的函数（s3c_hsmmc_set_ios），这些函数就是具体操作硬件的函数，也就是mmc.c中需要的那些硬件操作函数。这些函数在mmc驱动初始化构建时（s3c_hsmmc_initialize函数中）和struct mmc挂接起来备用。

 

分析：mmc.c和s3c_hsmmc.c构成了一个分层，mmc.c中调用了s3c_hsmmc.中的函数，所以mmc.c在上层，s3c_hsmmc.c在下层。这两个分层后我们发现mmc.c中不涉及具体硬件的操作，s3c_hsmmc.c中不涉及驱动工程时的时序操作。因此移植的时候就有好处：譬如我们要把这一套mmc驱动移植到别的SoC上mmc.c就不用动，s3c_hsmmc.c动就可以了；譬如SoC没变但是SD卡升级了，这时候只需要更换mmc.c，不需要更换s3c_hsmmc.即可。

 

(3)cpu/s5pc11x/下面还有一个setup_hsmmc.c，也和MMC驱动有关。但是这些代码为什么不能放到drivers目录下去，而要放到cpu目录下去？因为这里面的2个函数（setup_hsmmc_clock和setup_hsmmc_cfg_gpio）都是和SoC有关的初始化函数，这两个函数不能放到drivers目录下去。实际上如果非把这两个函数放在uboot/drivers/mmc/s3c_hsmmc.c文件中也凑活能说过去。

 

### 2.10.4.4、linux驱动前奏

让大家基本认识以下驱动，真正的驱动是非常复杂的。这里仅仅是uboot从Linux移植来的简略版。学驱动最主要学的是驱动的框架。

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第十一章 uboot的移植1-从三星官方uboot开始移植

## 2.11.0 章节概要

**2.11.1.移植前的准备工作**

​    本节介绍uboot移植工作正式开始前的准备工作，主要是环境搭建和必备工具的使用。

**2.11.2.ubuntu14.04上网及安装openssh**

​    本节详细介绍ubuntu14.04的网络配置问题，然后安装openssh-server，最后用sshsecureshell登录。

**2.11.3.移植初体验**

​    本节开始进行uboot移植，先使用三星移植版本的uboot直接编译烧写运行，再根据结果去分析问题，逐步展开移植工作。

**2.11.4.时钟和DDR的配置移植**

​    本节对配置文件中的时钟设置和DDR初始化信息、DDR配置信息做更改移植。

**2.11.5.DDR地址另外配置**

​    本节我们将对DDR进行另外配置，将DDR地址修改到30000000开始的区域。通过本次修改让大家进一步熟悉uboot的移植。

**2.11.6.DDR地址另外配置2**

​    本节接上节来继续解决DDR重新配置的问题，主要是发现问题定位问题并解决问题的思路引导和实践。

**2.11.7.inand驱动问题的解决**

​    本节我们通过分析和思考来解决iNand初始化不成功的问题，通过本实验让大家进一步认识到uboot移植的实质。

**2.11.8.一些小问题的修补**

​    本节对一些小细节问题进行修补，包括网络相关的环境变量的默认值、修改控制台使用的串口、修改行提示符等。

**2.11.9.网卡驱动移植1**

​    本节对uboot进行网卡驱动的移植，其实主要是网卡初始化函数的分析和更改。

**2.11.10.网卡驱动移植2**

​    本节进行网卡移植的代码实战，让大家看到网卡驱动移植前后的实验现象的差别，明白移植并不是一件困难的事情。

**2.11.11.网卡驱动如何工作**

​    本节以ping命令为例讲述uboot中的网卡驱动的工作原理，试图让大家对网卡芯片多一些了解，降低网络通信的神秘感。

**2.11.12.使用自己移植的uboot启动内核**

​    本节对uboot最一些更改和移植，使这个uboot可以用来启动内核。

## 2.11.1.移植前的准备工作

### 2.11.1.1、三星移植过的uboot源代码准备

(1)三星对于S5PV210的官方开发板为SMDKV210，对应的移植过的uboot是：网盘/2.uboot和linux内核移植（努力更新中）\资源下载\三星官方为210移植过的uboot和kernel/android_uboot_smdkv210.tar.bz2

(2)这个源代码网上是下载不到的，三星官方是不会把这些东西放在官网上下载的。这些东西都是随着官方的开发板一起流出的。

 

### 2.11.1.2、SourceInsight准备

(1)移植的时候最重要的工作就是看代码、改代码然后编译运行测试。

(2)编译代码必须在linux中（windows共享文件夹中配置uboot不行的），那么看代码和改代码可以在linux中（vim、gedit）也可以在windows中（Sourceinsight）。

(3)我一般习惯的方式是：在windows中解压一份uboot源代码，在linux中也解压一份，注意这两份代码原始情况是一模一样的。然后移植的时候是在windows中这一份中去看代码、改代码；在linux中这一份去编译烧写。这种做法需要在windows中和linux中2份代码之间保持同步（直白点说就是windows中改过了后要把改过的源代码复制到linux中那一份去覆盖linux中那一份里面的同目录同文件）。

(4)问题来了，怎么在windows中和linux中同步代码？通过共享文件夹在linux中进行复制（cp /mnt/hgfs/winshare/xxx.c ./）；通过一些专用工具，譬如sshsecureshell。

 

### 2.11.1.3、便捷的文件传输工具sshsecureshell

(0)windows中安装sshsecureshell客户端。

(1)虚拟机上网。不同的ubuntu版本中网卡重启的命令不同，在ubuntu10.04中网卡重启使用：/etc/init.d/networking restart 或者 service network restart就可以；但是在ubuntu14.04中这两个都不行了，要重启网卡需要使用：ifdown eth0 然后ifup eth0即可。

 

 

## 2.11.2.ubuntu14.04上网及安装openssh

### 2.11.2.1、ubuntu14.04上网问题

(1)虚拟机上网有2种模式，NAT和桥接。

(2)虚拟机上网配置要注意这几个地方：第一个要注意选择NAT还是桥接模式；第二个要注意ubuntu中网络配置文件/etc/network/interfaces，这个文件中 是配置网卡信息的（譬如静态ip还是dhcp，静态ip地址是多少等）；第三个如果是桥接模式要注意桥接到哪个网卡上（一般笔记本都有2个网卡，一个是有线网卡一个是无线网卡），如果是NAT模式没关系。

(3)ubuntu14.04中重启网卡的命令变了。

(4)演示：NAT方式下上网配置过程：

前提是主机windows通过无线wifi上网了（或者windows通过有线上网也可以）。然后在虚拟机中配置2点：第一选择NAT方式，第二配置/etc/network/inerfaces文件中使用**dhcp（动态获取ip）**方式；然后重启网卡，确认ip地址得到后即可上网。

(5)演示：桥接方式上网配置过程：

前提是主机windows通过无线wifi上网了(主机通过有线网卡上网的配置方式有不同)。然后虚拟机中配置注意三点：第一选择桥接方式，第二配置桥接到无线网卡（如果主机windows是通过有线上网的，则桥接到有线网卡）；第三配置/etc/network/inerfaces文件中使用dhcp方式；然后重启网卡，确认ip地址得到后即可上网。

(6)演示：虚拟机要ping通开发板的配置过程。

前提是开发板和电脑之间通过网线连接好。然后虚拟机中配置注意三点：第一选择桥接方式，第二配置桥接到有线网卡（如果配置为自动或者配置桥接到无线网卡则肯定无法ping通开发板）；第三配置/etc/network/inerfaces文件中使用static方式，ip地址配置保证和主机windows、开发板三者处于同一网段；然后重启网卡，确认ip地址得到后即可ping通开发板。

(7)windows系统中有一个bug，如果windows没有检测到有线网卡连接了外部网络则windows中本地连接是不工作的，网卡不工作。解决方案是用网线随便连接一个有联网能力的东西即可，譬如网线连接你的电脑到旁边兄弟的电脑上，譬如插上你的开发板（开发板中运行了linux系统），譬如插上路由器端口。

### 2.11.2.2、搭建openssh环境

(1)安装ssh-server。(sudo apt-get install openssh-server)如果报错提示依赖错误，可以参考：http://www.cnblogs.com/mliudong/p/4094519.html

 

(2)securecrt登录

(3)sshsecureshell登录

ssh登录不上，要修改/etc/ssh/sshd_config，参考：http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html。       修改完重启时如果/etc/init.d/ssh restart不起作用，可以使用：ps -e | grep ssh，看sshd的进程号，然后kill -9 进程号杀死ssh进程以达到重启的目的，或者直接重启ubuntu系统

 

 

## 2.11.3.移植初体验

### 2.11.3.1、直接编译三星移植版uboot尝试运行

(1)复制到linux的源生目录下，然后解压开。

(2)检查Makefile中的交叉编译工具链

(3)配置时使用：make smdkv210single_config，对应include/configs/smdkv210single.h头文件。

(4)配置完成后直接make编译，编译完成后就进入烧录步骤。

(5)uboot/sd_fusing目录下有sd_fusing.sh脚本，用来烧录。

 

### 2.11.3.2、代码分析&问题查找

运行结果是：第一，串口无输出；第二，开发板供电锁存成功。

分析运行结果：uboot中串口最早的输出在"OK"，在lowlevel_init.S中初始化串口时打印出来的；串口无输出"O"说明在打印"O"之前代码已经死掉了；开发板供电锁存在lowlevel_init.S中，开发板供电锁存成功说明这个代码之前的部分是没问题的。两个结合起来得到结论：错误在开发板供电锁存代码和串口初始化打印"O"代码之间。

 

(1)Windows下建立SourceInsight工程

(2)顺藤摸瓜去找可能出问题的地方

整个程序运行是从start.S开始的，看代码也从这里开始。

实际上只要屏蔽掉bl PMIC_InitIp    这一行代码，然后重新编译，整个uboot就启动起来了。但是很多配置信息是有问题的，很多功能应该也是不能用的，都要去一一查验。

 

 

## 2.11.4.时钟和DDR的配置移植

### 2.11.4.1、更改CONFIG_IDENT_STRING为" for ASTON210"，

然后同步到ubuntu中的一份代码，然后 make distclean; make smdkv210single_config，然后make，然后烧录运行，检查打印出来的banner信息是否如我们改动的那样。

 

### 2.11.4.2、确认时钟部分的配置

(1)时钟部分的运行结果本来就是对的，时钟部分的代码在lowlevel_init.S中的bl system_clock_init调用的这个函数中。函数的代码部分是没任何问题的，根本不需要改动，要改动的是寄存器写入的值，这些值都在配置头文件（smdkv210single.h）中用宏定义定义出来了。如果时钟部分要更改，关键是去更改头文件中的宏定义。

(2)三星移植时已经把210常用的各种时钟配置全都计算好用宏开关来控制了。只要打开相应的宏开关就能将系统配置为各种不同的频率。

 

### 2.11.4.3、DDR配置信息的更改

(1)从运行信息以及bdinfo命令看到的结果，显示DRAM bank0和1的size值都设置错了。

(2)使用md和mw命令测试内存，发现20000000和40000000开头的内存都是可以用的，说明代码中DDR初始化部分是正确的，只是size错了。

(3)内存部分配置成：

\#define CONFIG_NR_DRAM_BANKS  2     /* we have 2 bank of DRAM */

//#define SDRAM_BANK_SIZE     0x20000000  /* 512 MB */

\#define SDRAM_BANK_SIZE     0x10000000  /* 256 MB */

 

\#define PHYS_SDRAM_1      MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */

\#define PHYS_SDRAM_1_SIZE    SDRAM_BANK_SIZE

//#define PHYS_SDRAM_2      (MEMORY_BASE_ADDRESS + SDRAM_BANK_SIZE) /* SDRAM Bank #2 */

\#define PHYS_SDRAM_2      0x40000000

\#define PHYS_SDRAM_2_SIZE    SDRAM_BANK_SIZE

 

 

 

## 2.11.5.DDR地址另外配置

### 2.11.5.1、目标：将DDR端口0地址配置为30000000开头

(1)更改有2个目的：

第一是让大家体验内存配置的更改过程；

第二是3开头的地址和DRAM bank1上40000000开头的地址就连起来了。这样我们就得到了地址连续的512MB内存，而原来我们得到的512MB内存地址是断续的。

 

### 2.11.5.2、DDR初始化参数更改

(1)根据裸机中讲DDR初始化部分的课程，和uboot前面分析uboot中DDR初始化部分的代码的课程，得出结论就是：DDR的初始化代码部分是在lowlevel_init.S中写的，是不动的。代码部分就是对相应寄存器做相应值的初始化；要动的是值，而uboot为了具有可移植性把值都宏定义在include/configs/xxx.h中了。因此我们只需要去这个配置头文件中更改配置值即可。

(2)更改内容是：

\#define DMC0_MEMCONFIG_0  0x20E01323改为：

\#define DMC0_MEMCONFIG_0  0x30E01323 

​    注意20改为30了。

 

查数据手册，

 

### 2.11.5.3、smdkv210single.h中相关宏定义修改

(1)寄存器的值改了后相当于是硬件配置部分做了更改。但是uboot中DDR相关的一些软件配置值还没更改，还在原来位置，所以要去更改。

(2) #define MEMORY_BASE_ADDRESS 0x20000000改为：

\#define MEMORY_BASE_ADDRESS 0x30000000

 

 

 

### 2.11.5.4、虚拟地址映射表中相应修改

//下面是0xc0000000-d0000000这一段虚拟地址的映射表设置，现在的设置是将这段内存映射到0x20000000到0x30000000

.set __base,0x200

  // 256MB for SDRAM with cacheable

  .rept 0xD00 - 0xC00

  FL_SECTION_ENTRY __base,3,0,1,1

  .set __base,__base+1

  .endr

 

 

(1)uboot中开启了MMU对内存进行了段式映射，有一张内存映射表。之前课程中分析过，分析方法是一样的。

(2)经过实际分析，发现这个内存映射只是把20000000开始的256MB映射到C0000000开头的256MB。我们更改方法是**将2改成3.**

.set __base,0x300

(3)为了安全起见，再去配置头文件smdkv210single.h中查一遍，看看有没有其他的宏定义值和内存配置有关联的。

 

重新配置编译，烧录运行查看结果。

 

改动出错

## 2.11.6.DDR初始化参数更改2

### 2.11.6.1、修改DMC0的配置参数

  

​    （Sheridan）光改chipbasebit[31:24]是不行的，我们还得改chip_mask;这个值设置的是芯片大小，它采用的补码的方式来改写。比如芯片256MB，对应的大小就是0x0FFFFFFF,而这个数的补码就是0xF0；

 

(1)修改DDR中DMC0的memconfig_0寄存器的配置值，将

\#define DMC0_MEMCONFIG_0  0x30E01323 改为：

\#define DMC0_MEMCONFIG_0  0x30F01323

 

 (2)然后重新同步、编译烧写运行，发现uboot第二阶段运行了，但是整个uboot还是不成功。

(3)分析问题，寻找解决方案。分析方法有2种：第一种靠经验、靠发现能力、靠直觉去找；第二种就是在整个代码中先基本定位错误地方，然后通过在源代码中添加打印信息来精确定位出错的代码，然后找到精确的出错位置后再去分析错误原因，从而找到解决方案。

 

### 2.11.6.2、修改修改虚拟地址到物理地址的映射函数

(1)修改uboot/board/samsung/smdkc110/smdkc110.c中的virt_to_phy_smdkc110，将其中的20000000改为30000000即可。

(2)同步代码，然后重新编译烧录运行。

 

**2.11.6.3****、关于Uboot不能和老师的一样完整启动，停留在输出NAND**

 

（Sheridan）不知道为什么？Uboot启动到打印NAND:这就出错了，真个Uboot就停在这里了，和老师整个Uboot都启动不一样。经过一步步排查发现问题出现在/lib_arm/board.c的第497到500行。



\#if defined(CONFIG_CMD_NAND)

​    puts("NAND:  ");

​    nand_init();

  \#endif

  将/lib_arm/board.c的第497到500行。

这个函数删除，或者/include/configs/smdkv210single.h中将

\#defined CONFIG_CMD_NAND 这句话删除

 

### 2.11.6.3、总结：牵一发而动全身

 

 

## 2.11.7.inand驱动问题的解决

### 2.11.7.1、先从现象出发定位问题

(1)解决问题的第一步，是定位问题。所谓定位问题就是找到源代码当中导致这个问题的那一句或者那几句代码。有时候解决这个问题需要修改的代码和直接导致这个问题的代码是不同的。我们这里说的定位问题指的是定位到出问题的代码处，也就是运行了这一句代码时发生了这个错误。

(2)定位了问题之后，实际修改程序解决问题不一定改的是这一句代码。但是肯定和这一句代码有关联，我们要通过自己分析来找到这种关联，从而从定位的错误点找到真正需要修改的点，然后去修改他。

(3)实战方法：从打印出来的错误休息中挑选一个关键词，然后去源代码中搜索这个关键字，通过这种搜索的方法定位问题。通过搜索将问题定位在drivers/mmc/mmc.c的818行。

(4)然后就是解决问题了。

 

### 2.11.7.2、网络搜索解决方案

(1)初步的解决方案是自己先浏览一遍这个问题点周边代码上下文。通过浏览代码上下文，发现这个函数是在读取SD/iNand的ext_csd寄存器的值。通过浏览代码结合出错地方，可以判断出：从卡端读取ext_csd寄存器是成功的，并且从读取结果中拿到了卡的版本号信息。然后代码对版本号进行了判断，并且如果版本号大于5就会报错并且函数错误退出。这就是问题所正。

/*

 \* Read and decode extended CSD（Card specific Date）SD卡特有的信息.

 */

static int mmc_read_ext_csd(struct mmc *host)

{

 

(2)问题就是：我们使用的iNand卡的版本号大于5，而uboot代码本身不处理版本号大于5的卡，因此出错了。

(3)怎么解决？第一可能，换卡；第二可能，软件修复。

(4)网络搜索错误关键字，然后逐个去查阅，看看哪个可以给我们提供解决问题的思路和方法。http://blog.csdn.net/wang_shuai_ww/article/details/22308853

 

**2.11.7.3****、尝试修改代码解决问题**

(1)解决方法就是修改uboot中的代码，把判断的5改成更大的数字。譬如8，然后跳过这个错误。

 

**2.11.7.4****、推测和实验验证（SD卡和iNand的区别）**

(1)当前板子上有一个iNand接在SD0上，有一个外置SD卡接在SD2上。那uboot中初始化的这个是iNand而不是SD卡。也就是说uboot中实际用的是SD0而不是SD2.

在/drivers/mmc/mmc.c文件中

int mmc_initialize(bd_t *bis)

{

 mmc = find_mmc_device(0);

将find_mmc_device(0) 改为1；

 

(2)大家可以尝试，使用外置SD卡时，这个版本号的问题不会出现。从这里可以推测出SD卡和iNand的区别，至少从一个角度可以看出：SD卡版本高，iNand的版本比较低。

 

 

## 2.11.8.一些小问题的修补

### 2.11.8.1、控制台串口更换为串口0

(1)uboot中默认使用串口2来做控制台输入输出的。

(2)SOC中一共有4个串口（串口0、1、2、3），开发板X210上用DB9接口引出了2个串口，分别是串口2和串口0.（靠边的是串口2，靠里那个是串口0）。

(3)三星公司推荐使用串口2来作为调试串口，所以在三星移植的uboot和内核版本中都是以串口2默认为控制台串口的。

(4)有时候项目需要将调试串口修改为另外的串口（譬如串口0），这时候需要修改uboot的代码，做移植让uboot工作在串口0的控制台下。

//  include/s5pc110.h

\#if defined(CONFIG_SERIAL1)

\#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART0_OFFSET)

\#elif defined(CONFIG_SERIAL2)

\#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART1_OFFSET)

\#elif defined(CONFIG_SERIAL3)

\#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART2_OFFSET)

\#elif defined(CONFIG_SERIAL4)

\#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART3_OFFSET)

\#else

\#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART0_OFFSET)

\#endif

 

//include/config.s/smdkv210single.h

 

\#define CONFIG_SERIAL3     1  /* we use UART2 on SMDKC110

(Sheridan)将CONFIG_SERIAL3 修改 CONFIG_SERIAL1 

(5)uboot中真正去硬件初始化串口控制器的代码在lowlevel_init.S中的uart_asm_init中，其中初始化串口的寄存器用ELFIN_UART_CONSOLE_BASE宏作为串口n的寄存器的基地址，结合偏移量对寄存器进行寻址初始化。所以uart_asm_init中到底初始化的是串口几（从0到3）？取决于ELFIN_UART_CONSOLE_BASE宏。这个宏的值又由CONFIG_SERIALn（n是从1到4）来决定。

(6)同步代码、编译烧录运行，发现串口线插在串口2上，crt上只打印：SD checksum error.（这个是内部iROM打印出来的，内部iNand校验失败的信息）；然后将串口线改插到串口0上，启动，所有的信息出现。实验成功。

 

### 2.11.8.2、修改默认网络地址设置

\#define CONFIG_ETHADDR   00:40:5c:26:0a:5b

\#define CONFIG_NETMASK   255.255.255.0

\#define CONFIG_IPADDR    192.168.0.20

\#define CONFIG_SERVERIP   192.168.0.10

\#define CONFIG_GATEWAYIP  192.168.0.1

 

(1)修改配置头文件smdkv210single.h中的CONFIG_IPADDR等宏，则可以修改uboot的默认环境变量。

 

### 2.11.8.3、修改行提示符

(1)#define CFG_PROMPT     "SMDKV210 # "  /* Monitor Command Prompt   */

改为自己喜欢的名字如"Sheridan# "

(2)更改完成后如果环境变量还是原来的，正常。因为原来uboot执行过saveenv，因此环境变量已经被保存到iNand中的ENV分区中去了。uboot启动后校验时iNand的ENV分区中的环境变量是正确的，因此会优先加载。我们在uboot源代码中修改的只是默认的环境变量。解决方案是擦除掉iNand中的那一份环境变量，然后迫使uboot启动时使用uboot代码中自带的默认的这一份环境变量，就可以看到了。

mmc write <device num> addr blk# cnt；(help)

(3)可以使用mmc write 0 30000000 11# 32（表示将DDR的0x30000000开头的一段内存中的内容写入iNand中的第17个扇区开始的32个扇区内，写入长度是32个扇区长度（16KB））。这个数字不应该都表示16进制么？ 擦除32个扇区应该是20？？？？

 

 

### 2.11.8.4、总结

(1)结论就是对uboot的整体结构和过程了解之后，移植非常简单。

 

 

## 2.11.9.网卡驱动移植1

### 2.11.9.1、网卡芯片与开发板的连接方式

   (1)SoC的SROM bank和网卡芯片的CS引脚（SROM就是SRAM/ROM）。SoC的SROMController其实就是SoC提供的对外总线式连接SRAM/ROM的接口。如果SoC要外部外接一些SRAM/ROM类的存储芯片（或者伪装成SROM接口的芯片，譬如网卡芯片）就要通过**SROM Controller****来连接**。网卡接在SROM中好处就是网卡芯片好像一个存储芯片一样被扩展在SoC的一个地址空间中，主机SoC可以直接用一个地址来访问网卡芯片内部寄存器。

 

(2)网卡芯片内部寄存器使用相对地址访问。网卡芯片内部很多寄存器有一个地址，这个地址是从00开始的，但是实际上我们SoC不能用0地址去访问这个网卡的芯片内部寄存器。SoC访问网卡芯片00寄存器时的地址应该是：**起始地址+offset**这里的起始地址就是网卡芯片对应接在SROM bankn中的bankn对应的基地址。

(3)主机SoC上网，其实就是通过操控网卡芯片内部的寄存器、缓冲区等资源来上网的。也就是说其实SoC是通过网卡芯片来间接上网的。

(4)总结：实际上也是一种总线式连接方式。优势是SoC内部不需要内置网卡控制器，所有的SFR全都在外部网卡芯片中，而且还可以通过地址直接访问（IO与内存统一编址），不用像Nand/SD接口一样使用时序来访问。

(5)从逻辑上来看，网卡更像是串口，而不像是SD/Nand。

 

 

 

 

 

 

 

 

### 2.11.9.2、原理图浏览

 

   (1)210的SROM控制器允许8/16bit的接口，我们实际使用的是16位接口。

(2)网线有8根线，但是实际只有4根有效通信线，另外4根都是GND，用来抗干扰的。4根通信线中管发送的有2根（Tx-和Tx+），管接收的有2根（Rx+和Rx-）。因为网线上传输的是差分信号。

(3)**网卡芯片有个CS引脚，CS就是chip select，片选信号**。主机向CS发送有效信号则从机芯片工作，主机向CS发送无效信号则从机芯片不工作。，这个引脚要接主机SoC的片选信号引脚，主机S5PV210的每一个SROM bank中有一个片选信号CSn(n=0-5)，从原理图可以看出，我们X210上将DM9000的CS引脚接到了CSn1上，对应**SROM bank1**（推断出DM9000的总线地址基地址是0x88000000）。

  

(4)DM9000的CMD引脚接到了S5PV210的ADDR2引脚上。DM9000为了减少芯片引脚数，数据线和地址线是复用的（DATA0到DATA15这16根线是有时候做数据线传输数据，有时候做地址线传输地址的。什么时候做什么用就由CMD引脚决定。）通过查询数据手册知道：当CMD为高电平时对应传输是DATA，当CMD为低电平时对应传输为INDEX（offset，寄存器地址）。

 

注明：这些引脚上的电平变化都是控制器自动的，不需要程序员手工干预。程序员所需要做的就是在配置寄存器值时充分考虑到硬件电路的接法，然后给相应寄存器配置正确的数值即可。

 

 

## 2.11.10.网卡驱动移植2

### 2.11.10.1、网卡驱动文件介绍

(1)uboot中本来就提供了很多网卡芯片的驱动程序，在uboot/drivers/net/dm9000x.c和dm9000x.h。这个驱动来自于linux kernel源代码。所以我们uboot中是移植而不是编写。

(2)要想彻底看懂这个驱动，必须对linux的驱动模型中网络设备驱动有一定的理解才可以。因为我们还没学驱动，因此这个源代码就不用看了。

(3)这个驱动是linux内核中做好的，根本不用动可以在uboot中直接使用的。而且因为linux驱动设计的很合理（**数据和代码是分开的**，这里驱动主要是代码，数据是由硬件开发板中的接法决定的，数据由一定的数据结构来提供。），所以驱动本身具有可移植性。这个就决定了我们移植DM9000驱动时这个驱动文件dm9000x.c和h不用动，要动的是数据。

### 2.11.10.2、网卡移植的关键：初始化

(1)uboot在第二阶段init_sequences中进行了一系列的初始化，其中就有网卡芯片的初始化。这个初始化就是关键，在这里的初始化中只要将网卡芯片正确的初始化了，则网卡芯片就能工作（意思是网卡驱动dm9000x.c和dm9000x.h依赖于这里的初始化而工作）。

(2)网卡初始化代码地方在：

start_armboot

  init_sequence

​      board_init

​         dm9000_pre_init      这个函数就是移植的关键

static void dm9000_pre_init(void)

{

  unsigned int tmp;

  SROM_BW_REG &= ~(0xf << 20);

  SROM_BW_REG |= (0<<23) | (0<<22) | (0<<21) | (1<<20);

 

  SROM_BC5_REG = ((0<<28)|(1<<24)|(5<<16)|(1<<12)|(4<<8)|(6<<4)|(0<\<0));

 

  tmp = MP01CON_REG;

  tmp &=~(0xf<<20);

  tmp |=(2<<20);

  MP01CON_REG = tmp;

}

 

(3)dm9000_pre_init函数主要功能就是初始化DM9000网卡。这个初始化过程和我们开发板上DM9000网卡芯片的硬件连接方式有关。必须要结合开发板原理图来分析，然后决定这个函数怎么编程。

 

(4)原来的代码是三星的工程师根据三星的开发板SMDKV210的硬件接法来写的程序，我们要根据自己的开发板的硬件接法去修改这个程序，让网卡在我们的开发板上能工作。

(5)#define DM9000_16BIT_DATA这个宏用来表示DM9000工作在16位总线模式下。根据上节课的硬件原理图的分析，可以看到我们开发板上DM9000确实工作在16位模式下。

(6)从三星版本的代码中可以看出，它操作的是bit20-bit23，对照数据手册中寄存器定义，可以看出三星的开发板DM9000是接在Bank5上的。而我们接在bank1上的，因此我们需要操作的bit位是bit4-bit7。

SROM_BC5_REG = ((0<<28)|(1<<24)|(5<<16)|(1<<12)|(4<<8)|(6<<4)|(0<<0));

**SROM Bank Control Registe****寄存器有****6****个，其编号都相对于所接的****bank****几编号，我们接的是****bank1****，所以只要将****SROM_BC5_REG****改为****SROM_BC1_REG****即可。**

 

**根据手册中的描述，因为我们片选是****CS1,****所以我们要改****MP0_1CON1****这个寄存器，****bit4~7****值为****0x2****，**tmp &=~(0xf<<4); tmp |=(2<<4);

(7)总结：三个寄存器的修改。主要是三星的开发板DM9000接在bank5，我们接在了bank1上，因此要做一些修改。

 

### 2.11.10.3、基地址的配置等

\#ifdef CONFIG_DRIVER_DM9000

\#define CONFIG_DM9000_BASE   (0xA8000000)

\#define DM9000_IO      (CONFIG_DM9000_BASE)

\#if defined(DM9000_16BIT_DATA)

\#define DM9000_DATA     (CONFIG_DM9000_BASE+2)

\#else

\#define DM9000_DATA     (CONFIG_DM9000_BASE+1)

\#endif

\#endif

 

(1)之前说过，驱动分为2部分：代码和数据。代码不用动，数据要修改。

\#define CONFIG_DM9000_BASE   (0x88000000)

(2)CONFIG_DM9000_BASE是DM9000网卡通过SROM bank映射到SoC中地址空间中的地址。这个地址的值取决于硬件接到了哪个bank，这个bank的基地址是SoC自己定义好的。譬如我们这里接到了bank1上，bank1的基地址是0x88000000.

\#define DM9000_DATA     (CONFIG_DM9000_BASE+4)

(3)DM9000_IO表示访问芯片IO的基地址，直接就是CONFIG_DM9000_BASE；DM9000_DATA表示我们访问数据时的基地址，因为DM9000芯片的CMD引脚接到了ADDR2，因此这里要+4（0b100，对应ADDR2）。0b100,这个1刚好是第2根，（0,1,2）。

(4)本来这样配置就完了，重新编译运行网卡就应该工作了。但是实际测试发现不工作，要怎么样修改呢？修改方式是将CONFIG_DM9000_BASE改成0x88000300就工作了。

问题？这个0x300从哪里来的？我得出的感觉最靠谱的解释是：跟DM9000网卡芯片型号版本有关，我认为这个0x300是DM9000网卡本身的问题，他本身的内部寄存器就有一个0x300的一个偏移量。

 

 

## 2.11.11.网卡驱动如何工作

### 2.11.11.1、网卡移植代码实践

(1)经过实践，网卡驱动移植成功。

(2)其实还可以做一些实验。譬如说对网卡驱动初始化部分寄存器的设置，还有网卡CONFIG_DM9000_BASE也可以配成0x88000000再去试一试。

 

### 2.11.11.2、linux系统中网卡驱动的典型工作方式简介

(1)在linux系统中，网卡算是一个设备，这个设备驱动工作后会生成一个设备名叫ethn（n是0、1、2、····）（无线网卡名字一般叫wlan0、wlan1····）。然后linux系统用一些专用命令来操作网卡，譬如ifconfig命令。

(2)linux下的应用程序如何使用网卡驱动来进行网络通信？最通用的方法就是socket接口。linux系统中有一系列的API和库函数，提供了一个socket编程接口，linux下的应用程序都是通过socket来实现上网的，socket内部就是间接调用的网卡驱动实现网络通信的。

(3)linux设计是非常完备的，应用层和驱动层是严格分离的。也就是说写网络编程应用层的人根本不用管驱动，只要会用socket接口即可；写底层驱动的人根本不用管应用层，只要面向linux的网络驱动框架模型即可。

 

### 2.11.11.3、uboot中网卡驱动的工作方式简介

(1)一定要记住：uboot本身是一个裸机程序，是一个整体，没有分层。所以uboot中根本没有驱动和应用的概念。

(2)按照逻辑来说，ping这样的命令实现的代码就是网络应用的应用程序，像dm9000x.c和dm9000x.h这样的代码属于驱动程序。所以在uboot中这些东西是揉在一起的，应用是直接调用驱动实现的。也就是说ping命令内部是直接调用了dm9000的网卡驱动中的函数来实现自己的。

 

### 2.11.11.4、以ping命令为例查找代码验证分析

(1)ping命令是uboot的众多命令之一，ping命令实现的函数叫do_ping

(2)函数的调用关系：

do_ping

​    NetLoop

​       PingStart

​           PingSend 

​              ArpRequest

​                  eth_send（dm9000x.c中）

(3)验证了2.11.11.3中说的uboot中应用程序（ping）调用驱动程序（dm9000x.c）的方式。这就是一种直接调用的方式。

 

注：lcd驱动与logo显示，在2.13.uboot杂记-logo显示和fastboot原理等中详解

 

 

## 2.11.12.使用自己移植的uboot启动内核

### 2.11.12.1、问题：当前uboot不能启动内核

(1)用同样的方法（使用tftp 0x30008000 zImage-qt; 然后bootm 0x30008000），分别使用我们自己移植的uboot和使用九鼎移植版本的uboot去启动内核，发现九鼎移植版本的可以启动，但是我们自己移植的不可以启动。到此我们就断定我们的uboot有问题，不能启动内核。

(2)做基本检查：首先怀疑是机器码不对。经过和九鼎移植版本的uboot对比发现machid都是2456，说明机器码没错。

(3)想到一个问题，我们之前做实验时将串口改为了串口0，而内核zImage-qt的串口输出在串口2.怀疑可能的问题是uboot使用了串口0而内核使用了串口2所以在uboot后看不到内核的启动信息。

 

### 2.11.12.2、解决第一步：将串口改回串口2

(1)在smdkv210single.h中修改串口编号即可。

 

### 2.11.12.3、根据现象分析，定位问题并试图解决

(1)如果已经启动了内核，那没什么好说的了。应该是可以直接启动了。

(2)如何内核没有启动，是smdkv210single.h中没有定义bootm传参需要的那几个宏造成的。

\#define CONFIG_SETUP_MEMORY_TAGS

\#define CONFIG_CMDLINE_TAG

\#define CONFIG_INITRD_TAG

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

 

 

# 第十二章 uboot的移植2-从uboot官方标准uboot开始移植

## 2.12.0 章节概要

**2.12.1.选择合适的官方原版uboot**

​    本节课讲解uboot的版本差异，并且最终选择一个合适的官方uboot版本作为我们移植工作的起点。

**2.12.2.先初步浏览官方原版uboot**

​    本节对官方uboot进行大概浏览和结构分析、工程建立等，并将该uboot和我们之前分析过的移植好的uboot进行大概对比分析。

**2.12.3.mkconfig脚本分析**

​    本节分析2013.10版本的uboot的mkconfig，重点解析了8个传参与符号连接创建等，这些在后续分析代码时都会有一定帮助。

**2.12.4.先解决官方版本uboot的烧录运行**

​    本节首先移植sd_fusing文件夹，然后分析并修改代码使编译得到的u-boot.bin能够在SD卡中运行起来。

**2.12.5.start.S文件分析与移植1**

​    本节分析start.S文件流程，并且添加开发板置锁和串口输出字符的代码。

**2.12.6.start.S文件分析与移植2**

​    本节接上节来排除问题，讲解了如何使用LED点亮方式进行调试，并最终解决问题，成功输出字符"O"

**2.12.7.添加DDR初始化1**

​    本节开始添加DDR初始化代码，主要是分析了DDR初始化代码添加的位置、相关文件的移植等。

**2.12.8.添加DDR初始化2**

​    本节继续解决DDR初始化部分功能，添加调试信息打印以验证DDR初始化是否成功。

**2.12.9.添加uboot第二阶段重定位1**

​    本节首先分析uboot代码流程，找到应该添加uboot重定位功能的代码段，然后分析代码重定位的思路。

**2.12.10.添加uboot第二阶段重定位2**

​    本节接上节继续添加重定位代码，并且解决编译中的各种问题，成功实现重定位，并且看到了uboot启动第二阶段的信息。

**2.12.11.CPU时钟信息显示移植1**

​    本节分析uboot第二阶段的cpu信息输出，并且进行代码移植和更改，解决主频显示不正确的问题。

**2.12.12.CPU时钟信息显示移植2**

​    本节接上节继续解决主频显示不正确的问题。

**2.12.13.CPU时钟信息显示移植3**   

​    本节最终解决了主频显示不正确的问题，并且更正了以前一些不正确的认识，对210的iROM中时钟设置更加明确。

**2.12.14.board和DDR配置显示移植**

​    本节主要解决开发板名称、DDR配置值的初始化等修改，这些都是init_sequences中的东西。

**2.12.15.board_init_r移植**

​    本节开始移植board_init_r中的一些函数，主要内容是去掉原来的oneNand支持，加上SD/MMC的支持并将环境变量修改到SD/MMC中。

**2.12.16.uboot2013.10中SD/MMC驱动浏览**

​    本节进行SD/MMC驱动的浏览和错误问题定位分析，最终分析得到解决方案思路。

**2.12.17.SD卡驱动移植1**

​    本节开始移植SD卡驱动，主要进行驱动文件的逐个分析、文件关系的对应复制Makefile的修改等。

**2.12.18.SD卡驱动移植2**

​    本节继续进行SD卡驱动移植实验，将移植的驱动文件整理然后进行编译、修改等使之可以通过编译。

**2.12.19.SD卡驱动移植3**

​    本节继续进行SD卡驱动移植实验，主要在编译脚本cp.sh中添加代码使之选择性清理配置编译，这样可以提升效率。

**2.12.20.环境变量的移植**

​    本节分析环境变量分区的问题，通过代码分区确认了当前环境变量被放在何处，并且通过修改代码将环境变量放在合适的位置。

**2.12.21.环境变量的测试和配置移植**

​    本节对环境变量进行测试和效果确认，并且将uboot中默认的环境变量表重新设置以使该uboot更方便使用。

**2.12.22.网卡驱动的移植1**

​    本节开始移植网卡驱动，主要是分析网卡驱动初始化代码，然后进行网卡初始化的添加、代码实践、效果查看。

**2.12.23.网卡驱动的移植2**

​    本节接上节继续进行网卡驱动的移植。主要是分析网卡驱动不工作的原因并且进行解决方案分析、实践及效果确认。

​    

## 2.12.1.选择合适的官方原版uboot

### 2.12.1.1、官方原版uboot的版本

(1)版本号。刚开始是1.3.4，后来变成2009.08

(2)新版和旧版的差别。uboot的架构很早就定下来了，然后里面普遍公用的东西（common目录下、drivers目录下、fs目录下等···）在各个版本之间几乎是完全一样的。差别最大的是board和cpu目录，这两个目录正是单板（开发板）相关的。越新的uboot版本支持越多的开发板（CPU），所以越新的uboot越庞大。

(3)并不是越新的版本就越好。越新的uboot中会多出更多的开发板的支持代码，如果我们的开发板并不是很新，就没必要去用很新版本的uboot。因为多出来的代码自己也用不到而且还会成为累赘。

 

### 2.12.1.2、官方原版uboot的来源

(1)从uboot官方网站ftp下载：[ftp://ftp.denx.de/pub/u-boot/](ftp://ftp.denx.de/pub/u-boot/)

(2)从一些镜像网站下载

 

### 2.12.1.3、新版uboot配置体系的改变

(1)在最新的uboot版本（准确的说是2013.10到2014.10中的某个版本）中，uboot的文件体系发生了一个很大的变化。这个变化就是uboot引入了linux kernel的配置体系（Kbuild（K指的是kernel）、Kconfig、menuconfig），从而让我们可以在图形界面下，像配置内核一样配置uboot。

(2)所以新版本的uboot配置时和我们之前的课程讲的就不同了。我们移植时不能选择这种配置方式更改之后的uboot版本。我们要选择更改之前的。

(3)新版本的配置方式本质上和linux kernel一样的，所以在学完linux kernel移植后自己就能看懂，因此不用担心。

 

### 2.12.1.4、结论：选择合适的官方原版uboot进行移植

(1)结合以上，选择2013.10版本进行实验移植是比较合理的。

 

### 2.12.1.5、注意：实践工作中一般是从SoC厂商的uboot出发移植的

(1)在工作中一般是不需要从uboot官方版本出发去做移植的，而是从SoC厂商提供的开发板配套的uboot去做移植的。

 

 

## 2.12.2.先初步浏览官方原版uboot

### 2.12.2.1、文件夹结构浏览

(1)文件夹结构分析、主要文件检视

总的来说，文件夹结构和以前基本一样。不同的主要是lib，以前是lib_arm和lib_generic，现在是arch和lib。arch目录下放的是和cpu架构有关的东西。

总的来说，2013.10版本的uboot在结构上和1.3.4版本的uboot还是有所不同的。

(2)参照物开发板的选择

我们开发板使用的CPU是S5PV210，所以要找uboot中针对S5PV210或者S5PC110进行移植的作为参考。

根据规律，我们应该参考include/configs/s5p_goni.h，对应的board在uboot/board/samsung/goni这个目录。

(3)删除无关文件和文件夹

其实不删除也可以，但是删除更好。

 

### 2.12.2.2、建立SI工程并预解析

 

### 2.12.2.3、主Makefile浏览及boards.cfg文件

(1)2013.10版本的uboot的Makefile中使用了boards.cfg文件，因此在配置uboot时make xxx_config，这个xxx要到boards.cfg文件中查找。

(2)其实就相当于把以前的版本的uboot中各种开发板的配置部分规则抽离出来写到了Makefile中，然后把配置信息部分写到了一个独立文件boards.cfg。

 

### 2.12.2.4、mkconfig脚本浏览及符号连接的分析

(1)下节课详细分析，给出结论。

### 2.12.2.5、结论：

(1)参照物开发板为：55p_goni

(2)配置对应的cpu、board文件夹分别为：

cpu: u-boot-2013.10\arch\arm\cpu\armv7

board:  u-boot-2013.10\board\samsung\goni

 

 

## 2.12.3.mkconfig脚本分析

### 2.12.3.1、脚本功能浏览

(1)首先我们在命令行配置uboot时，是：make s5p_goni_config，对应Makefile中的一个目标。

(2)新版本的Makefile中：

%_config:: unconfig

@$(MKCONFIG) -A $(@:_config=)

%和terminal中的*差不多，万能匹配符；$(@:_config=) 中的$(@:表示整个%_config目标，而后面对的：_config=表示将_config替换为空

从这里分析得出结论，实际配置时是调用mkconfig脚本，然后传参2个：-A和s5p_goni

(3)到了mkconfig脚本中了。在24到35行中使用awk**正则表达式**（字符串匹配）将boards.cfg中与刚才$1（s5p_goni）能够匹配上的那一行截取出来赋值给变量line，然后将line的内容以空格为间隔依次分开，分别赋值给$1、$2···$8。

if [ \( $# -eq 2 \) -a \( "$1" = "-A" \) ] ; then

  \# Automatic mode

  line=`awk '($0 !~ /^#/ && $7 ~ /^'"$2"'$/) { print $1, $2, $3, $4, $5, $6, $7, $8 }' boards.cfg`

  if [ -z "$line" ] ; then

​    echo "make: *** No rule to make target \`$2_config'. Stop." >&2

​    exit 1

  fi

 

  set ${line}

  \# add default board name if needed

  [ $# = 3 ] && set ${line} ${1}

fi

**line=boards.cfg****里面的一行中的内容，他会去board.cfg中去搜索要找对的内容；**

**(4)****注意在解析完boards.cfg之后，$1到$8就有了新的值。**

$1 = Active

$2 = arm

$3 = armv7

$4 = s5pc1xx

$5 = samsung

$6 = goni

$7 = s5p_goni

$8 = - 

 

### 2.12.3.2、几个传参和其含义

(1)几个很重要的变量

arch=arm 

cpu=armv7

vendor=samsung

soc=s5pc1xx

 

### 2.12.3.3、符号链接

(1)include/asm -> arch/arm/include/asm

(2)include/asm/arch -> include/asm/arch-s5pc1xx

(3)include/asm/proc -> include/asm/proc-armv

 

最后创建了include/config.h文件。

 

### 2.12.3.4、Makefile中添加交叉编译工具链

(1)官方原版的uboot中CROSS_COMPLIE是没有定义的，需要自己去定义。如果没定义就直接去编译，就会用gcc编译。

(2)添加一行：

CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-

 

### 2.12.3.5、配置编译测试

(1)编译过程：

make distclean

make s5p_goni_config

make

(2)结果：得到u-boot.bin即可

 

 

## 2.12.4.先解决官方版本uboot的烧录运行

### 2.12.4.1、如何烧录uboot

(1)烧录u-boot.bin到SD卡中有2种方法：

1、windows下用烧录软件；

2、linux下用dd命令烧录脚本来烧录；

因为windows下的工具不开源，出了问题没法调试，所以不推荐。推荐linux下用烧录脚本来烧录（实质是dd命令进行sd卡扇区写入）

(2)移植原来的版本的uboot中的sd_fusing文件夹到官方uboot版本中，使用这个文件夹中的sd_fusing.sh脚本来进行烧录。

 

### 2.12.4.2、分析：为什么烧录运行不正确？

 

(1)串口接串口2，串口有输出。但是这个串口输出不是uboot输出的，而是内部iROM中的BL0运行时输出的。

   (2)输出错误信息分析：

第一个SD checksum Error：是第一顺序启动设备SD0（iNand）启动时校验和失败打印出来的；

第二个SD checksum Error：是第二顺序启动设备SD2（外部SD卡）启动时校验和失败打印出来的；

剩下的是串口启动和usb启动的东西，可以不管。

总结：从两个SD checksum Error，可以看出：外部SD卡校验和失败了。

分析：SD卡烧录出错了，导致SD卡校验和会失败。

 

### 2.12.4.3、解决方案分析

 

(1)为什么SD卡烧录会出错？可能原因：烧录方法错误、烧录原材料错误。

   (2)经过分析，sd_fusing这个文件夹下的mkbl1这个程序肯定没错，上一层目录下的u-boot.bin是存在的，校验和失败不失败和u-boot.bin无关。

(3)经过分析和查找，发现是mkbl1程序和start.S中前16个字节校验和的处理上面不匹配造成的，解决方法是在start.S最前面加上16个字节的占位。

 

### 2.12.4.4、代码实践

//在start.s添加16K的站位，不然校驗和和出錯；

  .word 0x2000

  .word 0x0

  .word 0x0

  .word 0x0

注意：这个start.s在./arch/arm/cpu/armv7/ 这个路径下

 (1)重新编译烧录运行，发现结果只显示一个SD checksum Error。这一个就是内部SD0通道的inand启动校验和失败打印出来的。剩下的没有了说明外部SD卡校验和成功了，只是SD卡上的uboot是错误的，没有串口输出内容，所以没有输出了。

 

 

## 2.12.5.start.S文件分析与移植1

### 2.12.5.1、start.S流程分析

(1) #define CONFIG_SYS_TEXT_BASE    0x34800000可以看出我们的uboot的连接地址是在0x34800000位置。

(2)save_boot_params是个空函数，里面直接返回的。

(3)cpu_init_cp15这个函数功能是设置MMU、cache等。这个版本的uboot中未使用虚拟地址，因此MMU在这里直接关掉。

(4)cpu_init_crit，这个函数里只有一句跳转指令，短跳转到lowlevel_init函数。

注意：uboot中有2个lowlevel_init.S文件（文件中还都有lowlevel_init函数），凭一般分析无法断定2个中哪个才是我们想要的。通过分析两个文件所在文件夹下面的Makefile可以判定board/samsung/goni目录下的才是真正包含进来的，arch/arm/cpu/armv7目录下的并没有被包含进来。

还可以通过实践验证的方法来辅助判断。通过查看之前已经编译过的uboot源码目录，看哪个被编程为.o文件了，就知道哪个是真正被使用的了。

(5)lowlevel_init函数在board/samsung/goni目录下，主要作用是时钟设置、串口设置、复位状态判断···这个函数是S5PC100和S5PC110两个CPU共用的。

(6)经过浏览，发现lowlevel_init函数中做的有意义的事情有：关看门狗、调用uart_asm_init来初始化串口、并没有做时钟初始化（下面有时钟初始化的函数，但是实际没调用。如果uboot中没有初始化时钟，那么时钟就是iROM中初始化的那种配置）

### 2.12.5.2、添加开发板制锁和串口打印字符"O"

(1)我们为了调试uboot的第一阶段，就要看到现象。为了看到现象，我们向lowlevel_init函数中添加2个代码，一个是开发板制锁，一个是串口打印"O"

(2)这两段代码可以直接从ARM裸机全集课程中的代码中来。其实也可以从三星移植版本的uboot中来，但是因为三星移植版本中用到了很多寄存器定义，涉及到头文件的，所以移植过来不方便。

(3)实践添加。

​    1、在board/Samsung/lowleve_init.S中 disable watch代码后面添加置锁

//開發板置鎖

  ldr r0, =0xE010E81C

  ldr r1, =0x301

  str r1, [r0]

 

### 2.12.5.3、实践结果及分析

(1)实验结果是：没看到开发板制锁，串口也没有输出任何东西。实验失败。

(2)结论：因为开发板制锁没有成功，所以我们判定，在开发板制锁代码运行之前uboot就已经挂掉了。下面就是去跟踪代码运行，然后判定问题点再去解决。

 

 

## 2.12.6.start.S文件分析与移植2

### 2.12.6.1、添加LED点亮代码跟踪程序运行

(1)在基础代码阶段，串口还没有运行，串口调试工具还无法使用时，使用LED点亮的方式来调试程序就是一个有力的手段。

(2)有些情况下可以用Jlink等调试工具来调试这种基础代码。

(3)从程序的基本运行路径端出发，隔一段给他添加一个LED点亮代码，然后运行时根据现象来观察，判定哪里执行了哪里没执行。从而去定位问题。

(4)从以前的裸机代码中组织出一个标准的LED点亮然后延时一段的一个标准代码段：

​     ldr r0, =0x11111111

  ldr r1, =0xE0200240

  str r0, [r1]

  ldr r0, =((1<<3) | (0<<4) | (0<<5)) // 1是灭，0是亮

  ldr r1, =0xE0200244

  str r0, [r1]

  

//延时代码

  ldr r2, =9000000

  ldr r3, =0x0

delay_loop: 

  sub r2, r2, #1 

  cmp r2, r3     

  bne delay_loop

 

 

(5)之前做实验时发现一个现象：我们的uboot运行时按住电源开关时所有4颗LED都是亮的。所以我们做实验时给LED点亮是看不到现象的，所以我们的代码关键是要熄灭某些LED来判断。

(6)我们将熄灭LED的函数在start.S中隔一段的关键部位放上1个，然后运行时通过观察LED的点亮熄灭状态，就知道程序运行到哪里了。

(7)经过判断我们发现：start.S中工作一切正常，但是函数一旦放到lowlevel_init.S中就完全不工作了。通过分析得出结论：b lowlevel_init这句代码出了问题。

 

### 2.12.6.2、修改u-boot.lds将lowlevel_init.S放到前部

​    //start.S

ENTRY(cpu_init_crit)

  /*

   \* Jump to board specific initialization...

   \* The Mask ROM will have already initialized

   \* basic memory. Go here to bump up clock rate and handle

   \* wake up conditions.

   */

  b  lowlevel_init    @ go setup pll,mux,memory

ENDPROC(cpu_init_crit)

 

(1)问题分析：跳转代码出了问题。分析问题出在代码的连接上。

(2)三星S5PV210要求BL1大小为8KB，因此uboot第一阶段代码必须在整个uboot镜像的前8KB内，否则跳转不到。

(3)对比三星移植版本的uboot的u-boot.lds和官方版本uboot的连接脚本u-boot.lds（注意这两个版本的uboot的连接脚本的位置是不同的），就发现lowlevel_init.S的代码段没有被放在前面。

(4)在u-boot.lds中start.o后面添加board/samsung/goni/lowlevel_init.o (.text*)，这个就保证了lowlevel_init函数被连接到前面8kb中去。

(5)报错，lowlevel_init重复定义了

### 2.12.6.3、修改board/samsung/goni/Makefile解决编译问题

(1)问题分析：为什么会重复定义。因为lowlevel_init这个函数被连接时连接了2次。一次是board/samsung/goni这个目录下生成libgoni.o时连接了1次，第2次是连接脚本最终在连接生成u-boot时又连接了一次，所以重复定义了。

(2)这个错误如何解决？思路是在libgoni.o中不要让他连接进lowlevel_init，让他只在最终连接u-boot时用1次，就可以避免重复定义。

(3)参考当前版本的uboot的start.S文件的处理技巧，解决了这个问题。

COBJS-y := goni.o onenand.o

\#SOBJS := lowlevel_init.o

LOW   := lowlevel_init.o

SRCS  := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)

OBJS  := $(addprefix $(obj),$(COBJS-y))

SOBJS  := $(addprefix $(obj),$(SOBJS))

 

\#新加的這句保證了即使不被包含進去也可以被編譯

all: $(obj).depend $(LOW) $(LIB)

 

 

### 2.12.6.4、实践验证。

结果是开发板制锁和串口输出'O'都成功了。

 

 

## 2.12.7.添加DDR初始化1

### 2.12.7.1、分析下一步移植路线

(1)cpu_init_crit函数成功初始化串口、时钟后，转入_main函数，函数在arch/arm/lib/crt0.S文件中。

(2)在crt0.S中首先设置栈，将sp指向DDR中的栈地址；然后调用board_init_f函数进行板级初始化。函数在arch/arm/lib/board.c中。

(3)在这个版本的uboot中，把以前uboot的第二阶段start_armboot函数分成了2部分：board_init_f和board_init_r。所以在这里就和以前版本的uboot接轨上了，推测board_init_f中肯定是做了板级初始化，board_init_r中进入了uboot的命令行。

(4)分析到这里，在uboot2013.10版本中思路已经很清晰了：uboot的第二阶段就在crt0.S文件中，第二阶段的入口就是_main函数。第一阶段工作主要就是cpu_init_crit函数，所以我们要在cpu_init_crit函数中添加DDR初始化和uboot的重定位。

(5)分析到这里，下一步工作方向就确定了。我们要先在cpu_init_crit函数中添加DDR初始化，然后在start.S中bl _main之前添加uboot的重定位，然后将bl _main改成ldr pc, __main(__main: .word _main)长跳转。然后在crt0.S中board_init_f后删除那些重定位代码，至此uboot的第二阶段就应该能启动起来了。后续的移植就是第二阶段了。

 

### 2.12.7.2、分析DDR初始化代码移植思路

(1)如果本来uboot中有DDR初始化代码，那我们可以就着这些代码来修改。但是问题是这个uboot2013.10中根本没有DDR初始化，所以我们需要完全从头去另外添加DDR初始化代码。

(2)我们的思路就是从三星版本的uboot中直接移植DDR初始化代码过来即可。三星版本的uboot中DDR初始化函数在cpu/s5pc11x/s5pc110/cpu_init.S文件中，直接将这个文件移植过来即可。

 

### 2.12.7.3、动手移植

(1)添加cpu_init.S文件到uboot2013.10中。注意，这里的代码必须保证在前8kb内，所以必须和lowlevel_init.S文件一样的链接处理。主要是在board/samsung/goni/Makefile中和arch/arm/cpu/u-boot.lds文件中做修改添加。

(2)添加头文件s5pc110.h到include目录下。

(3)对cpu_init.S文件代码进行修整，把一些无用的代码去掉，把一些相关的条件编译人工处理一下。

(4)在SourceInsigt工程中添加入这两个文件。然后重新解析一遍。然后对新添加的代码进行分析修整，把里面一些明显的宏定义缺失给补上。

 

 

## 2.12.8.添加DDR初始化2

### 2.12.8.1、移植必要的宏定义

(1)DDR配置参数，从三星版本的smdkv210single.h中复制到s5p_goni.h中。

(2)s5pc110.h中进行修整。

 

### 2.12.8.2、代码同步、编译、再修整

 

### 2.12.8.3、添加调试信息，验证DDR初始化完成。

(1)调试信息有LED点亮和串口输出两种。优先选用串口调试的方法。

(2)在DDR初始化完成后，添加串口输出字符"K"，这样启动时如果看到了"OK"就说明DDR已经被成功初始化了。

(3)结果：看到了"OK"标志，说明DDR添加实验成功。

 

 

## 2.12.9.添加uboot第二阶段重定位1

### 2.12.9.1、在重定位代码前加调试信息定位

(1)逻辑上来说，重定位部分代码应该在DDR初始化之后和uboot第二阶段来临前之间。

(2)uboot的第一阶段和第二阶段的划分并不是绝对的，唯一必须遵循的原则就是第一阶段不能大于8KB。所以uboot的第一阶段最少要完成DDR初始化和重定位，最多不能超过8KB。在满足这些条件时，第一阶段和第二阶段的接点可以随便挑。

(3)找到合适的地方来写重定位代码，重定位之后远跳转到第二阶段的入口。

//添加調試信息串口輸出字符“A”

  ldr r1, =0x41414141   @print "O"

  ldr r2, =0xE2900820

  str r1, [r2]

 

// bl _main

  ldr pc, __main

  __main:

​    .word _main

 

 

 (4)

### 2.12.9.2、重定位代码移植

 

### 2.12.9.3、清bss段移植

 

### 2.12.9.4、movi_bl2_copy函数移植

(1)从三星版本的uboot中赋值movi.c和movi.h到uboot2013.10中。

(2)改makefile和u-boot.lds。

 

 

## 2.12.10.添加uboot第二阶段重定位2

### 2.12.10.1、_mian函数中基本处理

(1)主要就是把里面的重定位代码部分给删除掉。剩下就是：设置栈、调用board_init_f函数和board_init_r函数。

 

### 2.12.10.2、代码同步及编译

(1)主要是crt0.S和movi.h。

 

### 2.12.10.3、编译中出现问题解决

(1)movi.h中宏定义出错，最后在s5p_goni.h中添加了 CONFIG_EVT1这个宏解决了

(2)连接错误：u-boot contains relocations other than   R_ARM_RELATIVE

在uboot下用grep "R_ARM_RELATIVE" -nR *搜索，发现Makefile中有一个检查重定位的规则，屏蔽掉这个规则后编译连接成功。

 

###    2.12.10.4、结果验证及下阶段展望

(1)看到了uboot启动打印出来的一系列信息，但是uboot没有进入命令行。

(2)这说明uboot中的DDR初始化和重定位功能都已经完美实现，后面就是第二阶段的继续移植了。

 

 

 

 

## 2.12.11.CPU时钟信息显示移植1

### 2.12.11.1、修改cpuinfo显示信息

   （1）将显示信息CPU:的信息修改为如图中所示。

​    （2）尝试去修改cpu头文件中的return 来解决400MHz不对的问题

//cpu.h

 \#define IS_SAMSUNG_TYPE(type, id)     \

static inline int cpu_is_##type(void)      \ 

{              \

  return s5p_cpu_id == id ? 1 : 0;    \

}

 

IS_SAMSUNG_TYPE(s5pc100, 0xc100)

 

//cpu_is_s5pc110这个函数在文件中是不能搜索到的，因为他用了##符号来连接函数

将  函数里的  return 直接改为 return 1

 

//Cpu_info.c

// printf("CPU:\t%s%X@%sMHz\n",

//     s5p_get_cpu_name(), s5p_cpu_id,

//     strmhz(buf, get_arm_clk()));

  printf("\nCPU: s5pv210@%ldMHz(%s)\n",strmhz(buf, get_arm_clk())),"OK");

  return 0;

}

### 2.12.11.4、代码实践

(1)arch/arm/include/asm/arch-s5pc1xx/cpu.h，和arch/arm/cpu/armv7/s5p-common/cpu_info.c文件同步一下。

（2）发现修改cpu.h中的代码牵一发而动全身，改了一个地方另一个地方就不对了，而且之后 比对发现cpu_is_s5pc110这个函数中返回本来就是1，所以因此不用改动，本来就是对的。

 

​    

## 2.12.12.CPU时钟信息显示移植2

### 2.12.12.1、问题分析

（2）怀疑这个函数中所包含的计算armclock的时钟频率不对，添加各种打印信息以及直接更改相应的获取的值。最后对比Samsung的uboot的代码发现s5pc110_get_pll_clk 这个函数中所包含的计算armclock的时钟频率计算没有问题，所以显示400MHz其实就是该uboot所给的时钟频率，至于为什么会这样主要是因为我们lowlevel_init函数中并没有添加时钟初始化的函数，所以这个400MHz应该是irom直接初始化给的时钟。

​    （2）定位到lowleve_init函数，在

/* for UART */

  bl uart_asm_init

  //DDR init

  bl mem_ctrl_asm_init

 这两句之**前**添加：bl system_clock_init 

 

  **在添加时钟初始化之后初始化串口的****ok****打印信息不起作用？？有待解决**

（3）在sytem_clock_init函数中将一下几个设置A PLL、MPLL、EPLL、VPLL,根据三星SOC用户手册更改为推荐值。

​    /* 

  /* S5PC110_APLL_CON 

  ldr r1, =0x80C80601     @ 800MHz

  str r1, [r0, #0x100]

  /* S5PC110_MPLL_CON 

  ldr r1, =0x829B0C01     @ 667MHz

  str r1, [r0, #0x108]

  /* S5PC110_EPLL_CON 

  ldr r1, =0x80600602     @ 96MHz VSEL 0 P 6 M 96 S 2

  str r1, [r0, #0x110]

  /* S5PC110_VPLL_CON 

  ldr r1, =0x806C0603     @ 54MHz

  str r1, [r0, #0x120]

 

/* S5PC110_APLL_CON Sheridan*/

  ldr r1, =0x807d0301     @ 100MHz

  str r1, [r0, #0x100]

  /* S5PC110_MPLL_CON */

  ldr r1, =0x829B0C01     @ 667MHz

  str r1, [r0, #0x108]

  /* S5PC110_EPLL_CON */

  ldr r1, =0x80300302     @ 48MHz VSEL 0 P 6 M 96 S 2

  str r1, [r0, #0x110]

  /* S5PC110_VPLL_CON */

  ldr r1, =0x806C0603     @ 108MHz

  str r1, [r0, #0x120]

  p = (r>>8) & 0x3f;

  s = r & 0x7;

 

 

 

（4）解决更改了时钟后urt串口在汇编阶段初始化失败的问题。将samsung官方板子中的urt初始化代码移植过来，将原来的代码注释掉完美解决。

​    注意：还未分析为什么更改时钟导致串口初始化失败，有待后面有时间解决。

uart_asm_init:

  /* set GPIO to enable UART0-UART4 */

  mov r0, r8

  ldr r1, =0x22222222

  str r1, [r0, #0x0]     @ S5PC100_GPIO_A0_OFFSET

  ldr r1, =0x00002222

  str r1, [r0, #0x20]     @ S5PC100_GPIO_A1_OFFSET

 

  ldr r0, =0xE2900800 @0xEC000000

  mov r1, #0x0

  str r1, [r0, #800]

  str r1, [r0, #0xc]

 

  mov r1, #0x3

  str r1, [r0, #0x0]

 

  ldr r1, =0x3c5

  str r1, [r0, #0x4]

 

  ldr r1, =34

  str r1, [r0, #0x28]

 

  ldr r1, =0xDDDD

  str r1, [r0, #0x2C]

/* 

  add r0, r8, #0x360     @ S5PC110_GPIO_MP0_5_OFFSET

  ldr r1, [r0, #0x0]     @ S5PC1XX_GPIO_CON_OFFSET

  bic r1, r1, #(0xf << 28)    @ 28 = 7 * 4-bit

  orr r1, r1, #(0x1 << 28)    @ Output

  str r1, [r0, #0x0]     @ S5PC1XX_GPIO_CON_OFFSET

 

  ldr r1, [r0, #0x8]     @ S5PC1XX_GPIO_PULL_OFFSET

  bic r1, r1, #(0x3 << 14)    @ 14 = 7 * 2-bit

  orr r1, r1, #(0x2 << 14)    @ Pull-up enabled

  str r1, [r0, #0x8]     @ S5PC1XX_GPIO_PULL_OFFSET

 

  ldr r1, [r0, #0x4]     @ S5PC1XX_GPIO_DAT_OFFSET

  orr r1, r1, #(1 << 7)    @ 7 = 7 * 1-bit

  str r1, [r0, #0x4]     @ S5PC1XX_GPIO_DAT_OFFSET

*/

 

  ldr r1, =0x4f4f4f4f   @print "O"

  ldr r2, =0xE2900820

  str r1, [r2]

  mov pc, lr

 

 

## 2.12.13.CPU时钟信息显示移植3

### 2.12.13.1、问题分析

(1)时钟显示ARMCLK是400MHz。

(2)调试，把m、p、s和apll_ratio打印出来后，发现这几个值的设置和之前的uboot的设置是不同的。原因在于我们当前版本的uboot中并未对SoC的时钟进行过设置，当前uboot中的时钟是iROM代码默认设置的。

(3)我自己之前一直认为iROM中把210的时钟设置为了1000MHz，然后三星版本的uboot中设置的时钟也是按照这个数据手册356页推荐的这个最佳性能配置时钟设置的。所以以前认为uboot中可以没有时钟设置也是一样的。

(4)但是实际上不是这样的，实际上内部iROM中设置的时钟APLL输出是800MHz，ARMCLK是400MHz。如果uboot中不做时钟的设置实际得到的就是这个时钟。所以我们之前代码得到的结果是400MHz。

(5)所以要解决这个时钟不对的问题，要在lowlevel_init.S中添加上时钟初始化的代码即可。

 

### 2.12.13.2、时钟初始化函数的添加

(1)在lowlevel_init.S中移植system_clock_init函数，并且在s5p_goni.h中添加相关的宏定义参数，然后在lowlevel_init函数中调用system_clock_init函数。

### 2.12.13.1、总结和感悟

 

 

## 2.12.14.board和DDR配置显示移植

### 2.12.14.1、board名称更改

### 2.12.14.2、DDR配置值修改

### 2.12.14.3、MACH_TYPE定义

### 2.12.14.4、DDR打印信息更改

### 2.12.14.5、代码实践

### 2.12.14.6、关于MACH_TYPE的定义问题。

(1)在uboot2013.10中和uboot1.3.4中设计有所不同。在uboot1.3.4中这个东西是分散定义在各个配置头文件当中的。但是在uboot2013.10中我们把MACH_TYPE集中定义在一个文件arch/arm/include/asm/mach-types.h中了。

(2)集中定义其实是uboot从linux内核中学来的。在linux kernel中MACH_TYPE就是在文件中集中定义的。集中定义的好处是方便查阅，不容易定义重复。

(3)这个MACH_TYPE是和开发板绑定的，原则上每一个开发板型号都有一个MACH_TYPE，这个机器码由linux内核管理者来分配的，如果需要应该向这些人申请。

 

 

## 2.12.15.board_init_r移植

### 2.12.15.1、去掉oneNand支持

​    （1）函数在board.c文件中的board_init_r中，在相关的头文件中屏蔽宏定义即可。

​      （2）   编译时出错/usr/local/x210_learning/gfuboot/uboot-2013.10/common/env_onenand.c:112: undefined reference to `onenand_mtd'

因为我们屏蔽了onenand的初始化，所以没有引用这个文件。

​    （3）解决方法：我们进入common的文件夹下看到Makfile发现只要把相关的宏定义在相关的头文件中去掉即可。

### 2.12.15.2、添加SD/MMC支持

​    （1）我们编译过程中出现和很多问题都和头文件的宏定义有关系。

​       //S5p_goni.h

//MMC---------------------------------------------//

\#define CONFIG_ENV_SIZE   0x4000     //16K

\#define CONFIG_ENV_IS_IN_MMC  1

\#define CONFIG_SYS_MMC_ENV_DEV  0   //0表示內部inand ，1表示sd卡

 

（2）定义：#define CONFIG_ENV_IS_IN_MMC  1 这句话是将common文件下的makefile的依赖的env_mmc添加进去，这样我们初始化就用地是env_mmc中的mmc/sd的初始化代码了。

 

（3）编译过程中发现CONFIG_SYS_MMC_ENV_DEV 这个没定义，这个宏文定义表示将环境变量保存在哪里, 0表示內部inand ，1表示sd卡。

 （4）出现这个错误：

 

​       这个原因是我们已经改用mmc了，onenand的初始化代码相关的宏已经被我们删掉了，所以会报错。

​       解决方法：将board/Samsung/goni/Makefile中的onenand.o去掉

include $(TOPDIR)/config.mk

 

LIB = $(obj)lib$(BOARD).o

 

COBJS-y := goni.o **onenand.o**

\#SOBJS := lowlevel_init.o

LOW := lowlevel_init.o cpu_init.o movi.o

SRCS  := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)

OBJS  := $(addprefix $(obj),$(COBJS-y))

SOBJS  := $(addprefix $(obj),$(SOBJS))

 

 

 

## 2.12.16.uboot2013.10中SD/MMC驱动浏览

### 2.12.16.1、从初始化代码开始浏览

(1)

### 2.12.16.2、相关函数和文件

(1)

drivers/mmc/mmc.c、

drivers/mmc/sdhci.c

board/samsung/goni/goni.c

arch/arm/include/asm/arch-s5pc1xx/mmc.h

 

### 2.12.16.3、当前错误定位及解决方案分析

(1)错误发生路径定位

board_init_r

  mmc_initialize

​      do_preinit

​         mmc_start_init

​             mmc_go_idle

​                mmc_send_cmd

​                    sdhci_send_command

​                       sdhci_transfer_data   错误在这个函数中

(2)错误原因分析

sdhic.c中的所有函数构成了三星210CPU的SD/MMC控制器的驱动。这里面的函数是三星公司的工程师写的，内容就是用来控制210CPU的内部的SD/MMC控制器和外部的SD卡通信的。这就是所谓的驱动。

sdhci_transfer_data函数出错，说明是SoC的SD/MMC控制器和外部SD卡（其实现在用的是SD0的iNand）的数据传输出了问题。（细节分析发现是控制器内部有一个中断状态错误标志被置位了。）

(3)解决方案分析：

两条思路：

第一是去逐行的分析SD卡驱动实现（分析中要对SD卡通信协议和210这个SoC的SD控制器非常熟悉），然后发现错误所在，然后修改代码解决问题；

第二个是投机取巧的方法，就是把原来三星移植版本的uboot中的SD/MMC驱动整个移植过来替换掉uboot2013.10中的MMC驱动。

其实还有第三条折中思路，就是综合第一种和第二种，譬如参考三星移植版本的uboot中的驱动实现来修补uboot2013.10中的驱动实现。

 

## 2.12.17.SD卡驱动移植1

### 2.12.17.1、分析两个版本的uboot中SD卡驱动差异

(1)uboot2013.10中：驱动相关的文件主要有：

drivers/mmc/mmc.c

drivers/mmc/sdhci.c

drivers/mmc/s5p_sdhci.c

board/samsung/goni/goni.c

(2)三星移植版本中，驱动相关的文件主要有：

drivers/mmc/mmc.c

drivers/mmc/s3c_hsmmc.c

cpu/s5pc11x/cpu.c

cpu/s5pc11x/setup_hsmmc.c

(3)经过分析发现：SD卡驱动要工作要包含2部分内容，一部分是drivers/mmc目录下的是驱动，另外一部分是uboot自己提供的初始化代码（譬如GPIO初始化、时钟初始化）

### 2.12.17.2、复制必要的文件并修改相应Makefile

(1)首先解决drivers/mmc目录下的文件替换。将三星板子的两个文件放在2013版本的drivers/mmc/目录下，然后在这个目录下的Makefile下把相应替换的文件去掉，加上新放上来的***.o。

(2)修改初始化代码。

### 2.12.17.3、代码浏览及修补

(1)按照代码运行时的流程来逐步浏览代码，看哪里需要修补。

 

 

## 2.12.18.SD卡驱动移植2

### 2.12.18.1、继续修补驱动代码

(1)include/mmc.h

(2)include/s3c_hsmmc.h

### 2.12.18.2、同步及编译、问题解决

(1)出错1：cmd_mmc.c中出错。原因是cmd_mmc.c和mmc驱动密切相关，所以改了驱动后这个实现文件也要跟着改，解决方法是从三星版本的直接同名文件复制过来替换

(2)出错2：drivers/mmc/mmc_write.c编译出错。原因是这个文件和本来版本中的mmc.c文件相关，但是mmc.c被替换  掉了所以这个文件编译报错。解决方案就是修改makefile去掉这个文件的依赖，让他不被编译。

(3)出错3：#include<regs.h>注释掉，然后添加#include <s5pc110.h>

 

 

## 2.12.19.SD卡驱动移植3

### 2.12.19.1、解决每次编译时间都很长的问题

(1)每次编译脚本cp.sh执行时都会先cp同步代码，然后make distclean···所以每次都会清空后从头编译，这就很费时间了。

(2)但是实际上有时候是不会make distclean的，只需要先cp然后直接make即可（当更改没有涉及到配置头文件s5p_goni.h，没有涉及到makefile文件，或者其他项目配置文件，也就是说我们的更改只是普通代码文件的更改时）。

 

### 2.12.19.2、效果测试

(1)读写测试均成功

 

 

## 2.12.20.环境变量的移植

### 2.12.20.1、iNand分区表检查-env究竟应该放在哪

(1)测试环境变量是否可以保存，通过开机set设置环境变量然后save，然后关机后重启来测试环境变量的保存是否成功。

(2)我们的环境变量究竟保存到哪里去了？这个就要去分析代码中的分区表。

(3)环境变量应该被放在哪里？虽然无法确定ENV一定要放在哪里，但是有一些地方肯定是不能放的，否则将来会出问题。原则是同一个SD卡扇区只能放一种东西，不能叠加，否则就会被覆盖掉。uboot烧录时使用的扇区数是：SD2的扇区1-16和49-x（x-49大于等于uboot的大小）

(3)从uboot的烧录情况来看，SD2的扇区0空闲，扇区1-16被uboot的BL1占用，扇区17-48空闲，扇区49-x被uboot的BL2占用。再往后就是内核、rootfs等镜像的分区了。系统移植工程师可以根据kernel镜像大小、rootfs大小等来自由给SD分区。

(4)从uboot的分区情况来看，ENV不能往扇区1-16或者49-x（整个uboot大小）中来放置，其他地方都可以商量。ENV的大小是16K字节也就是32个扇区。

 

### 2.12.20.2、环境变量相关代码浏览

(1)目前情况是uboot在SD2中，而ENV在SD0中，所以现在ENV不管放在哪个扇区都能工作，不会有问题。但是我们还是得找到ENV分区所在并且改到不会和uboot冲突，因为将来部署系统时我们会将uboot和kernel、rootfs等都烧录到iNnand中去，那时候也要确保不会冲突。

我们现在save的ENV变量保存到SD0通道（iNand）中了，并且把BL1个覆盖的。

**注意：覆盖的是inand中的uboot，SD卡中的uboot并没有被覆盖，所以我们save之后SD卡中的uboot并没有被覆盖。**

(2)、static inline int write_env(struct mmc *mmc, unsigned long size,

unsigned long offset, const void *buffer)

类似于这种函数，在代码分析中，关键是弄明白各种参数的意义：

**mmc**表示要写的mmc设备；
 **size**表示要写的大小；

**offset**表示要写到SD卡的哪个扇区去；

**buffer**是要写的内容；

(3)**CONFIG_ENV_OFFSET**这个宏决定了我们的ENV在SD卡中相对SD卡扇区0的偏移量，也就是ENV写到SD卡的哪里去了。经过分析发现这个宏的值为0.所以我们的ENV

被写到了0扇区开始的32个扇区中。

(4)写到这里肯定不行，因为和uboot的BL1冲突了。解决方案是改变这个CONFIG_ENV_OFFSET的值，将ENV写到别的空闲扇区去。

(5)#define MOVI_BL2_POS    ((eFUSE_SIZE / MOVI_BLKSIZE) + MOVI_BL1_BLKCNT + MOVI_ENV_BLKCNT)

​       后面这三个其实分别是1+16+32=49

其中的1就是扇区0（空闲的），16是就是扇区1-16（uboot的BL1），32就是扇区17-48（存放ENV的），49自然就是uboot的BL2开始扇区了。这种安排是三星移植的uboot版本中推荐的SD卡的分区方式，不一定是唯一的。

(6)我们参考这个设计，即可实现环境变量不冲突。所以只要将ENV放到17扇区起始的地方即可。

 

 

## 2.12.21.环境变量的测试和配置移植

### 2.12.21.1、如何测试环境变量的保存是否正确

(1)程序修改重新编译后启动，启动后要注意iNand中本来有没有环境变量。为了保险起见对iNand的前49个扇区进行擦除，然后就可以确保里面没有之前保存过的环境变量了。使用命令：mmc write 0 30000000 0# 49来擦除SD0的扇区0-48，保证以前的环境变量都没有了。

(2)重新开机后先set随便改一个环境变量作为标记然后saveenv然后重启。

(3)测试方法是，使用：mmc read 0 30000000 17# 32命令将iNand的17开始的32个扇区读出来到内存30000000处，然后md查看。找到显示区域里面的各个环境变量，看读出来的和自己刚才修改的值是否一样。

 

### 2.12.21.2、常用环境变量的配置移植

(1)常用的环境变量就是网络相关的那几个，和CONFIG_BOOTCOMMAND、CONFIG_BOOTARGS等。

 

 

## 2.12.22.网卡驱动的移植1

### 2.12.22.1、添加网络支持

(1)uboot中对各种功能也是一个条件编译可以配置可以裁剪的设计（从linux内核学来的），默认情况下我们的uboot没有选择支持网络。

(2)在配置头文件中添加一行 #define CONFIG_CMD_NET

(3)添加了网络支持宏之后，在uboot初始化时就会执行eth_initialize函数，从而网络相关代码初始化就会被执行，将来网络就有可能能用。

 

### 2.12.22.2、添加ping和tftp命令

(1)在linux系统中网络底层驱动被上层应用调用的接口是socket，是一个典型的分层结构，底层和上层是完全被socket接口隔离的。

(2)但是在uboot中网络底层驱动和上层应用是黏在一起的，不分层。意思就是上层网络的每一个应用都是自己去调用底层驱动中的操作硬件的代码来实现的。

(3)uboot中有很多预先设计的需要用到网络的命令，和我们直接相关的就是ping和tftp这两个命令。这两个命令在uboot中也是需要用相应的宏开关来打开或者关闭的。

(4)经过代码检查，发现ping命令开关宏为CONFIG_CMD_PING，而tftp命令的开关为CONFIG_CMD_NET，确认添加。

### 2.12.22.3、代码实践

结果是ping和tftp命令都被识别了，但是都提示no ethernet found`````网络不通。为什么不通？因为还没做初始化等移植

 

### 2.12.22.4、移植网卡初始化代码

 

（1）开启network 后发现net初始化失败，

 

## 2.12.23.网卡驱动的移植2

### 2.12.23.1、实验现象分析

(1)因为我们没有自定义的网卡初始化函数（board_eth_init或者cpu_eth_init），所以uboot启动时初始化网卡时打印：Net:  Net Initialization Skipped

  

(2)eth.c中有2个很重要的全局变量：eth_devices（用来指向一个链表，这个链表中保存了当前系统中所有的网卡信息）和eth_current（eth_current指针指向当前我们正在操作的那个网卡）。

(3)在linux的网卡驱动体系中，有一个数据结构（struct eth_device）用来表示（封装）一个网卡的所有信息，系统中注册一个网卡时就是要建立一个这个结构体的实例，然后填充这个实例中的各个元素，最后将这个结构体实例加入到eth_devices这个链表上，就完成了注册。了解了这些之后，你就明白了网卡驱动在初始化时必须负责将自己注册到系统的网卡驱动体系中（其实就是把自己的eth_device结构体实例添加到eth_devices链表中）。如果你不做这个过程就会出现：网卡找不到的错误。

(4)分析当前的问题是：在uboot-2013.10/arch/arm/lib/board.c eth_initialize(gd->bd); 函数所在的305行判断eth_devices是否为NULL之前没有去做网卡驱动的注册，所以这里为NULL，所以打印出了“No ethernet found.”

/*

   \* If board-specific initialization exists, call it.

   \* If not, call a CPU-specific one

   */

  if (board_eth_init != __def_eth_init) {

​    if (board_eth_init(bis) < 0)

​      printf("Board Net Initialization Failed\n");

  } else if (cpu_eth_init != __def_eth_init) {

​    if (cpu_eth_init(bis) < 0)

​      printf("CPU Net Initialization Failed\n");

  } else

​    printf("Net Initialization Skipped\n");

 

   if (!eth_devices) {    //eth_devices赋值，等于NULL，也就是网卡没注册  

​    puts("No ethernet found.\n");

​    bootstage_error(BOOTSTAGE_ID_NET_ETH_START);

  

 

 

### 2.12.23.2、No ethernet found 修复

(1)想解决这个问题，就是要在305行之前去注册网卡驱动。注册网卡驱动的代码不能随便乱写，一定要遵守linux网卡驱动架构的要求。这一块的代码一般属于网卡驱动的一部分，像这里就在dm9000x.c中。

(2)dm9000x.c中的最后一个函数int dm9000_initialize(bd_t *bis)，这个函数就是用来注册dm9000网卡驱动的。

​    （3）在uboot-2013.10/arch/arm/lib/board.c/board_init_r函数中的board_init()函数中添加//initalize network card

  \#ifdef CONFIG_DRIVER_DM9000

​    dm9000_pre_init();    //注册网卡，隔日eth——devices赋值

  \#endif

——————————————————————

​          int board_init(void)

{

  /* Set Initial global variables */

  s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;

 

  //initalize network card

  \#ifdef CONFIG_DRIVER_DM9000

​    dm9000_pre_init();

  \#endif

 

  gd->bd->bi_arch_number = MACH_TYPE_SMDKV210 ;

  gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;

 

  return 0;

}

 

### 2.12.24.3、Net Initialization Skipped修复

(1)根据之前分析uboot函数，发现前面有2个函数预留的可以用来放网卡初始化函数的，经过对比感觉board_eth_init函数稍微合适点，于是乎去添加。

在\uboot-2013.10\net\eth.c文件件添加这个int board_eth_init(bd_t *bis)函数，屏蔽原来的__attribute__(… 这个函数

 

int board_eth_init(bd_t *bis){

 

  return dm9000_initialize(bis);  //正式添加网卡初始化函数

}

int cpu_eth_init(bd_t *bis) __attribute__((weak, alias("__def_eth_init")));

//int board_eth_init(bd_t *bis) __attribute__((weak, alias("__def_eth_init")));

 

### 2.12.24.4、解决ERROR: resetting DM9000 -> not responding  

 

  

ERROR: resetting DM9000 -> not responding                    
 dm9000 not found at 0x88000000 id: 0x00000000  

 从错误信息来分析。id号打印出来是错误的。
 先定位错误文件：
 root@xjg:/home/xjg/u-boot-2012.10# grep -r "ERROR: resetting DM9000"
 drivers/net/dm9000x.c: printf("ERROR: resetting DM9000 -> not responding\n");

 发现一開始reset函数就错误发生。说明是前面的步骤有问题。
 我检查了下你的lowlevel_init.S文件，发现时钟初始化有问题。
 终于定位是在以下这句  凝视了就能够。


 210   /* CLK_IP1 */
 211 /*  ldr r1, =0xe9fdf0f9     @ FIMD[0] USBOTG[16]
 212             @ NANDXL[24]
 213   str r1, [r0, #0x464]     @ S5PC110_CLK_IP1
 214 */

 以下看看这一步为什么不正确？
 S5PV210 can disable the clock operation of each IP if it is not required。
 //看这样子像是屏蔽时钟的寄存器
 改动成以下这个样子就能够了。说明这个寄存器的第26位（SROM时钟）是不能屏蔽的。
 210   /* CLK_IP1 */
 211   ldr r1, =0xeDfdf0f9     @ FIMD[0] USBOTG[16]
 212             @ NANDXL[24]
 213   str r1, [r0, #0x464]     @ S5PC110_CLK_IP1

214 

为什么和SROM时钟相关呢？从原理图上能够知道dm9000是使用的自己的时钟源，dm9000芯片外接了一个25MHz的晶振。


 感谢物联网大讲堂朱老师的指导：
 210用srom接口来和网卡通信。还记得dm9000是怎么接到210上面的吗？csn1片选信号。


 就是说dm9000是接在210的SROM  bank1上面的。这就能够解释为什么SROM时钟不能关闭了。。。。

转载于:https://www.cnblogs.com/wzjhoutai/p/6875694.html

2.12.23.uboot启动内核的移植

 

 

 

 

 

 

 

 

 

 



 

# 第十三章 uboot杂记-logo显示和fastboot原理等

## 2.13.0 章节概要

**2.13.1.X210的uboot中LCD操作分析**

​    本节分析在X210的uboot中LCD是如何被操作的，包括分析核心板、底板和LCD模组的原理图、uboot中的相关代码等。

**2.13.2.logo显示和LCD屏幕分辨率适配**

​    本节首先讲解如何修改代码让uboot在新版X210BV3S中正常显示logo，然后顺带分析下logo显示部分的代码。

**2.13.3.fastboot的基本分析**

​    本节简要描述了fastboot的功能和工作原理，目的是让大家对fastboot有一个宏观和直觉上的认识。

**2.13.4.uboot的fastboot代码分析1**

​    本节开始分析fastboot的实现代码，从do_fastboot函数入手一路顺藤摸瓜分析到rx_handler函数。

**2.13.5.uboot的fastboot代码分析2**

​    本节继续分析fastboot的实现代码，主要是fastboot从机和主机之间通过的各种命令集及其实现，通过分析让大家从本质上理解fastboot是如何工作的。

## 2.13.1.X210的uboot中LCD操作分析

### 2.13.1.1、新旧版本开发板的LCD模组差异

(1)2015.11月初之前购买的X210开发板都属于老版本，型号是X210V3；之后购买的开发板都是新版本的，型号是X210V3S。

(2)两个开发板主要电路是完全一样的，不同主要有3点：一个是把拨码开关换成了短路帽；另一个是LCD分辨率从800*480升级成1024*600；第三个是触摸屏芯片型号换了。

 

### 2.13.1.2、背光电路分析

(1)LCD的背光源有2种设计。一种是简单设计，背光只能点亮和熄灭两种状态，不能调亮度；另一种设计类似手机屏幕可以调节亮度。第一种设计很简单，就是开和关。第二种模式比较复杂，需要一个额外的PWM调光IC来支持，X210的LCD模组上使用MP3202芯片来做调光。

(2)分析原理图和MP3202的数据手册，可以得出结论：

 

第一：PWMTOUT0（GPD0_0）接在了IC的FB引脚上，SoC应该通过该引脚输出一个频率合适的PWM波形给调光IC，这个波形的占空比就会控制MP3202输出的电流大小，从而控制屏幕亮度。

第二：L_DISP（DISP、SYS_OE、GPF3_5）接在了MP3202的EN引脚上，SoC应该给该引脚一个高电平来让背光工作，或者给一个低电平来让背光不工作。

(3)综合分析：背光要点亮，要同时满足以上两个条件。GPD0_0要输出低电平或者PWM信号，同时GPF3_5要输出一个高电平。一般来说我们在uboot中都把GPD0_0设置成输出模式然后输出低电平来点亮背光。

 

### 2.13.1.3、X210的uboot中LCD代码分析

(1)在uboot-jiuding/board.c中init_sequence中的display_banner中的open_backlight函数中给GPF3_5输出高电平。但是这个其实是可以省略的，注释掉这一句uboot的LCD显示照样正常的，主要原因是后面LCD操作的部分还会再做一遍的。

static void open_backlight(void)

{

  unsigned int reg;

 

  //open backlight. GPF3_5=1

  reg = readl(GPF3CON);

  reg = reg & ~(0xf<<20) | (0x1<<20);

  writel(reg,GPF3CON);

 

  reg = readl(GPF3PUD);

  reg = reg & ~(0x3<<10) | (0x2<<10);

  writel(reg,GPF3PUD);

 

  reg = readl(GPF3DAT);

  reg |= (0x1<<5);

  writel(reg,GPF3DAT);

}

 

(2)真正的初始化LCD系统并且显示logo是在start_armboot函数的后段的x210_preboot_init中。这个函数纯粹是九鼎在移植时添加的。如果我们自己移植uboot可以考虑自己去添加。

 

 

## 2.13.2.logo显示和LCD屏幕分辨率适配

### 2.13.2.1、LCD驱动mpadfb.c分析

(1)fb_init函数给framebuffer相关的数据结构赋值。左值的info是一个结构体，这个结构体描述fb驱动中的硬件设备参数的，右值的lcd是自己定义的一个数据结构，里面的值都是我们人为配置给驱动体系的。

(2)lcd_port_init看名字是lcd端口的初始化，端口就是GPIO，所以这个函数是在初始化LCD相关的SoC的引脚。

(3)lcd_reg_init看名字是LCD的寄存器的初始化，就是SoC的LCD控制器中的那些寄存器的初始化。

(4)以上三个函数调用执行完后，LCD初始化就结束了。然后向LCD写东西就能显示了。但是你要注意背光是否被点亮了。后面剩下的事情就是写东西和开背光两个了。

(5)display_logo(&s5pv210_fb);这个函数负责把logo图片写到LCD的fb中去。backlight_brigness_init(1);负责开背光。

 

### 2.13.2.2、解决新版开发板X210BV3S的logo显示问题

(1)用旧版本的uboot.bin下载到新版开发板中，发现能工作，但是屏幕logo显示不正常（屏幕下面有一条显示不正常的，然后logo是显示出来的但是不在屏幕正中间）。

(2)原因分析：主要原因新版开发板LCD屏幕的分辨率是1024*600而旧版分辨率是800*480.所以旧版本的uboot在新版开发板上运行时，就会造成屏幕填充不满（现象就是下面有一排显示不正常的），还会造成显示内容位置偏移，本来在中间结果偏左了。

(3)解决方案：很简单，在uboot中将LCD的参数部分，分辨率改成1024*600即可。

 

### 2.13.2.3、logo显示代码分析

(1)logo是以工具将图片做成二进制的字符串数据。

(2)显示时通过计算将logo代表的矩形放在屏幕正中央

(3)绘图时先绘制背景色，然后在logo矩形中写入logo图片内容即可。

 

 

## 2.13.3.fastboot的基本分析

### 2.13.3.1、什么是fastboot

(1)fastboot是android使用的一种刷机方法.android系统设计了2种刷机方式：fastboot和recovery。

(2)fastboot使用usb作为物理传输。刷机其实就是镜像传输+烧录，fastboot刷机时就是通过usb线来传输镜像的。

(3)fastboot是uboot中的一个命令。uboot进入命令行中后，如果需要刷机，则可以在命令行执行fastboot命令就可以让uboot进入fastboot模式，刷机就是在fastboot模式下进行的。

(4)fastboot需要主机端的fastboot软件配合。要实现fastboot刷机，只有开发板端uboot是不行的，还需要在主机上有fastboot.exe的软件配合。

(5)fastboot在开发板和主机间定义了一套协议。其实fastboot是我们在开发板和主机之间定义的一套协议，这套协议以usb为底层传输物理层，协议规定了主机fastboot软件和开发板fastboot软件之间的信息传输规则。消息传递可以实现功能有：主机可以向开发板发送命令、开发板可以向主机发送回复、主机可以向开发板发送文件（download）

​    

 

 

### 2.13.3.2、fastboot的工作原理

(1)uboot的fastboot命令将开发板伪装成一个usb从设备。开发板本身并不是一个usb设备，所以开发板直接插到电脑上电脑是没有反应，没有提示发现设备需要装驱动的。伪装之后开发板就被主机windows识别成一个安卓手机了。

(2)主机的fastboot软件和开发板的fastboot程序通信来工作。平时工作时，开发板端只要执行了fastboot命令进入fastboot模式即可，剩下的就不用管了。主机端通过运行fastboot命令，传递不同的参数来实现主机端和开发板端的通信。

譬如主机端执行fastboot devices，则这个命令通过USB线被传递到开发板中被开发板的fastboot程序接收，接收后去处理然后向主机端发送反馈信息，主机端接收到反馈信息后显示出来。

(3)我们学习fastboot时分析代码的思路就是：

主机端：fastboot.exe的源代码没有，fastboot协议虽然能找到但是很枯燥，所以主机端没有去分析的。

开发板端：主要分析点就是uboot如何进入fastboot模式，fastboot模式下如何响应主机发送的各种命令。

 

 

## 2.13.4.uboot的fastboot代码分析1

### 2.13.4.1、do_fastboot函数

(1)do_fastboot函数本身涉及到很多操作SD/Nand等磁盘的，主要目的是为了刷机。要完整的分析fastboot的函数细节很复杂很麻烦，我们并不是要做这个。

 

### 2.13.4.2、关键点：rx_handler（顺藤摸瓜一路找下去）

do_fastboot

​    fastboot_poll

​       fboot_usb_int_hndlr

​           fboot_usb_pkt_receive

​              fboot_usb_int_bulkout

​                  fastboot_interface->rx_handler（函数指针）

​                     指向cmd_fastboot.c/rx_handler

找的过程涉及到USB物理层通信的一些概念和理解，相对比较复杂。最终uboot这边的fastboot是通过rx_handler函数来处理主机端fastboot软件发送过来的信息的。fastboot协议的命令实现都在这个函数中提现。所以这个函数的分析就是重点。

​                     

### 2.13.4.3、代码分析

(1)大文件download机制

rx_handler函数中通过if和else分成了两部分，if部分负责处理download，else部分负责处理命令。usb传输单次传输最大只能有限个字节（64、256），因此当我们发送比较小的东西（譬如命令）时可以单次传输完毕；当我们发送比较大的东西（譬如文件）时就必须要分包发送。

 

(2)down后的响应机制。开发板端通过fastboot_tx_status函数   向主机发送响应，主机显示这个响应。

 

 

## 2.13.5.uboot的fastboot代码分析2

(1)uboot中fastboot有关的一些宏定义设置值

CFG_FASTBOOT_TRANSFER_BUFFER 配置fastboot工作时的缓冲区地址，fastboot在执行某些功能时需要大块内存做缓冲区（譬如download时），这里就是在给他配置缓冲区。

CFG_FASTBOOT_TRANSFER_BUFFER_SIZE fastboot缓冲区的大小。

注意：很多同学在之前刷机时，烧录uboot和zImage都正常，但是烧录android镜像x210.img时错误，提示：image too large...（意思是文件太大）。这个错误的原因就是x210.img太大了，超出了CFG_FASTBOOT_TRANSFER_BUFFER_SIZE所以放不下了，所以uboot的fastboot这里报错了。

 

### 2.13.5.1、fastboot命令响应之：fastboot reboot

/* reboot 

​      Reboot the board. */

​    if (memcmp(cmdbuf, "reboot", 6) == 0)

​    {

​      if (!strcmp(cmdbuf + 6, "-bootloader"))

​      {

​        strcpy((char *)interface.transfer_buffer, (char *)FASTBOOT_REBOOT_MAGIC);

​      }

​      else

​      {

​        memset(interface.transfer_buffer, 0x0, FASTBOOT_REBOOT_MAGIC_SIZE);

​      }

sprintf(response,"OKAY");

​      fastboot_tx_status(response, strlen(response), FASTBOOT_TX_SYNC);

​      //udelay (1000000); /* 1 sec */

 

​      do_reset (NULL, 0, 0, NULL);

​      

​      /* This code is unreachable,

​        leave it to make the compiler happy */

​      return 0;

​    }

 

 

(1)作用：在PC机这边可以远程重启开发板

### 2.13.5.2、fastboot命令响应之：fastboot getvar

(1)作用是得到一些fastboot中定义的变量名的值，譬如version、product。。。。。

​    命令使用：fastboot getvar version

### 2.13.5.3、fastboot命令响应之：fastboot erase

### 2.13.5.4、fastboot命令响应之：fastboot download

### 2.13.5.5、fastboot命令响应之：fastboot boot

### 2.13.5.6、fastboot命令响应之：fastboot flash

### 2.13.5.7、fastboot命令响应之：fastboot oem

(1)oem命令是用户自定义的。其他命令全都是fastboot协议定义的，但是有时候自带的命令不足以使用，oem厂商可能希望定义一些自己专有的命令，则可以使用oem命令。

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

 

# 第十四章 话说linux内核

## 2.14.0 章节概要

**2.14.1.内核和发行版的区别**

​    本节主要讲解linux内核和linux发行版的区别，并非不痛不痒的讲解，而是从几个方面的细节进行讲述。

**2.14.2.内核和驱动的关联**

​    本节首先讲述操作系统学习的框架性思维，然后讲述了内核和驱动这两个概念的区别和关联。

**2.14.3.内核和应用程序、根文件系统的关联**

​    本节讲述内核和应用程序的关联，内核和根文件系统的关联。

**2.14.4.linux内核的模块化设计**

​    本节重点讲述linux内核的模块化设计理念及其优势，试图使大家对内核可配置有更深刻的认识。

**2.14.5.选择合适版本的内核**

​    本节讲解linux内核的版本变迁，并且对各主要版本做介绍，最终讲了我们如何选择最适合自己的内核版本进行工作。

​    

## 2.14.1.内核和发行版的区别

### 2.14.1.1、到底什么是操作系统

(1)linux、windows、android、ucos就是操作系统

(2)操作系统本质上是一个程序，由很多个源文件构成，需要编译连接成操作系统程序（vmlinz、zImage）。

(3)操作系统的主要作用就是管理计算机硬件，给应用程序提供一个运行环境。

 

### 2.14.1.2、操作系统核心功能：

(1)**内存管理**：如果没有操作系统，内存是需要程序自己来管理的。譬如在uboot中要使用内存的哪里是自己随便用的，没有注册也没有限制。这时候如果程序自己不小心把同一块内存重复用了就会出现程序逻辑错误。系统大了之后（内存多了）内存管理非常麻烦；有了操作系统之后，操作系统负责管控所有的内存，所有的应用程序需要使用内存时都要向操作系统去申请和注册，由操作系统的内存管理模块来分配内存给你使用，这样好处是可以保证内存使用不会冲突。

(2)**进程调度**：操作系统下支持多个应用程序同时运行（所以可以一边聊QQ一边看电影···），这是宏观上的并行。实际上在单核心CPU上微观上是不能并行的，宏观上的并行就是操作系统提供的分时复用机制。操作系统的进程调度模块负责在各个进程之间进行切换。

(3)**硬件设备管理**：没有操作系统时要控制任何硬件都要自己写代码，有了操作系统后操作系统本身会去控制各个硬件，应用程序就不用考虑硬件的具体细节了。操作系统的硬件设备管理模块就是驱动模块。

(4)**文件系统**：文件系统是管理存储设备的一种方式。存储设备是由很多个扇区组成的，每个扇区有512/1024/2048/4096字节，存储设备要以扇区为单位进行读写。如果没有文件系统，程序要自己去读写扇区，就得记得哪个文件在哪个扇区。有了文件系统之后我们人不用再关注扇区，人只用关注文件系统中的目录和文件名，而不用管这个文件在物理磁盘的哪个扇区。

 

### 2.14.1.3、操作系统扩展功能：

(1)协议栈：网络通信…

(2)有用的应用程序包：应用程序本身不属于操作系统内核的一部分，应用程序是给人用的，面向某种功能的。譬如ping程序用来测试网络是否联通，ifconfig程序用来配置网卡。

 

### 2.14.1.4、内核和发行版的区别

区别：内核是操作系统内核的简称，内核负责实现操作系统的核心功能（资源管理模块，譬如内存管理、调度系统······），内核不包括应用程序。所以说只有内核人是没法用的，因为人做任何事情都是通过相应的应用程序来完成的。所以卖操作系统的人把内核和一些常用的应用程序打包在一起提供给普通用户，这就是操作系统的发行版（也就是普通意义上的操作系统）。

(1)内核只有一个。www.kernel.org

(2)发行版有很多。譬如ubuntu、redhat、suse、centos······

 

 

 

## 2.14.2.内核和驱动的关联

### 2.14.2.1、学习linux的思路

(1)对庞大的整体要有个认识。学习路线就是先建立框架和整体，然后逐渐去学习各个细节部分，逐步细化。

(2)对各分层的作用要清楚。

(3)对层次间的关联和互相调用要理解。

 

### 2.14.2.2、驱动属于内核的一部分

(1)驱动就是内核中的硬件设备管理模块

(2)驱动工作在内核态。内核态就是在跑操作系统的代码，用户态就是在运用应用层的代码。

(3)驱动程序故障可能导致整个内核崩溃。

(4)驱动程序漏洞会使内核不安全。

 

 

## 2.14.3.内核和应用程序、根文件系统的关联

###    2.14.3.1、应用和内核的关系

 

(1)应用程序不属于内核，而是在内核之上的

(2)应用程序工作在用户态，是受限制的。

(3)应用程序故障不会导致内核崩溃

(4)应用程序通过内核定义的API接口来调用内核工作

(5)总结1：应用程序是最终目标

(6)总结2：内核就是为应用程序提供底层资源管理的服务员

 

### 2.14.3.2、内核和根文件系统

(1)根文件系统提供根目录。

(2)进程1存放在根文件系统中。

(3)内核启动最后会去装载根文件系统。

(4)总结：根文件系统为操作系统启动提供了很多必备的资源：根目录、进程1

 

## 2.14.4.linux内核的模块化设计

### 2.14.4.1、什么是模块化设计

(1)因为linux内核很庞大，代码量很大、东西很多，如果设计时完全设计成一体（各个文件、各个函数之间紧耦合），复杂度超出了人所能理解的范围。所以模块化设计也是一种必要。

(2)模块化设计就是内核中各个功能模块在代码上是彼此独立的，譬如说调度系统和内存管理系统之间并没有全局变量的互相引用，甚至函数互相调用也很少，就算有也是遵循一个接口规范的。模块化设计的目的就是实现功能模块的松耦合。

### 2.14.4.2、模块化设计的体现

(1)配置时可裁剪。linux内核在编译之前可以进行配置，配置时可以选择将组成内核的成千上万个模块每一个要或者不要。要了之后还有更多的一些细节的配置。

(2)模块化编译和安装。为了操作方便，逐渐从静态的升级变成了动态的升级（不需要重启系统，更不需要重新烧录系统）。这种动态的升级也是由模块化来支持的。

(3)源码中使用条件编译。这种在uboot中已经见过了。

 

### 2.14.4.3、模块化设计的好处

(1)功能可裁剪、灵活性

(2)可扩展性（动态安装卸载、新硬件支持）

(3)利于协作

 

### 2.14.4.4、模块化设计是一种普遍性的系统设计原则

 

 

## 2.14.5.选择合适版本的内核

### 2.14.5.1、linux内核版本变迁简史

(1)linux0.01：初版

(2)linux0.11：很多讲linux内核源代码解析的书都是以这个版本为原本来讲。《图解linux内核设计的艺术》。

(3)linux2.4。比较接近现代的版本，很多经典的书都是以2.4版本内核为参照的，譬如《LDD3》。linux2.4的晚期内核在前几年还会经常碰到有用的。

(4)linux2.6早期。2.6的早期和2.4晚期内核挺像的。

(5)linux2.6晚期。2.6的晚期内核较早期内核有一些改变，尤其是驱动相关的部分和一些头文件的位置。2.6的晚期内核目前还算是比较主流。

(6)linux3.x 4.x

### 2.14.5.2、如何选择合适的内核版本

(1)并不是越新版本的内核越好

(2)选择SoC厂家移植版本会减少工作量

### 2.14.5.3、S5PV210适用的内核版本

(1)2.6.35.7+android2.3/QT4.8.3

(2)3.0.8+android4.0

### 2.14.5.4、本课程使用2.6.35.7版本内核讲解

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

 

# 第十五章 内核的配置和编译原理

## 2.15.0 章节概要

**2.15.1.linux内核源码目录结构1**

​    本节先找到合适的内核源码树，然后解压之并讲解根目录下的各个单个文件。

**2.15.2.linux内核源码目录结构2**

​    本节接上节讲解内核源码根目录下的各个文件夹，并且把一些重要文件夹的作用简单讲解。

**2.15.3.内核配置和编译体验**

​    本节进行内核的三步配置编译过程，目的是让大家学会内核的配置编译操作，方便之后学习原理。

**2.15.4.内核的配置原理1**

​    本节开始讲解内核配置的原理，主要是make xx_defconfig的原理。

**2.15.5.menuconfig的使用和演示**

​    本节详细演示make menuconfig的具体使用，详解其帮助信息。

**2.15.6.menuconfig的工作原理**

​    本节讲解menuconfig的工作原理，主要揭示了menuconfig和.config、Kconfig文件的关联。

**2.15.7.Kconfig文件详解1**

​    本节详解Kconfig文件的格式、作用等

**2.15.8.Kconfig文件详解2**

​    本节进一步解释Kconfig中配置项的细节，如depends、select等关键字的作用。

**2.15.9.menuconfig的实验学习思路**

​    本节总结menuconfig的原理并且提出一些验证思路并去实际验证，目的是让大家加深理解menuconfig的同时学会通过实验验证的方法进行学习。

## 2.15.1.linux内核源码目录结构1

### 2.15.1.1、源码从哪里来

(1)之前讲过，我们使用2.6.35.7版本的内核，这个版本的内核有三种：

第一种是kernel.org上的官方版本；

第二种是三星移植过的；

第三种是九鼎X210的移植版本；

我们讲课时使用第三种内核来讲解，后面的移植实验使用第二种内核来移植。

(2)源码在开发板光盘中有。可以自己去linux下解压然后make distclean清理然后再次打包传输到windows下去解压分析；也可以直接去我网盘中下载我打包好的。

(3)解压后最终在windows下得到了一个kernel的源码目录树，这个源码目录就是九鼎以三星移植过的内核为原材料自己针对X210移植后的内核版本。

### 2.15.1.2、分析源码目录下的单个文件

(1)Kbuild，Kbuild是kernel build的意思，就是内核编译的意思。这个文件就是linux内核特有的内核编译体系需要用到的文件。

(2)Makefile，这个是linux内核的总makefile，整个内核工程用这个Makefile来管理的。

(3)mk，是九鼎在移植时自己添加的，不是linux内核本身的东西。九鼎添加这个文件的作用是用这个文件来整天管理kernel目录的配置和编译，也就是说这个文件有点类似于我们之前移植uboot时自己创建的那个cp.sh。

### 2.15.1.3、简单讲一下linux内核的配置体系。

(1)linux内核很庞大，里面模块很多，而且可配置性非常高。所以linux源代码的配置是一个很复杂的事情，必须要有一套很复杂的机制来保证linux内核可以被正确的配置。（对比一下uboot，uboot的配置项都是在xxx.h中，用宏定义来表示的。uboot的这种方式很依赖于人的水平，因为uboot的配置体系很简单。）

(2)linux内核本身配置项有上千个，光靠人眼睛去看脑袋去记根本不可能，所以内核发明了一种体系用来帮助人进行简单化的配置。这种体系就是我们本课程中重点要研究的东西。

(3)Kbuild、Kconfig等文件，都是和内核的配置体系有关的。

 

 

## 2.15.2.linux内核源码目录结构2

(1)**arch**：arch是architecture的缩写，意思是架构。arch目录下是好多个不同架构的CPU的子目录，譬如arm这种cpu的所有文件都在arch/arm目录下，X86的CPU的所有文件都在arch/x86目录下。

(2)**block**：英文是块的意思，在linux中block表示块设备（以块（多个字节组成的整体，类似于扇区）为单位来整体访问），譬如说SD卡、iNand、Nand、硬盘等都是块设备。你几乎可以认为块设备就是存储设备。block目录下放的是一些linux存储体系中关于块设备管理的代码。

(3)**crypto**：英文意思是加密。这个目录下放了一些各种常见的加密算法的C语言代码实现。譬如crc32、md5、sha1等。

(4)**Documentation**：里面放了一些文档。

(5)**drivers**：驱动目录，里面分门别类的列出了linux内核支持的所有硬件设备的驱动源代码。

(6)**firmware**：固件。什么是固件？固件其实是软件，不过这个软件是固话到IC里面运行的叫固件。就像S5PV210里的iROM代码。

(7)**fs**：fs就是file system，文件系统，里面列出了linux支持的各种文件系统的实现。

(8)**include**：头文件目录，公共的（各种CPU架构共用的）头文件都在这里。每种CPU架构特有的一些头文件在arch/arm/include目录及其子目录下。

(9)**init**：init是初始化的意思，这个目录下的代码就是linux内核启动时初始化内核的代码。

(10)**ipc**：ipc就是inter process commuication，进程间通信，里面都是linux支持的IPC的代码实现。

(11)**kernel**： kernel就是内核，就是linux内核，所以这个文件夹下放的就是内核本身需要的一些代码文件。

(12)**lib**：lib是库的意思，这里面都是一些公用的有用的库函数，注意这里的库函数和C语言的库函数不一样的。在内核编程中是不能用C语言标准库函数，因为C语言标准库函数属于应用层，而操作系统内核应该用自己的函数。这里的lib目录下的库函数就是用来替代那些标准库函数的。譬如在内核中要把字符串转成数字用atoi，但是内核编程中只能用lib目录下的atoi函数，不能用标准C语言库中的atoi。譬如在内核中要打印信息时不能用printf，而要用printk，这个printk就是我们这个lib目录下的。

(13)**mm**：mm是memory management，内存管理，linux的内存管理代码都在这里。

(14)**net**：该目录下是网络相关的代码，譬如TCP/IP协议栈等都在这里。

(15)**scripts**：脚本，这个目录下全部是脚本文件，这些脚本文件不是linux内核工作时使用的，而是用来辅助对linux内核进行配置编译生产的。我们并不会详细进入分析这个目录下的脚本，而是通过外围来重点学会配置和编译linux内核即可。

(16)**security**：安全相关的代码。不用去管。

(17)**sound**：音频处理相关的。

(18)**tools**：linux中用到的一些有用工具。

(19)**usr**：目录下是initramfs相关的，和linux内核的启动有关，暂时不用去管。

(20)**virt**：内核虚拟机相关的，暂时不用管。

 

总结：这么多目录跟我们关系很紧密的就是arch和drivers目录，然后其他有点相关的还有include、block、mm、net、lib等目录。

 

 

## 2.15.3.内核配置和编译体验

### 2.15.3.1、先确认Makefile

(1)主要是检查交叉编译工具链有没有设置对。CROSS_COMPILE  ?= /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-

(2)确认ARCH = arm。主要目的是为了编译时能找到arch/arm目录。

 

### 2.15.3.2、make x210ii_qt_defconfig

(1)最后只要出现：configuration written to .config这句话，就证明我们的操作是正确的。如果没有出现这句话，就有错误。

(1)可能出现的错误1：名字敲错了。名字是字符串匹配的，一定要正确。

注意：如果这一步配置没有得到.config文件，是不能进行到下一步的。实际测试时没有.config也可以make menuconfig，但是这样做出来的内核编译和烧写运行应该是有问题的。

 

### 2.15.3.3、make menuconfig

(1)可能出现的错误1：ncurses库没装

错误信息：

 *** Unable to find the ncurses libraries or the

 *** required header files.

 *** 'make menuconfig' requires the ncurses libraries.

***

 *** Install ncurses (ncurses-devel) and try again.

 

解决方案： apt-get install libncurses5-dev （参考了：http://blog.csdn.net/yao_qinwei/article/details/8805101）

 

(2)可能出现的错误2：屏幕太小

错误信息：

Your display is too small to run Menuconfig!

It must be at least 19 lines by 80 columns.

解决方案：全屏，或者是把字体调小。

 

总结：make menuconfig是第二步配置，具体的用法和配置意义在后面课程讲。我们这里因为是九鼎已经移植过的，所以第二步配置是可以不做的，直接退出即可。

用键盘的向右方向键移动到EXIT，按回车退出。

 

### 2.15.3.4、make

(1)可能出现的错误1：莫名其妙的错误，可以试试先make distclean

(2)代码本身的错误：具体问题具体分析

(3)编译完成后得到的内核镜像不在源码树的根目录下，在arch/arm/boot这个目录下。得到的镜像名是zImage

 

 

## 2.15.4.内核的配置原理1

### 2.15.4.1、烧写测试

### 2.15.4.2、配置的关键是得到.config文件

(1).config以.开头，是一个隐藏文件，因此平时是看不到的，需要ls -a来看

(2)当我们make distclean后（也就是说默认情况下）是没有.config文件的，我们配置的两步过程就是为了得到内容合适的.config文件

(3).config文件是linux内核在编译过程中很重要的一个文件，其作用类似与uboot中的include/configs/x210_sd.h，内核在编译过程中会读取.config中的配置项，并且用这些配置项去指导整个编译链接过程。

(4).config文件的格式类似于脚本文件，其中内容为类似于于：CONFIG_ARM=y的一个一个的配置项。这些配置项就类似于脚本文件中定义的一个一个变量，所以这一行可以被理解为定义了一个变量CONFIG_ARM，这个变量的值为y。

(5).config文件中每一行都是一个配置项，从.config文件的规模可以看出linux内核的可配置项有两三千个。所以linux内核是高度可配置的，而且linux内核的所有配置项很难全部搞明白。因为linux内核的配置项太多太繁杂超出了人的大脑能够记忆和处理的数量级，因此linux内核不像uboot那样直接手工配置，而是发明了一个图形化的配置工具menuconfig。

 

### 2.15.4.3、make xx_defconfig和make menuconfig相配合

(1)我们为了对.config文件中的两三千个配置项做逐一合适的配置，专门发明了两步结合的配置方式。

(2)其实只要人的记忆足够好，大脑足够厉害，完全可以手工去书写/修改.config文件完成内核配置，最终只要.config中内容是正确的，就不影响编译过程。

(3)第一步：make xxx_defconfig解决的问题是大部分的配置项（这一步结束后99%的配置项就已经正确了），下来就是对个别不同的针对我们的开发板进行细节调整，细节调整就通过make menuconfig来完成。

(4)make xxx_defconfig这一步其实是参考别人已经做好的，这样做有很多好处：减少很多工作量，避开了很多自己不懂的配置项（譬如对内存管理的、调度系统的等模块的配置项），我们只用管自己需要管的。

(5)make menuconfig其实就是读取第一步得到的.config，然后给我们一个图形化的界面，让我们可以更加容易的找到自己想要修改的配置项，然后更改配置他。

 

### 2.15.4.4、make xx_defconfig到底做了什么？

(1)make x210ii_qt_defconfig其实相当于：cp arch/arm/configs/x210ii_qt_defconfig .config

(2)arch/arm/configs目录下的这么多个xxx_defconfig哪里来的？其实这些文件都是别人手工配置好适合一定的开发板的.config文件后自己把.config文件保存过去的。譬如说我们用S5PV210这个SoC，针对这个SoC的开发板的最初配置肯定是三星的工程师去做的。

 

 

## 2.15.5.menuconfig的使用和演示    

### 2.15.5.1、使用说明解释

(1)make ，menuconfig中本身自带的提示就有所有的用法，这里只要全部理解就可以了。

(2)menuconfig中间的选择区中有很多个选择项，每个选择项对应.config文件中的一个配置项，每一个选择项都可以被选择和配置操作，选择区中的每一项都是有子目录的，将光标放在选择项上按Enter键可以进入子目录（子目录可能还会有子目录）。选择区太短放不下所有的一个目录层级的选项，可以用箭头按键的向上箭头和向下箭头来上翻和下翻。

 

注：在menuconfig中操作相关的几个键盘按键，主要是；Enter、ESC、四个方向箭头按键。还有一些特殊字符按键，如/ ? 

**向上和向下箭头**：主要用来在选择项菜单中目录浏览时上下翻

**回车**        ：主要作用是选中并且执行select/exit/help。

**ESC**         ：主要作用是返回上一层

**向左和向右箭头**：主要作用是在菜单选项（select、exit、help）间切换。

 

(3)用法翻译：

**箭头按键导航整个菜单**：

回车按键选择子菜单;

注意选项后面有 **--->**的选项才是有子菜单的，没有这个标识的没有子菜单。

**高亮的字母是热键（快捷键）**：

键盘按键**Y****、N、M**：三个按键的作用分别是将选中模块**编入、去除、模块化**。

**ESC：**双击ESC表示退出；

**？**：显示帮**助信息**；

**/** ：输入搜索内容来全局搜索信息（类似于vi中的搜索）；

**[ ]**：不可以模块化；

**< >**: 的才可以模块化；

 

**在menuconfig中选项前面的括号里，\*表示编入，空白表示去除，M表示模块化**;

注：linux内核中一个功能模块有三种编译方法：一种是编入、一种去去除、一种是模块化。所谓编入就是将这个模块的代码直接编译连接到zImage中去，去除就是将这个模块不编译链接到zImage中，模块化是将这个模块仍然编译，但是不会将其链接到zImage中，会将这个模块单独链接成一个**内核模块.ko文件**，将来linux系统内核启动起来后可以动态的加载或卸载这个模块。

 

 

## 2.15.6.menuconfig的工作原理

### 2.15.6.1、menuconfig本身由一套软件支持

(1)linux为了实现图形化界面的配置，专门提供了一套配置工具menuconfig。

(2)ncurses库是linux中用来实现文字式的图形界面，linux内核中使用了ncurses库来提供menuconfig

(3)kernel_samsung\scripts\kconfig\lxdialog目录下的一些c文件就是用来提供menuconfig的那些程序源代码。

 

### 2.15.6.2、menuconfig读取Kconfig文件

(1)menuconfig本身的软件只负责提供menuconfig工作的这一套逻辑（譬如在menuconfig中通过上下左右箭头按键来调整光标，Enter ESC键等按键按下的响应），而并不负责提供内容（菜单里的项目）。

(2)menuconfig显示的菜单内容（一方面是菜单的目录结构，另一方面是每一个菜单项目的细节）是由内核源码树各个目录下的Kconfig文件来支持的。Kconfig文件中按照一定的格式包含了一个又一个的配置项，每一个配置项在make menuconfig中都会成为一个菜单项目。而且menuconfig中显示的菜单目录结构和源码目录中的Kconfig的目录结构是一样的。

(3)在相应的Kconfig文件中删除一个config项，则再次make menuconfig时这个项目已经看不到了。

 

### 2.15.6.3、menuconfig读取/写入.config文件

(1)刚才已经知道menuconfig的菜单内容来自于Kconfig文件，但是每一个菜单的选择结果（Y、N、M）却不是保存在Kconfig文件中的。Kconfig文件是不变的，Kconfig文件只是决定有没有这个菜单项，并不管这个菜单项的选择结果。

(2)menuconfig工作时在我们make menuconfig打开时，他会读取.config文件，并且用.config文件中的配置选择结果来初始化menuconfig中各个菜单项的选择值。

 

总结：菜单项的项目内容从Kconfig文件来，菜单项的选择值从.config文件来

 

(3)当我们每次退出make menuconfig时，menuconfig机制会首先检查我们有没有更改某些配置项的值，如果我们本次没有更改过任意一个配置项目的值那直接退出；如果我们有改动配置项的值则会提示我们是否保存。此时如果点保存，则会将我们更改过的配置重新写入.config文件中记录，下一次再次打开make menuconfig时会再次加载.config，最终去编译内核时编译连接程序会考虑.config中的配置值指导整个编译连接过程。

 

总结：本节课主要内容就是讲：menuconfig和Kconfig和.config的关系。

 

 

## 2.15.7.Kconfig文件详解1

### 2.15.7.1、Kconfig的格式

(1)Kconfig按照一定的格式来书写，menuconfig程序可以识别这种格式，然后从中提取出有效信息组成menuconfig中的菜单项。

(2)将来在做驱动移植等工作时，有时需要自己添加Kconfig中的一个配置项来将某个设备驱动添加到内核的配置项目中，这时候就需要对Kconfig的配置项格式有所了解，否则就不会添加。

(3)#开头的行是注释行

(4)menuconfig表示菜单（本身属于一个菜单中的项目，但是他又有子菜单项目）、config表示菜单中的一个配置项（本身并没有子菜单下的项目）。

*menuconfig NETDEVICES*

​    *default y if UML*

​    *depends on NET*

​    *bool "Network device support"*

​    *---help---*

​     *You can say N here if you don't intend to connect your Linux box to*

​     *any other computer at all.*

(5)menuconfig或者config后面空格隔开的大写字母表示的类似于 NETDEVICES 的就是这个配置项的配置项名字，这个字符串前面添加CONFIG_后就构成了.config中的配置项名字。

(6)一个menuconfig后面跟着的所有config项就是这个menuconfig的子菜单。这就是Kconfig中表示的目录关系。

*menu "Device Drivers"*

*source "drivers/base/Kconfig"*

*source "drivers/connector/Kconfig"*

(7)内核源码目录树中每一个Kconfig都会source引入其所有子目录下的Kconfig，从而保证了所有的Kconfig项目都被包含进menuconfig中。这个也告诉我们：如果你自己在linux内核中添加了一个文件夹，一定要在这个文件夹下创建一个Kconfig文件，然后在这个文件夹的上一层目录的Kconfig中source引入这个文件夹下的Kconfig文件。

 

### 2.15.7.2、tristate和bool的含义

(1)tristate意思是三态：3种状态，对应Y、N、M三种选择方式；

(2)bool是要么真要么假（对应Y和N）;

所以tristate的意思就是这个配置项可以被三种选择，bool的意思是这个配置项只能被2种选择。

 

## 2.15.8.Kconfig文件详解2

### 2.15.8.1、depends的含义

 

​    IFB配置项依赖于NET_CLS_ACT，如果NET_CLS_ACT值为假，IFB也为假；

(1)depends中文意思是“取决于”或者“依赖于”，所以depends在这里的意思是：本配置项依赖于另一个配置项。如果那个依赖的配置项为Y或者M，则本配置项才有意义；如果依赖的哪个配置项本身被设置为N，则本配置项根本没有意义。

(2)depends项目会导致make menuconfig的时候找不到一些配置项。所以你在menuconfig中如果找不到一个选项，但是这个选项在Kconfig中却是有的，则可能的原因就是这个配置项依赖的一个配置项是不成立的。

 

(3)depends并不要求依赖的配置项一定是一个，可以是多个，而且还可以有逻辑运算。这种时候只要依赖项目运算式子的裸机结果为真则依赖就成立。

​    select ：当前选项选中后则select后指定的选项自动被选择

### 2.15.8.2、help

(1)帮助信息，告诉我们这个配置项的含义，以及如何去配置他。

 

### 2.15.8.3、Kconfig和.config文件和Makefile三者的关联

(1)配置项被配置成Y、N、M会影响.config文件中的CONFIG_XXX变量的配置值。

(2)这个.config中的配置值（=y、=m、没有）会影响最终的编译链接过程。如果=y则会被编入（built-in），如果=m会被单独连接成一个ko模块，如果没有则对应的代码不会被编译。那么这么是怎么实现的？都是通过makefile实现的。

(3)obj-$(CONFIG_DM9000) += dm9000.o

如果CONFIG_DM9000变量值为y，则obj += dm9000.o，因此dm9000.c会被编译；如果CONFIG_DM9000变量未定义，则dm9000.c不会被编译。如果CONFIG_DM9000变量的值为m则会被连接成ko模块（这个是在linux内核的Makefile中定义的规则）。

 

总结：把menuconfig中的菜单项、Kconfig中的配置项、.config中的一行、 Makefile中的一行，这4个东西结合起来理解，则整个linux内核的配置体系就明了了。

 

 

## 2.15.9.menuconfig的实验学习思路

### 2.15.9.1、验证menuconfig和.config的关系

(1)make menuconfig时，会读取.config中的配置值来初始化menuconfig中的配置项。

验证：如果理论正确的，那么我自己手工修改了.config的配置后，再次make menuconfig时看到的初始值就应该是我手工修改的。

(2)menuconfig中修改了（按Y、N、M）配置项的值，然后退出时保存，则这个保存结果会修改.config文件中的相应行。

验证：如果结论是正确的，那么在menucofig中修改了配置后保存退出，再次去手工打开.config文件则可以看到相应配置的一行内容被修改了。

 

### 2.15.9.2、验证menuconfig和Kconfig的关系

(1)menuconfig读取Kconfig的内容作为菜单项目内容。

验证1：在Kconfig中删除一个config项，则再次make menuconfig时就看不到这个项目了。（上课时已经验证过了）。

验证2：在Kconfig中自己添加创建一个config项，则再次make menuconfig时就能看到多了一个项目。

 

### 2.15.9.3、验证验证menuconfig和Makefile的关系

(1)我找一个模块，把他配制成y，然后去make编译连接，最后得到的zImage中这个模块就应该被编译连接进去到zImage中了。

验证：

​    方法一：去这个模块对应的源代码目录看一下这个源码有没有被编译。

​    方法二：去zImage对应的elf格式的vmlinux中查看符号。

​           相应的目录中有System.map有相应的函数；

​    方法三：将vmlinux反编译（objdump）后得到的文件中找模块对应的符号。

​           /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-objdum -D

​           vmlinux >vmlinx.txt , 将反编译的信息写到vmlinux.txt中去；

​    方法四：将zImage下载到开发板中启动，启动后看你的模块能不能工作。

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第十六 章内核的启动过程分析

## 2.16.0 章节概要

**2.16.1.做好内核分析的准备工作**

​    本节课开始建立工程、分析Makefile等，主要目的是为开始内核代码的分析扫清障碍，做好准备工作。

**2.16.2.head.S文件分析1**

​    本节开始分析head.S文件，主要分析了内核运行的虚拟地址与物理地址，内核真正入口以及启动条件等。

**2.16.3.内核启动的汇编阶段**

​    本节讲解内核启动的汇编阶段剩余内容，主要是cpu的校验、机器码的校验、传参tag的校验、页表的创建、各种段的处理等。

**2.16.4.内核启动的C语言阶段1**

​    本节讲述内核学习的学习思路、学习方法和主体线路。本节课程的学习目的是让大家对内核的特点和不同的学习思路有个认识。

**2.16.5.内核启动的C语言阶段2** 

​    本节开始按照代码执行路径分析内核的C阶段。本节课主要讲了printk函数的工作原理和内核初始化打印出banner信息的部分。

**2.16.6.内核启动的C语言阶段3**

​    本节讲解setup_arch函数中的machine查找的部分，初步分析了内核对机器码的定义和存储方式、比对方式、获取方式。

**2.16.7.内核启动的C语言阶段4**

​    本节讲解setup_arch函数中对cmdline的处理，重点讲解了cmdline的传递方式、确认方式和其对内核的影响和意义。

**2.16.8.内核启动的C语言阶段5**

​    本节讲解start_kernel函数中剩余部分函数调用直到rest_init的部分，并无太多重点细节。

**2.16.9.内核启动的C语言阶段6**

​    本节重点讲解了rest_init函数中创建三个内核线程以及对这三个内核线程的介绍，本节课听完后就明白了操作系统最终的走向和归宿。

**2.16.10.init进程详解1**

​    本节课从宏观上讲解了init进程的工作和主要作用，交代了操作系统在内核态和用户态下的切换过程，init进程如何一步步发展成为平时看到的操作系统。

**2.16.11.init进程详解2**

​    本节对init进程的代码进行分析对比，重点是一些细节和对上节讲到的宏观理论的代码验证和支持。

**2.16.12.cmdline常用参数**

​    本节补充讲解uboot给内核传参时常用的一些cmdline参数选项及其含义。

**2.16.13.内核中架构相关代码简介**   

​    本节补充讲解内核源码中架构相关的代码部分，并非代码详解而是从宏观上讲述相关的文件夹和文件位置、作用介绍等。

## 2.16.1.做好内核分析的准备工作

### 2.16.1.1、删除无用文件

(1)官方版本的kernel中是支持各种硬件架构、各种开发板的，因此有很多文件夹和文件和我们无关，在建立SI工程前应该删掉这些家伙。

(2)我们现在分析的是开发板厂商九鼎科技移植好的针对X210开发板的kernel，因此其中一些无用文件已经被删掉了。

 

### 2.16.1.2、建立SI工程并解析

(2)建立方法和uboot中当时讲的是一样的。

 

### 2.16.1.3、Makefile分析

(1)kernel的Makefile写法和规则等和uboot的Makefile是一样的，甚至Makefile中的很多内容都是一样的。

(2)kernel的Makefile比uboot的Makefile要复杂，这里我们并不会一行一行的详细分析。

(3)Makefile中只有一些值得关注的我会强调一下，其他不强调的地方暂时可以不管。

(4)Makefile中刚开始定义了kernel的内核版本号。这个版本号挺重要（在模块化驱动安装时会需要用到），要注意会查，会改。

(5)在make编译内核时，也可以通过命令行给内核makefile传参（跟uboot配置编译时传参一样）。譬如make O=xxx可以指定不在源代码目录下编译，而到另外一个单独文件夹下编译。

(6)kernel的顶层Makefile中定义了2个变量很重要，一个是ARCH，一个是CROSS_COMPILE。ARCH决定当前配置编译的路径，譬如ARCH = arm的时候，将来在源码目录下去操作的arch/arm目录。CROSS_COMPILE用来指定交叉编译工具链的路径和前缀。

(7)CROSS_COMPILE = xxx和ARCH = xxx和O=xxx这些都可以在make时通过命令行传参的方式传给顶层Makefile。

所以有时候你会看到别人编译内核时：make O=/tmp/mykernel ARCH=arm CROSS_COMPILE=/usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-

 

### 2.16.1.4、链接脚本分析

(1)分析连接脚本的目的就是找到整个程序的entry

(2)kernel的连接脚本并不是直接提供的，而是提供了一个汇编文件vmlinux.lds.S，然后在编译的时候再去编译这个汇编文件得到真正的链接脚本vmlinux.lds。

(3)vmlinux.lds.S在arch/arm/kernel/目录下。

(4)思考：为什么linux kernel不直接提供vmlinux.lds而要提供一个vmlinux.lds.S然后在编译时才去动态生成vmlinux.lds呢？

猜测：.lds文件中只能写死，不能用条件编译。但是我们在kernel中链接脚本确实有条件编译的需求（但是lds格式又不支持），于是乎kernel工作者找了个投机取巧的方法，就是把vmlinux.lds写成一个汇编格式，然后汇编器处理的时候顺便条件编译给处理了，得到一个不需要条件编译的vmlinux.lds。

(5)入门在哪里？从vmlinux.lds中ENTRY(stext)可以知道入口符号是stext，在SI中搜索这个符号，发现arch/arm/kernel/目录下的head.S和head-nommu.S中都有。

(6)head.S是启用了MMU情况下的kernel启动文件，相当于uboot中的start.S。head-nommu.S是未使用mmu情况下的kernel启动文件。

 

 

## 2.16.2.head.S文件分析1

### 2.16.2.1、内核运行的物理地址与虚拟地址

(1)KERNEL_RAM_VADDR（VADDR就是virtual address），这个宏定义了内核运行时的虚拟地址。值为0xC0008000

(2)KERNEL_RAM_PADDR（PADDR就是physical address），这个宏定义内核运行时的物理地址。值为0x30008000

(3)总结：内核运行的物理地址是0x30008000，对应的虚拟地址是0xC0008000。

 

### 2.16.2.2、内核的真正入口

(1)内核的真正入口就是ENTRY(stext)处

(2)前面的__HEAD定义了后面的代码属于段名为.head.text的段，意义为将这段代码连接到这一段上去。

 

### 2.16.2.3、内核运行的硬件条件

(1)内核的起始部分代码是被解压代码调用的。回忆之前讲zImage的时候，uboot启动内核后实际调用运行的是zImage前面的那段未经压缩的解压代码，解压代码运行时先将zImage后段的内核解压开，然后再去调用运行真正的内核入口。

(2)内核启动不是无条件的，而是有一定的先决条件，这个条件由启动内核的bootloader（我们这里就是uboot）来构建保证。

(3)ARM体系中，函数调用时实际是通过寄存器传参的（函数调用时传参有两种设计：一种是寄存器传参，另一种是栈内存传参）。所以uboot中最后theKernel (0, machid, bd->bi_boot_params);执行内核时，运行时实际把0放入r0中，machid放入到了r1中，bd->bi_boot_params放入到了r2中。ARM的这种处理技巧刚好满足了kernel启动的条件和要求。

(4)kernel启动时MMU是关闭的，因此硬件上需要的是物理地址。但是内核是一个整体（zImage）只能被连接到一个地址（不能分散加载），这个连接地址肯定是虚拟地址。因此内核运行时前段head.S中尚未开启MMU之前的这段代码就很难受。所以这段代码必须是位置无关码，而且其中涉及到操作硬件寄存器等时必须使用物理地址。

### 2.16.2.4、内核启动要求的传参方式

 

 

## 2.16.3.内核启动的汇编阶段

### 2.16.3.1、__lookup_processor_type

  mrc p15, 0, r9, c0, c0   @ get processor id

bl __lookup_processor_type   @ r5=procinfo r9=cupid

  movs  r10, r5       @ invalid processor (r5=0)?

  beq __error_p  

 

(1)我们从cp15协处理器的c0寄存器中读取出硬件的CPU ID号，然后调用这个函数来进行合法性检验。如果合法则继续启动，如果不合法则停止启动，转向__error_p启动失败。

(2)该函数检验cpu id的合法性方法是：内核会维护一个本内核支持的CPU ID号码的数组，然后该函数所做的就是将从硬件中读取的cpu id号码和数组中存储的各个id号码依次对比，如果没有一个相等则不合法，如果有一个相等的则合法。

(3)内核启动时设计这个校验，也是为了内核启动的安全性着想。

### 2.16.3.2、__lookup_machine_type

  bl __lookup_machine_type    @ r5=machinfo

  movs  r8, r5       @ invalid machine (r5=0)?

  beq __error_a      @ yes, error 'a' 

 

(1)该函数的设计理念和思路和上面校验cpu id的函数一样的。不同之处是本函数校验的是机器码。

### 2.16.3.3、__vet_atags

​     bl __vet_atags

(1)该函数的设计理念和思路和上面2个一样，不同之处是用来校验uboot给内核的传参ATAGS格式是否正确。这里说的传参指的是uboot通过tag给内核传的参数（主要是板子的内存分布memtag、uboot的bootargs）

(2)内核认为如果uboot给我的传参格式不正确，那么我就不启动。

(3)uboot给内核传参的部分如果不对，是会导致内核不启动的。譬如uboot的bootargs设置不正确内核可能就会不启动。

### 2.16.3.4、__create_page_tables

  bl __create_page_tables

(1)顾名思义，这个函数用来建立页表。

(2)linux内核本身被连接在虚拟地址处，因此kernel希望尽快建立页表并且启动MMU进入虚拟地址工作状态。但是kernel本身工作起来后页表体系是非常复杂的，建立起来也不是那么容易的，但是kernel想了一个好办法。

(3)kernel建立页表其实分为2步：

**第一步**，kernel先建立了一个段式页表（和uboot中之前建立的页表一样，页表以1MB为单位来区分的），这里的函数就是建立段式页表的。段式页表本身比较好建立（段式页表1MB一个映射，4GB空间需要4096个页表项，每个页表项4字节，因此一共需要16KB内存来做页表），坏处是比较粗不能精细管理内存；

**第二步**，再去建立一个细页表（4kb为单位的细页表），然后启用新的细页表废除第一步建立的段式映射页表。

(4)内核启动的早期建立段式页表，并在内核启动前期使用；内核启动后期就会再次建立细页表并启用。等内核工作起来之后就只有细页表了。

### 2.6.3.5、__switch_data

  ldr r13, __switch_data   @ address to jump to after

(1)建立了段式页表后进入了__switch_data部分，这东西是个函数指针数组。

(2)分析得知下一步要执行__mmap_switched函数。

(3)复制数据段、清除bss段（目的是构建C语言运行环境）。

(4)保存起来cpu id号、机器码、tag传参的首地址。

(5)b start_kernel跳转到C语言运行阶段。

 

总结：汇编阶段其实也没干啥，主要原因是uboot干了大部分活。汇编阶段主要就是校验启动合法性、建立段式映射的页表并开启MMU以方便使用内存、跳入C阶段。

 

 

 

## 2.16.4.内核启动的C语言阶段1

### 2.16.4.1、这一块的学习思路

(1)抓大放小，不深究：浏览里面的函数大概知道函数干了什么，不要去抓函数实现的细节。

(2)感兴趣可以就某个话题去网上搜索资料学习。

(3)重点局部深入分析

### 2.16.4.2、具体学习方法

(1)顺着代码执行路径抓全。这是我们的学习主线。

(2)对照内核启动的打印信息进行分析。

### 2.16.4.3、几条学习线路

(1)分析uboot给kernel传参的影响和实现

(2)硬件初始化与驱动加载

(3)内核启动后的结局与归宿

 

## 2.16.5.内核启动的C语言阶段2

### 2.16.5.1、杂碎（暂时不用深究）

(1)**smp**：smp就是对称多处理器（其实就是我们说的多核心CPU）。对称就是CPU的核心是一样的。

(2)**lockdep**：锁定依赖，是一个内核调试模块，处理内核自旋锁死锁问题相关的。

(3)**cgroup**：control group，内核提供的一种来处理进程组的技术。

### 2.16.5.2、打印内核版本信息

printk(KERN_NOTICE "%s", linux_banner);

(1)代码位于：kernel/init/main.c中的572行

(2)printk函数是内核中用来从console打印信息的，类似于应用层编程中的printf。内核编程时不能使用标准库函数，因此不能使用printf，其实printk就是内核自己实现的一个printf。

(3)printk函数的用法和printf几乎一样，不同之处在于可以在参数最前面用一个宏来定义消息输出的级别。为什么要有这种级别？主要原因是linux内核太大了，代码量太多，里面的printk打印信息太多了。如果所有的printk都能打印出来而不加任何限制，则最终内核启动后得到海量的输出信息。

 

\#define KERN_EMERG "<0>"  /* system is unusable      */

​                 已经掉下悬崖

\#define KERN_ALERT "<1>"  /* action must be taken immediately */

​                 在悬崖边上了一只脚已经迈出了悬崖

\#define KERN_CRIT  "<2>"  /* critical conditions     */

​                 在悬崖边上了，还没迈步

\#define KERN_ERR  "<3>"  /* error conditions     */

​                 你感冒了

\#define KERN_WARNING "<4>"  /* warning conditions      */

​                 没事，大冬天在外面浪，没准就感冒了

\#define KERN_NOTICE "<5>"  /* normal but significant condition */

​                 比较重要点的消息，考诉你什么考试类

\#define KERN_INFO  "<6>"  /* informational      */

​                 一般消息：节日快乐类

\#define KERN_DEBUG "<7>"  /* debug-level messages     */

​                 调试信息

(4)为了解决打印信息过多，无效信息会淹没有效信息这个问题，linux内核的解决方案是给每一个printk添加一个打印级别。级别定义0-7（注意编程的时候要用相应的宏定义，不要直接用数字）分别代表8种输出的重要性级别，0表示最重要，7表示最不重要。我们在printk的时候自己根据自己的消息的重要性去设置打印级别。

(5)linux的控制台监测消息的地方也有一个消息过滤显示机制，控制台实际只会显示级别比我的控制台定义的级别高的消息。譬如说控制台的消息显示级别设置为4，那么只有printk中消息级别为0-3（也可能是0-4）的才可以显示看见，其余的被过滤掉了。

(6)linux_banner的内容解析。

 

/* FIXED STRINGS! Don't touch! */

const char linux_banner[] =

  "Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"

  LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";

 

 

 

## 2.16.6.内核启动的C语言阶段3

### 2.16.6.1、setup_arch函数简介

setup_arch(&command_line);

(1)从名字看，这个函数是CPU架构相关的一些创建过程。

(2)实际上这个函数是用来确定我们当前内核的机器（arch、machine）的。我们的linux内核会支持一种CPU的运行，CPU+开发板就确定了一个硬件平台，然后我们当前配置的内核就在这个平台上可以运行。之前说过的机器码就是给这个硬件平台一个固定的编码，以表征这个平台。

(3)当前内核支持的机器码以及硬件平台相关的一些定义都在这个函数中处理。

 

### 2.16.6.2、Machine查找

 

(1)setup_processor函数用来查找CPU信息，可以结合串口打印的信息来分析。

 

(2)setup_machine函数的传参是机器码编号，machine_arch_type符号在include/generated/mach-types.h的32039-32050行定义了。经过分析后确定这个传参值就是2456.

(3)函数的作用是通过传入的机器码编号，找到对应这个机器码的machine_desc描述符，并且返回这个描述符的指针。

(4)其实真正干活的函数是lookup_machine_type，找这个函数发现在head-common.S中，真正干活的函数是__lookup_machine_type

(5)__lookup_machine_type函数的工作原理：内核在建立的时候就把各种CPU架构的信息组织成一个一个的machine_desc结构体实例，然后都给一个段属性.arch.info.init，链接的时候会保证这些描述符会被连接在一起。__lookup_machine_type就去那个那些描述符所在处依次挨个遍历各个描述符，比对看机器码哪个相同。

 

 

## 2.16.7.内核启动的C语言阶段4

### 2.16.6.3、setup_arch函数进行了基本的cmdline处理

(1)这里说的cmdline就是指的uboot给kernel传参时传递的命令行启动参数，也就是uboot的bootargs。

(2)有几个相关的变量需要注意：

default_command_line：看名字是默认的命令行参数，实际是一个全局变量字符数组，这个字符数组可以用来存东西。

 

static char default_command_line[COMMAND_LINE_SIZE] __initdata = CONFIG_CMDLINE;

 

CONFIG_CMDLINE：在.config文件中定义的（可以在make menuconfig中去更改设置），这个表示内核的一个默认的命令行参数。

(3)内核对cmdline的处理思路是：内核中自己维护了一个默认的cmdline（就是.config中配置的这一个），然后uboot还可以通过tag给kernel再传递一个cmdline。如果uboot给内核传cmdline成功则内核会优先使用uboot传递的这一个；如果uboot没有给内核传cmdline或者传参失败，则内核会使用自己默认的这个cmdline。以上说的这个处理思路就是在setup_arch函数中实现的。

 

### 2.6.6.4、实验验证内核的cmdline确定

 

(1)验证思路：首先给内核配置时配置一个基本的cmdline，然后在uboot启动内核时给uboot设置一个bootargs，然后启动内核看打印出来的cmdline和uboot传参时是否一样。

(2)在uboot中去掉bootargs，然后再次启动内核看打印出来的cmdline是否和内核中设置的默认的cmdline一样。

 

注意：uboot给内核传递的cmdline非常重要，会影响内核的运行，所以要谨慎。有时候内核启动有问题，可以分析下是不是uboot的bootargs设置不对。

 

注意：这个传参在这里确定出来之后，还没完。后面还会对这个传参进行解析。解析之后cmdline中的每一个设置项都会对内核启动有影响。

思考：内核为什么要这样设计？

 

 

## 2.16.8.内核启动的C语言阶段5

### 2.16.8.1、setup_command_line

(1)也是在处理和命令行参数cmdline有关的任务。

### 2.16.8.2、parse_early_param&parse_args

​     parse_early_param();

  parse_args("Booting kernel", static_command_line, __start___param,

​      __stop___param - __start___param,

​      &unknown_bootoption

 

(1)解析cmdline传参和其他传参

(2)这里的解析意思是把cmdline的细节设置信息给解析出来。譬如cmdline：console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3，则解析出的内容就是就是一个字符串数组，数组中依次存放了一个设置项目信息。

console=ttySAC2,115200 一个

root=/dev/mmcblk0p2 rw 一个

init=/linuxrc             一个

rootfstype=ext3          一个

(3)这里只是进行了解析，并没有去处理。也就是说只是把长字符串解析成了短字符串，最多和内核里控制这个相应功能的变量挂钩了，但是并没有去执行。执行的代码在各自模块初始化的代码部分。

 

### 2.16.8.3、杂碎

(1)trap_init                   置异常向量表

(2)mm_init                   内存管理模块初始化

(3)sched_init                     内核调度的初始化

(4)early_irq_init&init_IRQ         中断初始化

(5)console_init                控制台初始化

总结：start_kernel函数中调用了很多的xx_init函数，全都是内核工作需要的模块的初始

化函数。这些初始化之后内核就具有了一个基本的可以工作的条件了。如果把内核比喻成一个复杂机器，那么start_kernel函数就是把这个机器的众多零部件组装在一起形成这个机器，让他具有可以工作的基本条件。

 

### 2.16.8.4、rest_init

(1)这个函数之前内核的基本组装已经完成。

(2)剩下的一些工作就比较重要了，放在了一个单独的函数中，叫rest_init。

 

总结：start_kernel函数做的主要工作：打印了一些信息、内核工作需要的模块的初始化被依次调用（譬如内存管理、调度系统、异常处理···）、我们需要重点了解的就是setup_arch中做的2件事情：机器码架构的查找并且执行架构相关的硬件的初始化、uboot给内核的传参cmdline。

 

 

## 2.16.9.内核启动的C语言阶段6

### 2.16.9.1、操作系统去哪了

  kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);

  numa_default_policy();

  pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);

 

(1)rest_init中调用kernel_thread函数启动了2个内核线程，分别是：kernel_init和kthreadd

(2)调用schedule函数开启了内核的调度系统，从此linux系统开始转起来了。

  /* Call into cpu_idle with preempt disabled */

  cpu_idle();

 

(3)rest_init最终调用cpu_idle函数结束了整个内核的启动。也就是说linux内核最终结束了一个函数cpu_idle。这个函数里面肯定是死循环。

(4)简单来说，linux内核最终的状态是：有事干的时候去执行有意义的工作（执行各个进程任务），实在没活干的时候就去死循环（实际上死循环也可以看成是一个任务）。

(5)之前已经启动了内核调度系统，调度系统会负责考评系统中所有的进程，这些进程里面只有有哪个需要被运行，调度系统就会终止cpu_idle死循环进程（空闲进程）转而去执行有意义的干活的进程。这样操作系统就转起来了。

 

### 2.16.9.2、什么是内核线程

(1)进程和线程。简单来理解，一个运行的程序就是一个进程。所以进程就是任务、进程就是一个独立的程序。独立的意思就是这个程序和别的程序是分开的，这个程序可以被内核单独调用执行或者暂停。

(2)在linux系统中，线程和进程非常相似，几乎可以看成是一样的。实际上我们当前讲课用到的进程和线程的概念就是一样的。

(3)进程/线程就是一个独立的程序。应用层运行一个程序就构成一个用户进程/线程，那么内核中运行一个函数（函数其实就是一个程序）就构成了一个内核进程/线程。

(4)所以我们kernel_thead函数运行一个函数，其实就是把这个函数变成了一个内核线程去运行起来，然后他可以被内核调度系统去调度。说白了就是去调度器注册了一下，以后人家调度的时候会考虑你。

 

### 2.16.9.3、进程0、进程1、进程2

(1)截至目前为止，我们一共涉及到3个内核进程/线程。

(2)操作系统是用一个数字来表示/记录一个进程/线程的，这个数字就被称为这个进程的进程号。这个号码是从0开始分配的。因此这里涉及到的三个进程分别是linux系统的进程0、进程1、进程2.

(3)在linux命令行下，使用ps命令可以查看当前linux系统中运行的进程情况。

(4)我们在ubuntu下ps -aux可以看到当前系统运行的所有进程，可以看出进程号是从1开始的。为什么不从0开始，因为进程0不是一个用户进程，而属于内核进程。

(5)三个进程

进程0：进程0其实就是刚才讲过的idle进程，叫空闲进程，也就是死循环。

进程1：kernel_init函数就是进程1，这个进程被称为init进程。

进程2：kthreadd函数就是进程2，这个进程是linux内核的守护进程。这个进程是用来保证linux内核自己本身能正常工作的。

 

总结1：本节课的重点在于理解linux内核启动后达到的一个稳定状态。注意去对比内核启动后的稳定状态和uboot启动后的稳定状态的区别。

总结2：本节课的第二个重点就是初步理解进程/线程的概念。

总结3：你得明白每个进程有个进程号，进程号从0开始依次分配的。明白进程0是idle进程（idle进程是干嘛的）；进程2是ktheadd进程（基本明白干嘛的就行）。

总结4：分析到此，发现后续的料都在进程1.所以后面课程会重点从进程1出发，分析之后发生的事情。

 

 

## 2.16.10.init进程详解1

### 2.16.10.1、init进程完成了从内核态向用户态的转变

(1)init进程有2种状态：init进程刚开始运行的时候是内核态，它属于一个内核线程，然后他自己运行了一个用户态下面的程序后把自己强行转成了用户态。因为init进程自身完成了从内核态到用户态的过度，因此后续的其他进程都可以工作在用户态下面了。

(2)内核态下做了什么？重点就做了一件事情，就是挂载根文件系统并试图找到用户态下的那个init程序。init进程要把自己转成用户态就必须运行一个用户态的应用程序（这个应用程序名字一般也叫init），要运行这个应用程序就必须得找到这个应用程序，要找到它就必须得挂载根文件系统，因为所有的应用程序都在文件系统中。

内核源代码中的所有函数都是内核态下面的，执行任何一个都不能脱离内核态。应用程序必须不属于内核源代码，这样才能保证自己是用户态。也就是说我们这里执行的这个init程序和内核不在一起，他是另外提供的。提供这个init程序的那个人就是根文件系统。

 

(3)用户态下做了什么？init进程大部分有意义的工作都是在用户态下进行的。init进程对我们操作系统的意义在于：其他所有的用户进程都直接或者间接派生自init进程。

 

(4)如何从内核态跳跃到用户态？还能回来不？

init进程在内核态下面时，通过一个函数kernel_execve来执行一个用户空间编译连接的应用程序就跳跃到用户态了。

注意:这个跳跃过程中进程号是没有改变的，所以一直是进程1.这个跳跃过程是单向的，也就是说一旦执行了init程序转到了用户态下整个操作系统就算真正的运转起来了，以后只能在用户态下工作了，用户态下想要进入内核态只有走API这一条路了。

 

### 2.16.10.2、init进程构建了用户交互界面

(1)init进程是其他用户进程的老祖宗。linux系统中一个进程的创建是通过其父进程创建出来的。根据这个理论只要有一个父进程就能生出一堆子孙进程了。

(2)init启动了login(用户登录)进程、命令行进程、shell进程

(3)shell进程启动了其他用户进程。命令行和shell一旦工作了，用户就可以在命令行下通过./xx的方式来执行其他应用程序，每一个应用程序的运行就是一个进程。

 

总结：本节的主要目的是让大家认识到init进程如何一步步发展成为我们平时看到的那种操作系统的样子。

 

 

## 2.16.11.init进程详解2

### 2.16.11.1、打开控制台

(1)linux系统中每个进程都有自己的一个文件描述符表，表中存储的是本进程打开的文件。

(2)linux系统中有一个设计理念：一切届是文件。所以设备也是以文件的方式来访问的。我们要访问一个设备，就要去打开这个设备对应的文件描述符。譬如/dev/fb0这个设备文件就代表LCD显示器设备，/dev/buzzer代表蜂鸣器设备，/dev/console代表控制台设备。

(3)这里我们打开了/dev/console文件，并且复制了2次文件描述符，一共得到了3个文件描述符。这三个文件描述符分别是0、1、2.这三个文件描述符就是所谓的：标准输入、标准输出、标准错误。

(4)进程1打开了三个标准输出输出错误文件，因此后续的进程1衍生出来的所有的进程默认都具有这3个三件描述符。

 

### 2.16.11.2、挂载根文件系统

(1)prepare_namespace函数中挂载根文件系统

(2)根文件系统在哪里？根文件系统的文件系统类型是什么？ uboot通过传参来告诉内核这些信息。

uboot传参中的root=/dev/mmcblk0p2 rw 这一句就是告诉内核根文件系统在哪里

uboot传参中的rootfstype=ext3这一句就是告诉内核rootfs的类型。

(3)如果内核挂载根文件系统成功，则会打印出：VFS: Mounted root (ext3 filesystem) on device 179:2.

如果挂载根文件系统失败，则会打印：No filesystem could mount root, tried: yaffs2

(4)如果内核启动时挂载rootfs失败，则后面肯定没法执行了，肯定会死。内核中设置了启动失败休息5s自动重启的机制，因此这里会自动重启，所以有时候大家会看到反复重启的情况。

(5)如果挂载rootfs失败，可能的原因有：

​    最常见的错误就是uboot的bootargs设置不对。

​    rootfs烧录失败（fastboot烧录不容易出错，以前是手工烧录很容易出错）

​    rootfs本身制作失败的。（尤其是自己做的rootfs，或者别人给的第一次用）

 

### 2.16.11.3、执行用户态下的进程1程序

(1)上面一旦挂载rootfs成功，则进入rootfs中寻找应用程序的init程序，这个程序就是用户空间的进程1.找到后用run_init_process去执行他

(2)我们如果确定init程序是谁？方法是：

先从uboot传参cmdline中看有没有指定，如果有指定先执行cmdline中指定的程序。cmdline中的init=/linuxrc这个就是指定rootfs中哪个程序是init程序。这里的指定方式就表示我们rootfs的根目录下面有个名字叫linuxrc的程序，这个程序就是init程序。

如果uboot传参cmdline中没有init=xx或者cmdline中指定的这个xx执行失败，还有备用方案。第一备用：/sbin/init，第二备用：/etc/init，第三备用：/bin/init，第四备用：/bin/sh。

如果以上都不成功，则认命了，死了。

 

### 2.16.11.4终端(terminal)、tty、shell、控制台（console）、bash之间的区别与联系

**1****、终端（terminal）**

终端（termimal）= tty（Teletypewriter， 电传打印机），作用是提供一个命令的输入输出环境，在linux下使用组合键ctrl+alt+T打开的就是终端，可以认为terminal和tty是同义词。

 

**2****、shell**

shell是一个命令行解释器，是linux内核的一个外壳,负责外界与linux内核的交互。shell接收用户或者其他应用程序的命令, 然后将这些命令转化成内核能理解的语言并传给内核, 内核执行命令完成后将结果返回给用户或者应用程序。当你打开一个terminal时，操作系统会将terminal和shell关联起来，当我们在terminal中输入命令后，shell就负责解释命令。

 

**3****、console**

在计算机发展的早期，计算机的外表上通常会存在一个面板，面板包含很多按钮和指示灯，可以通过面板来对计算机进行底层的管理，也可以通过指示灯来得知计算机的运行状态，这个面板就叫console。在现代计算机上，在电脑开机时（比如ubuntu）屏幕上会打印出一些日志信息，但在系统启动完成之前，terminal不能连接到主机上，所以为了记录主机的重要日志（比如开关机日志，重要应用程序的日志），系统中就多了一个名为console的设备，这些日志信息就是显示在console上。一台电脑有且只有一个console，但可以有多个terminal。举个例子，电视机上的某个区域一般都会有一些按钮，比如开机，调音量等，这个区域就可以当做console，且这个区域在电视上只有一个，遥控器就可以类比成terminal，terminal可以有多个。

 

**4****、bash**

linux系统上可以包含多种不同的shell(可以使用命令 cat /etc/shells 查看)，比较常见的有Bourne shell (sh)、C shell (csh) 和 Korn shell (ksh)，三种shell 都有它们的优点和缺点。Bourne shell 的作者是 Steven Bourne，它是 UNIX 最初使用的shell 并且在每种 UNIX 上都可以使用。bash的全称叫做Bourne Again shell，从名字上可以看出bash是Bourne shell的扩展，bash 与 Bourne shell 完全向后兼容，并且在 Bourne shell 的基础上增加和增强了很多特性，如命令补全、命令编辑和命令历史表等功能，它还包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。总而言之，bash是shell的一种，是增强的shell。

 

5、参考：

1、https://www.zhihu.com/question/21711307

 

2、https://blog.csdn.net/wenlifu71022/article/details/4069929

 

3、https://www.zhihu.com/question/20388511

 

转载于:https://www.cnblogs.com/sench/p/8920292.html

 

## 2.16.12.cmdline常用参数

### 2.16.12.1、格式简介

(1)格式就是由很多个项目用空格隔开依次排列，每个项目中都是项目名=项目值

(2)整个cmdline会被内核启动时解析，解析成一个一个的项目名=项目值的字符串。这些字符串又会被再次解析从而影响启动过程。

### 2.16.12.2、root=

(1)这个是用来指定根文件系统在哪里的

(2)一般格式是root=/dev/xxx（一般如果是nandflash上则/dev/mtdblock2，如果是inand/sd的话则/dev/mmcblk0p2）

(3)如果是nfs的rootfs，则root=/dev/nfs。 这种是网络文件系统。

 

### 2.16.12.3、rootfstype=

(1)根文件系统的文件系统类型，一般是jffs2、yaffs2、ext3、ubi

### 2.16.12.4、console=

(1)控制台信息声明，譬如console=/dev/ttySAC0,115200表示控制台使用串口0，波特率是115200.

(2)正常情况下，内核启动的时候会根据console=这个项目来初始化硬件，并且重定位console到具体的一个串口上，所以这里的传参会影响后续是否能从串口终端上接收到内核的信息。

 

### 2.16.12.5、mem=

(1)mem=用来告诉内核当前系统的内存有多少

 

### 2.16.12.6、init=

(1)init=用来指定进程1的程序pathname，一般都是init=/linuxrc

 

### 2.16.12.7、常见cmdline介绍

(1)console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3

第一种这种方式对应rootfs在SD/iNand/Nand/Nor等物理存储器上。这种对应产品正式出货工作时的情况。

 

(2)root=/dev/nfs nfsroot=192.168.1.141:/root/s3c2440/build_rootfs/aston_rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0,115200 

第二种这种方式对应rootfs在nfs上，这种对应我们实验室开发产品做调试的时候。

 

 

## 2.16.13.内核中架构相关代码简介

### 2.16.13.1、内核代码基本分为3块

(1)arch。    本目录下全是cpu架构有关的代码

(2)drivers    本目录下全是硬件的驱动

(3)其他     相同点是这些代码都和硬件无关，因此系统移植和驱动开发的时候这些代码几乎都是不用关注的。

 

### 2.16.13.2、架构相关的常用目录名及含义（arch目录下）

(1)mach：（mach就是machine architecture）。arch/arm目录下的一个mach-xx目录就表示一类machine的定义，这类machine的共同点是都用xx这个cpu来做主芯片。（譬如mach-s5pv210这个文件夹里面都是s5pv210这个主芯片的开发板machine）；mach-xx目录里面的一个mach-yy.c文件中定义了一个开发板（一个开发板对应一个机器码），这个是可以被扩展的。

(2)plat：（plat是platform的缩写，含义是平台）plat在这里可以理解为SoC，也就是说这个plat目录下都是SoC里面的一些硬件（内部外设）相关的一些代码。

在内核中把SoC内部外设相关的硬件操作代码就叫做平台设备驱动。

(3)include：这个include目录中的所有代码都是架构相关的头文件。（linux内核通用的头文件在内核源码树根目录下的include目录里）。

 

### 2.16.13.3、补充

(1)内核中的文件结构很庞大、很凌乱（不同版本的内核可能一个文件存放的位置是不同的），会给我们初学者带来一定的困扰。

(2)头文件目录include有好几个，譬如：

​        kernel/include       内核通用头文件

​        kernel/arch/arm/include       架构相关的头文件

​       kernel/arch/arm/include/asm

​       kernel\arch\arm\include\asm\mach

​        kernel\arch\arm\mach-s5pv210\include\mach

​        kernel\arch\arm\plat-s5p\include\plat

(3)内核中包含头文件时有一些格式

 

\#include <linux/kernel.h>       kernel/include/linux/kernel.h

\#include <asm/mach/arch.h>    kernel/arch/arm/include/asm/mach/arch.h

\#include <asm/setup.h>        kernel\arch\arm\include\asm/setup.h

\#include <plat/s5pv210.h>      kernel\arch\arm\plat-s5p\include\plat/s5pv210.h

 

(4)有些同名的头文件是有包含关系的，有时候我们需要包含某个头文件时可能并不是直接包含他，而是包含一个包含了他的头文件。

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

# 第十七章 内核的移植1-从三星官方内核开始移植

## 2.17.0 章节概要

**2.17.1.内核移植初体验**

​    本节为内核移植的第一节，首先选定好待移植的源码，然后构建移植环境，并且进行基本的修改和配置编译，再根据实验现象进行后续步骤

**2.17.2.初步移植以看到启动信息** 

​    本节课根据上节的实验结果来分析问题并且尝试解决问题，最终达到让内核启动信息可以打印出来。

**2.17.3.内核中机器码的确定**

​    本节讲解内核中各mach-xx的机器码是如何确定的，借此分析找到我们的平台对应的硬件初始化代码的位置。

**2.17.4.解决内核启动中的错误**

​    本节课引入内核错误OOPS，然后分析如何从内核oops信息中找到解决问题的线索并且解决启动中的问题。

**2.17.5.iNand的问题和安排**

​    本节分析iNand的问题和不能挂载rootfs的原因，因为时间关系这个问题暂时没能处理，要等到后面驱动部分开始时再去补上。

**2.17.6.网卡驱动的移植和添加实验**

​    本节课讲述网卡驱动的移植，主要目的是通过移植让大家初步认识到linux中的驱动框架、驱动与数据相隔离的思想，内核驱动和uboot中驱动的相同点和不同点等。

**2.17.7.内核启动第一阶段的调试方法** 

​    本节补充讲一下内核的一些调试手法，主要目的是为大家提升下调试技巧，提升学习动手能力。

 

## 2.17.1.内核移植初体验

### 2.17.1.1、三星官方移植版内核获取

(1)从网盘下载源码包。

(2)这个文件最初是来自于三星的SMDKV210开发板附带的光盘资料。

### 2.17.1.2、构建移植环境

(1)Windows下建立SI工程

(2)ubuntu下解压

 

### 2.17.1.3、配置编译下载尝试

(1)检查Makefile中ARCH和CROSS_COMPILE

(2)make xx_defconfig

(3)make menuconfig

(4)make -j4

默认情况下直接make则会直接单线程编译。但是如果make -j4则会4线程编译。

 

### 2.17.1.4、后续要做的事情：

(1)编译得到的zImage去下载运行，看结果

(2)根据结果去分析问题原因，然后去尝试解决这些问题。

 

 

## 2.17.2.初步移植以看到启动信息

### 2.17.2.1、分析问题

(1)根据运行结果，分析发现：linux内核的自解压代码都没有运行（因为没有看到：Uncompressing Linux... done, booting the kernel.）

(2)说明zImage根本没有被解压成功，内核代码根本就没有被运行，当然没有输出信息了。所以问题出在解压相关的部分。

(3)问题出在内核配置的解压后代码放置的内存地址处。

(4)内核配置的解压地址应该等于连接地址，否则自解压之后内核无法运行。现在问题变成：第一，内核的连接地址等于多少？第二，内核中配置的解压地址是多少？

(5)这里面还有个问题：内核的连接地址是一个虚拟地址，而自解压代码解压内核时需要物理地址，因此上面说的等于，其实是连接地址对应的物理地址等于自解压地址。

(6)连接地址和他对应的物理地址在head.S中可以查到，分别是0xC0008000和0x30008000。那么自解压代码配置的解压地址应该是30008000.

(7)自解压代码对应的自解压地址在mach/Makefile.boot文件中。在其中修改，加入两行：

\# override for SMDKV210

zreladdr-$(CONFIG_MACH_SMDKV210)    := 0x30008000

params_phys-$(CONFIG_MACH_SMDKV210)   := 0x30000100

(8)同步代码，并且编译，得到的zImage复制到/tftpboot，然后重新下载运行查看结果。

(9)结果就是：还是没运行，但是有效果。自解压代码解压打印信息已经出来了。但是内核还没运行

 

### 2.17.2.2、问题分析

android-kernel-samsung-dev/arch/arm/mach-s5pv210/include/mach/memory.h中

 

(1)定义的物理地址不对，从20000000改到30000000即可

 

 

## 2.17.3.内核中机器码的确定

### 2.17.3.1、MACHINE_START宏

(1)这个宏用来定义一个机器码的数据结构的。这个宏的使用其实是用来定义一个结构体类型为machine_desc类型的结构体变量，名为__mach_desc_SMDKV210。这个结构体变量会被定义到一个特定段.arch.info.init，因此这个结构体变量将来会被链接器链接到这个.arch.info.init段中。

 

static const struct machine_desc __mach_desc_SMDKV210  \

 __used             \

 __attribute__((__section__(".arch.info.init"))) = {  \

  .nr   = MACH_TYPE_SMDKV210,    \

  .name    = "SMDKV210",

  .phys_io  = S3C_PA_UART & 0xfff00000,

  .io_pg_offst  = (((u32)S3C_VA_UART) >> 18) & 0xfffc,

  .boot_params  = S5P_PA_SDRAM + 0x100,

  .init_irq  = s5pv210_init_irq,

  .map_io   = smdkv210_map_io,

  .init_machine  = smdkv210_machine_init,

  .timer   = &s5p_systimer,

};

 

 (2)经过分析，发现一个mach-xxx.c文件中定义了一个机器码的开发板的machine_desc结构体变量，这个结构体变量放到.arch.info.init段中后，那么就表示当前内核可以支持这个机器码的开发板。

(3)落实到当前开发板和当前内核中来分析，当前我们移植的目标开发板使用S5PV210的CPU，开发板名字叫X210.我们在三星官方版本的内核中是找不到mach-x210.c的，所以我们又不想从零开始去移植，因此我们的思路是在三星移植的mach-s5pv210目录下找一个mach-xx.c，这个开发板和我们的X210开发板最为接近，然后以此为基础来移植。

(4)经过查看，发现mach-s5pc110.c和mach-s5pv210.c和我们的X210开发板最为接近。我们一般确定的一个**移植思路原则**是：看我们的开发板和三星官方的哪个开发板最为相似。我们的X210开发板抄的是三星的SMDKV210，因此要找这个对应的那个文件。

(5)结合mach-s5pv210目录下的Makefile来分析，得知.config中定义了CONFIG_MACH_SMDKV210后，实际绑定的是mach-smdkc110.c这个文件。所以实际上mach-smdkv210.c这个文件根本没用到。给我们的启示就是不要光看名字。

 

### 2.17.3.2、硬件驱动的加载和初始化函数执行

(1).init_machine = smdkc110_machine_init,

(2)这个元素定义了一个机器硬件初始化函数，这个函数非常重要，这个函数中绑定了我们这个开发板linux内核启动过程中会初始化的各种硬件的信息。

 

 

## 2.17.4.解决内核启动中的错误

### 2.17.4.1、认识内核启动OOPS

(1)内核启动后会有打印信息，打印信息中隐藏了问题所在。认真的去分析这个打印信息，从中找到对的或者错误的一些信息片段，才能帮助我们找到问题，从而解决问题。

(2)内核启动中的错误信息有一些特征：

Unable to handle kernel NULL pointer dereference at virtual address 00000060

Internal error: Oops: 5 [#1] PREEMPT

PC is at dev_driver_string+0xc/0x44

LR is at max8698_pmic_probe+0x150/0x32c

(3)从以上错误信息中的PC和LR的值可以看出，程序是执行到dev_driver_string或者max8698_pmic_probe（这两个是函数或者汇编中的标号）符号部分的时候出错了。我们就从这两个符号出发去寻找、思考可能出错的地方然后试图去解决。

（4）当看到内核启动信息Oops的时候就说明内核启动失败了，而且失败的错误信息就在附近。

 

### 2.17.4.2、错误追溯及问题解决

(1)max8698_pmic_probe（power manger IC）看名字是max8698这个电源管理IC的驱动安装函数部分出错了，应该是我们的开发板系统中配置了支持这个电源管理IC，于是乎启动时去加载他的驱动，结果驱动在加载执行的过程中出错了OOPS了。

(2)我们为什么要配置支持这个驱动？这个驱动加载为什么要出错？

(3)结合我们X210开发板的硬件实际情况来分析：我们X210开发板上根本就没有max8698这个电源管理IC，既然硬件都没有驱动执行了肯定会出错。

(4)回忆当时从三星版本的uboot移植的时候，在uboot的lowlevel_init.S中也有调用个电源管理IC初始化函数（PMIC_init），后来解决的办法就是屏蔽掉了这个函数的调用，uboot就成功运行下去了。

(5)为什么我们的uboot和内核中默认都调用了这个电源管理IC的初始化代码？原因就是三星的SMDKV210开发板中是用了max8698这个电源管理IC的，所以三星的uboot和kernel中都有默认支持这个。但是X210中是没用的，因此都需要去掉。

(6)怎么解决？在uboot中是直接改源代码屏蔽掉那个初始化函数解决的；在内核中不能这么干？因为linux kernel是高度模块化高度可配置的，内核中每一个模块都是被配置项条件编译了的，因此要去掉某个模块的支持，只需要重新配置去掉选项即可，不用改源代码。所以我们的关键就是要找它对应的配置项。

(7)我们做法：make menuconfig，然后/搜索"MAX8698"这几个关键字，然后看到这个配置项的路径，然后到路径下去按N键去掉这个模块的支持，保存，重新编译即可。

 

(8)实践证明问题被解决了，而且内核再次启动后直接运行到挂载rootfs才出错。

 

 

### 2.17.4.3、分析及总结

(1)分析：问题究竟是怎么被解决的？涉及哪几个方面

根本原因在于CONFIG_MFD_MAX8698这个配置宏。这个配置宏决定了很多东西;

第一：这个配置宏决定了drivers目录下的max8698对应的驱动程序源代码是否被编译;

第二：这个配置宏决定了kernel启动过程中是否会调用一些max8698的相关的代码;

 

(2)总结：kernel是高度模块化和可配置化的，所以在内核中做任何事情（添加一个模块、更改一个模块、去掉一个模块）都必须按照内核设定的方案和流程来走。

 

 

## 2.17.5.iNand的问题和安排

### 2.17.5.1、错误分析

(1)得到的内核错误信息：Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)。从错误信息字面意思来分析，就是内核试图挂载根文件系统时失败，失败的原因是unknown-block（不能识别的块设备）

(2)backstrace分析，可以得知错误信息的来源，再结合之前的内核启动流程分析，就更加确定了出错的地方。

(3)下一个问题：分析这个错误出现的原因。unknown-block(0,0)。在kernel启动时uboot会传给内核一个cmdline，其中用root=xx来指定了rootfs在哪个设备上，内核就会到相应的地方去挂载rootfs。譬如我们传参中：root=/dev/mmcblk0p2，这里的/dev/mmcblk0p2就是rootfs的设备地址，这个设备文件编号的含义就是mmc设备0的第2个分区（设备0就是在SD0通道上的设备，也就是iNand），这里的问题就是没找到mmc设备0的第2分区。

(4)下一步问题：为什么没找到mmc设备0的第2分区。一定是因为kernel启动过程中加载mmc驱动的时候有问题，驱动没有发现mmc设备0.问题定位在MMC相关的驱动方面。

(5)对比九鼎版本的内核启动信息，即可发现我们的内核启动并没有找到MMC设备（内置的iNand和外置的SD卡都没找到），没找到肯定是驱动的问题，这就要去移植MMC驱动了。

 

### 2.17.5.2、问题阐述

(1)SD/iNand本身都是由一个一个的扇区组成的，回忆裸机中讲到的210的启动时，BL1在SD卡的1扇区开始往后存放，SD卡的0扇区是不用的。SD卡的0扇区是用来放置MBR的。

(2)MBR就是用来描述块设备的分区信息的，事先定义了一个通用的数据结构来描述块设备的分区，我们只要按照这个标准将分区信息写入MBR中即可对该设备完成分区。MBR默认就是在块设备的第0个扇区上存放的。

(3)我们内核中读到iNand分4个分区，我们哪里分区的？uboot中有一个命令fdisk -c 0时就对iNand进行了分区。uboot的fdisk命令内部已经写死了iNand的分区表，到内核中时内核直接读取MBR就知道了分区。所以在uboot和内核之间iNand设备的分区信息是靠iNand自己传递的，所以uboot不用给内核传参时传递分区表信息。

(4)如果开发板用的是nandFlash的话，分区表一般是在内核中自己用代码构建的。所以nand版本的内核移植的时候一般都需要去移植更改nand分区表。

 

### 2.17.5.3、解决安排

(1)暂时解决不了这个问题。

 

### 2.17.5.4、后续课程安排

(1)一节课搞定网卡驱动的移植，一节课讲述一些内核移植的小方法和技巧，然后课程结束

(2)整体移植的课程结束，进入根文件系统部分。

 

 

 

## 2.17.6.网卡驱动的移植和添加实验

### 2.17.6.1、移植标准

(1)网卡驱动移植ok时，启动信息为：

[  1.452008] dm9000 Ethernet Driver, V1.31

[  1.455870] eth0: dm9000c at e08f4300,e08f8304 IRQ 42 MAC: 00:09:c0:ff:ec:48 (platform data)

(2)当前内核中网卡驱动尚未移植，因此内核启动时有错误的打印信息：

[  1.130308] dm9000 Ethernet Driver, V1.31

[  1.133113] ERROR : resetting 

[  1.135700] dm9000 dm9000.0: read wrong id 0x2b2a2928

[  1.140915] dm9000 dm9000.0: read wrong id 0x2b2a2928

[  1.145941] dm9000 dm9000.0: read wrong id 0x2b2a2928

[  1.150963] dm9000 dm9000.0: read wrong id 0x2b2a2928

[  1.155992] dm9000 dm9000.0: read wrong id 0x2b2a2928

[  1.161018] dm9000 dm9000.0: read wrong id 0x2b2a2928

[  1.166041] dm9000 dm9000.0: read wrong id 0x2b2a2928

[  1.171070] dm9000 dm9000.0: read wrong id 0x2b2a2928

[  1.176092] dm9000 dm9000.0: wrong id: 0x2b2a2928

[  1.180774] dm9000 dm9000.0: not found (-19).

(3)移植的目标就是让我们的版本的内核可以打印出正确情况下的启动信息，那我们就相信内核启动后网卡是可以工作的。

 

### 2.17.6.2、make menuconfig中添加DM9000支持

(1)menuconfig中选择Y

(2)其实这一步本来就是Y，所以在我们这里是不用管的。但是你自己遇到的一个内核可能默认不是Y，因此要设置。

 

### 2.17.6.3、mach-smdkc110.c中逻辑分析

(1)mach-smdkc110.c中的smdkc110_machine_init是整个开发板的所有硬件的初始化函数，在这里加载了的硬件将来启动时就会被初始化，在这里没有的将来启动时就不管。

(2)smdkc110_devices和smdkc110_dm9000_set()这两个地方是和DM9000有关的，要分别去做移植。

(3)smdkc110_dm9000_set这个函数就是DM9000相关的SROM bank的寄存器设置，相当于uboot中dm9000移植时的dm9000_pre_init函数,只是读写寄存器的函数名称不同了。

 

### 2.17.6.4、修改相应的配置参数

(1)DM9000相关的数据配置在arch/arm/plat-s5p/devs.c中更改

(2)在arch/arm/mach-s5pv210/include/mach/map.h中定义了DM9000的IO基地址，和DM9000接在哪个bank有关。

(3)还有+2改成+4，IRQ_EINT9改成10即可。



 

### 2.17.6.5、代码实践

(1)同步代码、编译生成zImage

(2)下载启动后看启动信息。

 

 

## 2.17.7.内核启动第一阶段的调试方法

### 2.17.7.1、问题点描述

(1)内核启动在head.S中首先进行了三个校验（CPU id的校验、机器码的校验、tag的校验），然后创建页表，然后做了一些不太会出错的事情，然后b start_kernel。基本上能运行到start_kernel内核移植就不太会出问题了。

(2)有时候移植的内核启动后的现象是：根本没有启动信息出来。这时候有可能是内核启动运行了但是运行出错了没启动起来所以没有打印信息；也有可能是内核根本没得以运行。都有可能但是没法确定。我们希望能有一种调试手段来确定问题所在。

 

### 2.17.7.2、调试方法和原理

(1)调试方法就是在内核启动的第一阶段添加汇编操作led点亮/熄灭的方法来标明代码运行的轨迹。

(2)我们找之前裸机中汇编操作led点亮/熄灭的代码过来，复制粘贴到head.S中合适位置。然后内核启动后根据led的表现来标明代码有无运行。

 

### 2.17.7.3、动手测试

(1)整理好led操作的代码段，在head.S中合适的地方添加led这个函数，然后在head.S的内核起始运行阶段添加调用led函数，然后重新编译内核，运行内核看这段代码有无被运行。

(2)如果被运行了，证明在这个调用led的步骤之前的部分都是没问题的，那么如果有错肯定错误在后边；如果没有被运行则证明错误在之前，那么就要去之前的部分debug。

 

### 2.17.7.4、实验验证

bl1:

  ldr r3, =0x11111111   

  ldr r4, =0xE0200240     

str r3, [r4] 

​       

  ldr r3, =0x0

  ldr r4, =0xE0200244

str r3, [r4]

  moc pc lr

 

​      为什么要用r3,r3 因为在head.S 中，r0,r1… 一些寄存器被用来干别的事了，这时候要是胡乱用他们，有可能会导致出错。

 

 

 

 

 

 

 

 

 

 

 



 

# 第十八章 根文件系统的原理

## 2.18.0 章节概要

**2.18.1.根文件系统概述**

​    本节课对根文件系统进行概述，主要讲述了根文件系统存在的意义和根文件系统的物理本质。

**2.18.2.根文件系统的形式**

​    本节课探讨根文件系统的两种形态：烧录镜像形式和文件夹形式，试图从这个出发点让大家加深对根文件系统的本质的理解。

**2.18.3.自己制作ext3格式的根文件系统**

​    本节将自己制作一个最简易的ext3格式的rootfs，然后fastboot烧写启动去挂载执行，通过这个小实验让大家消除对rootfs的陌生感。

**2.18.4.nfs方式启动自制简易文件夹形式的rootfs**

​    本节将配置内核支持nfs启动挂载rootfs，并且自己做一个简单的文件夹作为根文件系统，其中涉及到nfs服务器搭建等细节问题。

**2.18.5.到底什么是linuxrc**

​    本节对linuxrc文件的本质进行探索，引出busybox，让大家对根文件系统的重点busybox的意义有所了解。

**2.18.6.rootfs中还应该有什么**

​    本节继续对rootfs进行扩展，讲解了rootfs中还应该有，或者说还可以有的一些内容，譬如运行时配置文件、开机自启动程序等。

**2.18.7.VFS简介**

​    本节对linux内核的VFS机制做简单引入，让大家了解到内核中VFS层的目的和意义，这对后面学习应用和驱动的对应调用做了一定铺垫。

​    

## 2.18.1.根文件系统概述

### 2.18.1.1、为什么需要根文件系统

(1)init进程的应用程序在根文件系统上

(2)根文件系统提供了根目录/

(3)内核启动后的应用层配置(etc目录)在根文件系统上。几乎可以认为：发行版=内核+rootfs

(4)shell命令程序在根文件系统上。譬如ls、cd等命令

总结：一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、/bin /sbin等目录下的shell命令，还有/lib目录下的库文件等···）相配合才能工作。

 

### 2.18.1.2、根文件系统的实质是什么

(1)根文件系统是特殊用途的文件系统。根文件系统它也是一种文件系统。

(2)根文件系统也必须属于某种文件系统格式。rootfstype=

(3)究竟文件系统是用来干嘛的。ZnFAT

首先，存储设备（块设备，像硬盘、flash等）是分块（扇区）的，物理上底层去访问存储设备时是按照块号（扇区号）来访问的。这就很麻烦。

其次，文件系统是一些代码，是一套软件，这套软件的功能就是对存储设备的扇区进行管理，**将这些扇区的访问变成了对目录和文件名的访问**。我们在上层按照特定的目录和文件名去访问一个文件时，文件系统会将这个目录+文件名转换成对扇区号的访问。

最后，不同的文件系统的差异就在于对这些扇区的管理策略和方法不同，譬如坏块管理、碎片管理。

 

 

## 2.18.2.根文件系统的形式

### 2.18.2.1、镜像文件形式

(1)使用专用工具软件制作的可供烧录的镜像文件

(2)镜像中包含了根文件系统中的所有文件

(3)烧录此镜像类似于对相应分区格式化。

(4)镜像文件系统具有一定的格式，格式是内化的，跟文件名后缀是无关的。

### 2.18.2.2、文件夹形式

(1)根文件系统其实就是一个包含特定内容的文件夹而已

(2)根文件系统可由任何一个空文件夹添加必要文件构成而成

(3)根文件系统的雏形就是在开发主机中构造的文件夹形式的

### ·2.18.2.3、

(1)镜像文件形式的根文件系统主要目的是用来烧录到块设备上，设备上的内核启动后去挂载它。镜像文件形式的根文件系统是由文件夹形式的根文件系统使用专用的镜像制作工具制作而成的。

(2)最初在开发主机中随便mkdir创建了一个空文件夹，然后向其中添加一些必要的文件（包括etc目录下的运行时配置文件、/bin等目录下的可执行程序、/lib目录下的库文件等···）后就形成了一个文件夹形式的rootfs。然后这个文件夹形式的rootfs可以被kernel通过nfs方式来远程挂载使用，但是不能用来烧录块设备。我们为了将这个rootfs烧录到块设备中于是用一些专用的软件工具将其制作成可供烧录的一定格式的根文件系统镜像。

(3)文件夹形式的rootfs是没有格式的，制作成镜像后就有了一定的rootfs格式了，格式是由我们的镜像制作过程和制作工具来决定的。每一种格式的镜像制作工具的用法都不同。

## 2.18.3.自己制作ext3格式的根文件系统

### 2.18.3.1、mke2fs介绍

(1)mke2fs是一个应用程序，在ubuntu中默认是安装了的。这个应用程序就是用来制作ext2、ext3、ext4等格式的根文件系统的。

(2)一般用来制作各种不同格式的rootfs的应用程序的名字都很相似，类似于mkfs.xxx（譬如用来制作ext2格式的rootfs的工具叫mkfs.ext2、用来制作jffs2格式的rootfs的工具就叫mkfs.jffs2）。

(3)ubuntu14.04中的mkfs.ext2等都是mke2fs的符号链接而已。

 

### 2.18.3.2、动手制作ext2格式的根文件系统

(1)创建rootfs.ext2文件并且将之挂载到一个目录下方便访问它

《参考资料：http://blog.csdn.net/zhengmeifu/article/details/24174513》

dd if=/dev/zero of=rootfs.ext2 bs=1024 count=2048

losetup /dev/loop23 rootfs.ext2  //ls /dev/loop* 查看，loop后面的数字得没用过才行

mke2fs -m 0 /dev/loop23 2048

mount -t ext2 /dev/loop23 ./rootfs

(2)我们向镜像中写入一个普通文件linuxrc。这个文件就会成为我们制作的镜像中的/linuxrc。内核挂载了这个镜像后就会尝试去执行/linuxrc。然后执行时必然会失败。我们将来实验看到的现象就应该是：挂载成功，执行/linuxrc失败。

(3)将来真正去做有用的rootfs时，就要在这一步添加真正可以执行的linuxrc程序，然后还要添加别的/lib目录下的库文件，/etc目录下的配置文件等。

(4)卸载掉，然后镜像就做好了。

umount /dev/loop23



losetup -d /dev/loop1

 

### 2.18.3.2、动手制作ext3/4格式的根文件系统

1.生成一个空的2MiB文件

dd if=/dev/zero of=rootfs.ext3 bs=1024 count=2048 (指定每一块大小为1024字节，一共又2048块，那么就是2048 * 1024 B = 2MiB)

2.对生成的文件进行格式化

 

mkfs.ext3 rootfs.ext3

3.挂载此空镜像

mount -o loop rootfs.ext3 ./rootfs

4.向挂载好的文件系统中写入需要加入的文件

cp everyfile ./rootfs

5.卸载根文件系统(意味着镜像已经制作完成)

umount  ./rootfs

6.将镜像写入sd卡的某个分区中

dd if=rootfs.ext4 of=/dev/mmcblk0p3 



 

 

注：制作ext4 和ext3 步骤一样，只需要将3给为4即可。

来源：https://www.cnblogs.com/dakewei/p/10150984.html

### 2.18.3.3、烧录制作的rootfs.ext3

(1)烧录过程参考裸机中第三部分的刷机过程。注意bootargs传参设置

bootargs=console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3



### 2.18.3.4、分析和总结

  、初始化1进程失败，说明实验成功了。

 

## 2.18.4.nfs方式启动自制简易文件夹形式的rootfs

### 2.18.4.1、什么是nfs

(1)nfs是一种网络通讯协议，由服务器和客户端构成。

(2)nfs的作用：利用nfs协议可以做出很多直接性应用，我们这里使用nfs主要是做rootfs挂载。

开发板中运行kernel做nfs客户端，主机ubuntu中搭建nfs服务器。在主机ubuntu的nfs服务器中导出我们制作的文件夹形式的rootfs目录，则在客户端中就可以去挂载这个文件夹形式的rootfs进而去启动系统。

(3)搭建nfs服务器

 

一 安装 **NFS
** **$ sudo apt-get install nfs-kernel-server
 $ sudo apt-get install nfs-common**
 二 配置**/etc/exports
** **$ sudo vi /etc/exports
** 文本末添加
 /root/rootfs *(rw,sync,no_root_squash,no_subtree_check) 注：文件夹选自己挂在的，不要照抄
 然后在终端执行 **$chmod 777 -R /root/rootfs
 $ sudo showmount -e
** 显示 clnt-create : RPC : Program not registered
 $ **sudo exportfs -r** 更新
 **$ sudo showmount localhost -e
** 显示
 /root/rootfs *


 三 启用
 **$ sudo /etc/init.d/nfs-kernel-server restart** 重启 nfs 服务
 显示如下
 \* Stopping NFS kernel daemon [ OK ]
 \* Unexporting directories for NFS kernel daemon... [ OK ]
 \* Exporting directories for NFS kernel daemon... [ OK ]
 \* Starting NFS kernel daemon [ OK ]
 挂载测试
 **$ mount -t nfs -o nolock localhost:/root/rootfs /mnt****（自己创建的文件夹，不要照抄）****
** 执行后，进入/mnt 目录中，如果可以看到/root/rootfs 中的内容，则说明 nfs 搭建成功！

示例：sudo mount -t nfs -o nolock 192.168.1.141:/usr/local/x210_learning/divers/rootfs/rootfs /opt

### 2.18.4.2、配置内核以支持nfs作为rootfs

(1)设置nfs启动方式的bootargs

//nfs 方式启动的bootargs

setenv bootargs root=/dev/nfs nfsroot=192.168.1.141:/root/rootfs  ip=192.168.1.20:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off init/linuxrc console=ttySAC2,115200



 

 (2)在menuconfig中配置支持nfs启动方式

 

**配置：**

 

 

 

 

 

### 2.18.4.3、无法通过nfs挂载ubuntu18.04中的根文件系统

 

无法通过nfs挂载ubuntu18.04中的根文件系统

在uboot中设置bootargs

set bootargs root=/dev/nfs nfsroot=192.168.0.8:/home/eker/nfsroot ip=192.168.0.210 console=ttySAC0,115200

引导内核后通过nfs挂载网络根文件系统时出现图1所示错误。

   

 

经过各种试验发现是nfs服务的问题。

原因是：ubuntu18.04只支持nfs 3和nfs 4，而uboot默认使用nfs 2。

解决方法：

在ubuntu18.04的 “/etc/default/nfs-kernel-server” 文件末尾加一行，如图2所示。

RPCNFSDOPTS="--nfs-version 2,3,4 --debug --syslog"

   

 

然后重启nfs服务即可。

sudo /etc/init.d/nfs-kernel-server restart



 作者：飞哥物联
 链接：https://www.jianshu.com/p/10e3245f15f3
 来源：简书
 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

 

### 2.18.4.3、总结

(1)nfs方式启动相当于开发板上的内核远程挂载到主机上的rootfs

(2)nfs方式启动不用制作rootfs镜像

(3)nfs方式不适合真正的产品，一般作为产品开发阶段调试使用

 

 

## 2.18.5.到底什么是linuxrc

### 2.18.5.1、/linuxrc是一个可执行的应用程序

(1)/linuxrc是应用层的，和内核源码一点关系都没有

(2)/linuxrc在开发板当前内核系统下是可执行的。因此在ARM SoC的linux系统下，这个应用程序就是用arm-linux-gcc编译链接的；如果是在PC机linux系统下，那么这个程序就是用gcc编译连接的。

(3)/linuxrc如果是静态编译连接的那么直接可以运行；如果是动态编译连接的那么我们还必须给他提供必要的库文件才能运行。但是因为我们/linuxrc这个程序是由内核直接调用执行的，因此用户没有机会去导出库文件的路径，因此实际上这个/linuxrc没法动态连接，一般都是静态连接的。

 

### 2.18.5.2、/linuxrc执行时引出用户界面

(1)操作系统启动后在一系列的自己运行配置之后，最终会给用户一个操作界面（也许是cmdline，也许是GUI），这个用户操作界面就是由/linuxrc带出来的。

(2)用户界面等很多事并不是在/linuxrc程序中负责的，用户界面有自己专门的应用程序，但是用户界面的应用程序是直接或者间接的被/linuxrc调用执行的。用户界面程序和其他的应用程序就是进程2、3、4·····，这就是我们说的进程1（init进程，也就是/linuxrc）是其他所有应用程序进程的祖宗进程。

 

### 2.18.5.3、/linuxrc负责系统启动后的配置

(1)就好像一个房子建好之后不能直接住，还要装修一样；操作系统启动起来后也不能直接用，要配置下。

(2)操作系统启动后的应用层的配置（一般叫运行时配置，英文简写etc（executable runtime configuration）是为了让我们的操作系统用起来更方便，更适合我个人的爱好或者实用性。

 

### 2.18.5.4、/linuxrc在嵌入式linux中一般就是busybox

(1)busybox是一个C语言写出来的项目，里面包含了很多.c文件和.h文件。这个项目可以被配置编译成各个平台下面可以运行的应用程序。我们如果用arm-linux-gcc来编译busybox就会得到一个可以在我们开发板linux内核上运行的应用程序。

(2)busybox这个程序开发出来就是为了在嵌入式环境下构建rootfs使用的，也就是说他就是专门开发的init进程应用程序。

(3)busybox为当前系统提供了一整套的shell命令程序集。譬如vi、cd、mkdir、ls等。在桌面版的linux发行版（譬如ubuntu、redhat、centOS等）中vi、cd、ls等都是一个一个的单独的应用程序。但是在嵌入式linux中，为了省事我们把vi、cd等所有常用的shell命令集合到一起构成了一个shell命令包，起名叫busybox。

 

## 2.18.6.rootfs中还应该有什么

### 2.18.6.1、最重要的就是上节课讲过的/linuxrc

### 2.18.6.2、dev目录下的设备文件

在linux中一切皆是文件，因此一个硬件设备也被虚拟化成一个设备文件来访问，在linux系统中/dev/xxx就表示一个硬件设备，我们要操作这个硬件时就是open打开这个设备文件，然后read/write/ioctl操作这个设备，最后close关闭这个设备。

在最小rootfs中/dev目录也是不可少的，这里面有一两个设备文件是rootfs必须的。

### 2.18.6.3、sys和proc目录

在最小rootfs中也是不可省略的，但是这两个只要创建了空文件夹即可，里面是没东西的，也不用有东西。这两个目录也是和驱动有关的。属于linux中的虚拟文件系统。

### 2.18.6.4、usr

usr是系统的用户所有的一些文件的存放地，这个东西将来busybox安装时会自动生成。

### 2.18.6.5、etc

etc目录是很关键很重要的一个，目录中的所有文件全部都是运行时配置文件。/etc目录下的所有配置文件会直接或者间接的被/linuxrc所调用执行，完成操作系统的运行时配置。etc目录是制作rootfs的关键，所以后面下一个课程专门讲这个etc目录。

### 2.18.6.6、lib

目录也是rootfs中很关键的一个，不能省略的一个。lib目录下放的是当前操作系统中的动态和静态链接库文件。我们主要是为了其中的动态链接库。

 

 

## 2.18.7.VFS简介

### 2.18.7.1、什么是VFS

(1)VFS是linux内核的一种设计理念、设计机制。VFS就是vitrual file system，叫虚拟文件系统。

(2)具体的一些文件系统如FAT、NTFS、ext2、ext3、jffs2、yaffs2、ubi等主要设计目的是为了管理块设备（硬盘、Nand···）。

(3)VFS是借鉴了文件系统的设计理念（通过文件系统将底层难以管理的物理磁盘扇区式访问，转换成目录+文件名的方式来访问），将硬件设备的访问也虚拟化成了对目录+文件的访问。所以有了VFS后我们可以通过设备文件（目录+文件名，譬如/dev/mmcblk0p2）的方式来访问系统中的硬件设备。

(4)以上可以初步看出VFS的一些厉害之处，但是VFS不止于此。

 

### 2.18.7.2、VFS的意义

(1)上面说过的对硬件设备的访问，将对硬件设备的访问和对普通文件的访问给接口统一化了（linux中一切届是文件）。

   (2)将操作系统上层（应用层）对下层不同文件系统类型的访问细节给屏蔽掉了。因此如果没有VFS那我们写cp命令（其他命令也一样）的时候就不得不去考虑你cp的这个文件在什么文件系统类型下。所以cp命令非常复杂，因此要考虑具体的文件系统类型。有了VFS后情况就不同了。VFS成了一个隔离层，隔离了下层的不同文件系统的差异性，对上层应用提供一个统一的接口。

(3)VFS将不同文件系统和下层硬件设备（块设备）驱动之间的细节也给屏蔽了。不同类型的文件系统在本身设计时是不用考虑各种不同的硬件设备的具体操作差异的，这里有一个类似于VFS的设计理念。

 

### 2.18.7.3、VFS和我们学习的关系

(1)VFS机制和rootfs挂载，和其他文件系统的挂载都是有关联的。

(2)内核中有一些sys proc这种虚拟文件系统，这东西也是和VFS机制有关。

(3)/dev/目录下的设备文件都和VFS有关，所以学习驱动绕不开VFS。

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 



 

 

# 第十九章 根文件系统构建实验及过程详解

## 2.19.0 章节概要

**2.19.1.根文件系统的构建路线**

​    本节讲述我们整个课程从零开始构建一个根文件系统的路线，是本部分课程的大纲。

**2.19.2.busybox的移植实战**

​    本节我们从零开始移植busybox到文件夹形式的根文件系统中。

**2.19.3.inittab详解**

​    本节引入并且解析inittab的格式，并且通过添加inittab文件使我们制作的最小根文件系统工作起来

**2.19.4.busybox源码分析1**

​    本节开始解析busybox源码，主要分析了busybox中main函数和xxx_main，通过分析从而搞明白busybox的工作原理

**2.19.5.busybox源码分析2**

​    本节继续解析busybox源码，主要分析了inittab文件解析部分、通用shell命令如pwd命令的执行部分以及busybox的体积优势。

**2.19.6.rcS文件介绍1**

​    本节讲解/etc/init.d/rcS文件并且解析其中PATH、runlevel、umask、mount等步骤的具体含义。

**2.19.7.rcS文件实战1**

​    本节根据上节理论实际添加rcS文件，并且解决过程中遇到的细节问题，通过实践现象来印证理论，加深理解。

**2.19.8.rcS文件介绍2**

​    本节继续解析rcS文件，主要分析了hostname、ifconfig、mdev等步骤。

**2.19.9.profile文件和用户登录理论**

​    本节通过添加profile文件在命令行中显示hostname，然后讲解了用户登录界面的相关理论。

**2.19.10.用户登录实战**

​    本节进行用户登录界面的实战，通过实际修改inittab文件来实现用户登录，并且添加passwd和shadow文件来管理密码。

**2.19.11.动态链接库的拷贝**

​    本节首先通过执行静态编译链接和动态编译链接的2个helloworld程序来引出动态链接库，然后进行实际的库文件拷贝工作解决动态链接程序的工作问题。

**2.19.12.开机自启动与主流rcS格式介绍**

​    本节讲述如何在rcS文件中做修改实现开机自启动和后台运行，然后介绍了主流产品中rcS文件的式样。

**2.19.13.制作ext2格式的镜像并烧录启动**

​    本节将前面做好的文件夹格式的rootfs制作成ext2格式的可烧录的镜像，然后实际烧录启动，让大家体会产品开发的全过程。

## 2.19.1.根文件系统的构建路线

### 2.19.1.1、先逐步构建文件夹形式根文件系统然后制作烧录镜像

(1)rootfs有2种格式：nfs方式启动的文件夹形式的rootfs和用来烧录的镜像形式的rootfs。

(2)传统的培训机构中上课时，rootfs制作实验都是直接给制作文档，学生参照制作文档的步骤自己动手做，一步到位做出来的就是可供烧录的rootfs。

(3)我们先从空文件夹开始，逐步向其中添加一些rootfs中必备的东西，然后做一步就用nfs方式去挂载启动，观察启动后的现象，并且理论上去分析原因。

### 2.19.12、动手实践和理论分析相结合

​    根文件系统不仅仅只做实验，我们还会教一些理论。

### 2.19.1.3、逐步添加不断复杂化的rootfs

  

 

## 2.19.2.busybox的移植实战

### 2.19.2.1、busybox源码下载

(1)busybox是一个开源项目，所以源代码可以直接从网上下载。

(2)busybox的版本差异不大，版本新旧无所谓。

(3)下载busybox可以去linuxidc等镜像网站，也可以去www.busybox.net官方网站下载。

 

### 2.19.2.2、修改Makefile

(1) ARCH = arm

(2) CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin//arm-none-linux-gnueabi-

 

### 2.19.2.3、make menuconfig进行配置

(1)参照网盘中章节目录下的《busybox menuconfig配置.txt》文件中的记录进行配置。

Busybox Settings--->

  Build Options--->

​      [*]Build BusyBox as a static binary(no shared libs)

 

Busybox Settings--->       

Busybox Library Tuning--->

​    [*]vi-style line editing commands

​    [*]Fancy shell prompts

​    

  

Linux Module Utilities--->

  [ ]Simplified modutils

  [*]insmod

  [*]rmmod

  [*]lsmod

  [*]modprobe

  [*]depmod

 

  

Linux System Utilities--->[*]mdev

  [*]Support /etc/mdev.conf

  [*]Support subdirs/symlinks

  [*]Support regular expressions substitutions when renaming dev

  [*]Support command execution at device addition/removal

  [*]Support loading of firmwares

 

### 2.19.2.4、make 然后 make install

(1)make编译，如果有错误解决之

(2)make install执行的时候其实是在执行busybox顶层目录下的一个目标install。

(3)make install在所有的linux下的软件中作用都是安装软件。在传统的linux系统中安装软件时都是选择源代码方式安装的。我们下载要安装的软件源代码，然后配置、编译、安装。make install的目的就是将编译生成的可执行程序及其依赖的库文件、配置文件、头文件安装到当前系统中指定（一般都可以自己指定安装到哪个目录下，如果不指定一般都有个默认目录）的目录下,

Make menuconfig 更改默认目录

Busybox settings

  Installation Options(“make install behavior”)--->

 

 

### 2.19.2.5、设置bootargs挂载添加了busybox移植的rootfs

(1)之前建立了一个空的文件夹然后自己touch linuxrc随便创建了一个不能用的/linuxrc然后去nfs挂载rootfs，实验结果是：挂载成功，执行/linuxrc失败。

(2)现在我们移植了busybox后/linuxrc就可以用了，然后再次去nfs挂载这个rootfs。预计看到的效果是：挂载成功，执行/linuxrc也能成功。

(3)注意uboot的bootargs设置成：setenv bootargs root=/dev/nfs nfsroot=192.168.1.141:/root/porting_x210/rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC2,115200 

(4)实验结果：挂载成功，执行/linuxrc（也就是busybox）成功，但是因为找不到/etc/init.d/rcS和/dev/tty2等文件所以一直在打印错误提示信息，但是其实有进入命令行。

 

 

## 2.19.3.inittab详解

### 2.19.3.1、添加一个典型的inittab

(1)将我提供的典型的inittab文件复制到我们制作的rootfs的根目录下的/etc/目录下

(2)再次启动内核挂载这个rootfs看效果

(3)实验现象是成功启动并且挂载rootfs进入了控制台命令行。当前制作的最小rootfs成功了

 

### 2.19.3.2、inittab格式解析

 (1)inittab的工作原理就是被/linuxrc（也就是busybox）执行时所调用起作用。

(2)inittab在/etc目录下，所以属于一个运行时配置文件，是文本格式的（内容是由一系列的遵照一个格式组织的字符组成的），实际工作的时候busybox会（按照一定的格式）解析这个inittab文本文件，然后根据解析的内容来决定要怎么工作。

(3)busybox究竟如何完成解析并且解析结果如何去工作（busybox中实现/etc/inittab的原理）并不是我们的目标，我们的重点是inittab的格式究竟怎样的？我们看到一个inittab后怎么去分析这个inittab对启动的影响。

(4)inittab的格式在busybox中定义的，网上可以搜索到详细的格式说明，具体去参考即可：

\#first:run the system script file

::sysinit:/etc/init.d/rcS

::askfirst:-/bin/sh

::ctrlaltdel:-/sbin/reboot

\#umount all filesystem

::shutdown:/bin/umount -a -r

\#restart init process

::restart:/sbin/init

**第一个**：#开始的行是注释

**第二个**：冒号在里面是分隔符，分隔开各个部分。

**第三个**：inittab内容是以行为单位的，行与行之间没有关联，每行都是一个独立的配置项，每一个配置项表示一个具体的含义。

**第四个**：每一行的配置项都是由3个冒号分隔开的4个配置值共同确定的。这四个配置值就是id:runlevels:action:process。值得注意得是有些配置值可以空缺，空缺后冒号不能空缺，所以有时候会看到连续2个冒号。/etc/inittab文件中每个登记项的结构都是一样的,共分为以冒号“:”分隔的4个字段.具体如下:

   identifier : run_level : action : process

**identifier**　：登记项标识符,最多为4个字符.用于惟一地标识/etc/inittab文件中的每一个登记项

**run_level**　：系统运行级,即执行登记项的init级别.用于指定相应的登记项适用于哪一个运行级,即在哪一个运行级中被处理.如果该字段为空,那么相应的登记项将适用于所有的运行级.在该字段中,可以同时指定一个或多个运行级,其中各运行级分别以数字0.1.2.3.4.5.6或字母a、b、c表示,且无需对其进行分隔.

**action**　 ：　动作关键字.用于指定init(M)命令或进程对相应进程(在“process”字段定义)所实施的动作.具体动作包括:

**boot**:只有在引导过程中,才执行该进程,但不等待该进程的结束;当该进程死亡时,也不重新启动该进程.

**bootwait**:只有在引导过程中,才执行该进程,并等待进程的结束:当该进程死亡时,也不重新启动该进程.实际上,只有在系统被引导后,并从单用户方式进入多用户方式时,这些登记项才被处理;如果系统的默认运行级设置为2(即多用户方式),那么这些登记项在系统引导后将马上被处理.

**initdefault**:指定系统的默认运行级.系统启动时,init将首先查找该登记项.如果存在init将据此决定系统最初要进入的运行级.具体来说,init将指定登记项“run_level"字段中的最大数字(即最高运行级)为当前系统的默认运行级;如果该字段为空,那么将其解释为“0123456”,并以“6”作为默认运行级.如果不存在该登记项,那么init将要求用户在系统启动时指定一个最初的运行级.

**off**:如果相应的进程正在运行,那么就发出一个警告信号,等待20秒后,再通过杀死信号强行终止该进程.如果相应的进程并不存在那么就忽略该登记项.

**once**:启动相应的进程,但不等待该进程结束便继续处理/etc/inittab文件中的下一个登记项;当该进程死亡时,init也不重新启动该进程.注意:在从一个运行级进入另一个运行级时,如果相应的进程仍然在运行,那么init就不重新启动该进程.

**ondemand**:与“respawn”的功能完全相同,但只用于运行级为a、b或c的登记项.

**powerfail**:只在init接收到电源失败信号时执行相应的进程,但不等待该进程结束.

**powerwait**:只在init接收到电源失败信号时执行相应的进程,并在继续对/etc/inittab文件进行任何处理前等待该进程结束.

**respawn:**如果相应的进程还不存在,那么init就启动该进程,同时不等待该进程的结束就继续扫描/etc/inittab文件;当该进程死亡时,init将重新启动该进程.如果相应的进程已经存在,那么init将忽略该登记项并继续扫描/etc/inittab文件.

**sysinit**:只有在启动或重新启动系统并首先进入单用户时,init才执行这些登记项.而在系统从运行级1－6进入单用户方式时,init并不执行这些登记项."action”字段为“sysinit”的登记项在“run_level”字段不指定任何运行级.

**wait**:启动进程并等待其结束,然后再处理/etc/inittab文件中的下一个登记项.

**process**  ：　所要执行的shell命令.任何合法的shell语法均适用于该字段.

 

**第五个**：每一行的配置项中4个配置值中最重要的是action和process，**action是一个条件/状态，process是一个可被执行的程序的pathname**。合起来的意思就是：当满足action的条件时就会执行process这个程序。

 

注意：理解inittab的关键就是明白“当满足action的条件时就会执行process这个程序。” 你去分析busybox的源代码就会发现，busybox最终会进入一个死循环，在这个死循环中去反复检查是否满足各个action的条件，如果某个action的条件满足就会去执行对应的process。

 

**第六个**：明白各个action什么意思

 

 

## 2.19.4.busybox源码分析1

### 2.19.4.1、源码目录梳理

### 2.19.4.2、SourceInsight工程建立

### 2.19.4.3、整个程序入口确认

(1)分析一个程序，不管多庞大还是小，最好的路线都是按照程序运行时的逻辑顺序来。所以找到一个程序的入口至关重要。

(2)学C语言的时候都知道程序的主函数main函数就是整个程序的入口。这种情况适应于操作系统下工作的应用程序的情况。

(3)在uboot和linux kernel这两个大的C语言的项目中，main函数都没有，都不是入口。在我们这种裸机程序中入口不是main函数，而是由连接脚本来指定的。

(4)busybox是linux启动起来后工作的一个应用程序，因此其中必然有main函数，而且main就是入口。

### 2.19.4.4、busybox中main函数全解析

(1)busybox入口就是main函数，其中有很多个main但是只有一个起作用了，其他的是没起作用的。真正的busybox工作时的入口是libbb/appletlib.c中的main函数

(2)busubox中有很多xxx_main函数，这些main函数每一个都是busybox支持的一个命令的真正入口。譬如ls_main函数就是busybox当作ls函数使用时的入口程序。

(3)ls或者cd等命令其实都是busybox一个程序，但是实际执行时的效果却是各自的效果。busybox是如何实现一个程序化身万千还能各自工作的？答案就是main转xxx_main。也就是说busybox每次执行时都是先执行其main，在main函数中识别（靠main函数的传参argv[0]来识别）我们真正要执行的函数（譬如ls）然后去调用相应的xxx_main（譬如ls_main）来具体实现这个命令。

 

 

## 2.19.5.busybox源码分析2

### 2.19.5.1、inittab解析与执行

(1)inittab的解析是在busybox/init/init.c/init_main函数中

(2)执行逻辑是：先通过parse_inittab函数解析/etc/inittab（解析的重点是将inittab中的各个action和process解析出来），然后后面先直接执行sysinit和wait和once（注意这里只执行一遍），然后在while(1)死循环中去执行respwan和askfirst。

 

### 2.19.5.2、pwd命令执行路径分析

(1)根据上节讲的，我们在busybox命令行下执行pwd命令时实际执行的是pwd_main这个函数。

 

### 2.19.5.3、busybox的体积优势原理

(1)busybox实际上就是把ls、cd、mkdir等很多个linux中常用的shell命令集成在一起了。集成在一起后有一个体积优势：就是busybox程序的大小比busybox中实现的那些命令的大小加起来要小很多。

(2)busybox体系变小的原因主要有2个：第一个是busybox本身提供的shell命令是阉割版的（busybox中的命令支持的参数选项比发行版中要少，譬如ls在发行版中可以有几十个-x，但是在busybox中只保留了几个常用的选项，不常用的都删除掉了）；第二个是busybox中因为所有的命令的实现代码都在一个程序中实现，而各个命令中有很多代码函数都是通用的（譬如ls和cd、mkdir等命令都会需要去操作目录，因此在busybox中实现目录操作的函数就可以被这些命令共用），共用会降低重复代码出现的次数，从而减少总的代码量和体积。

(3)经过分析，busybox的体积优势是嵌入式系统本身的要求和特点造成的。

 

 

## 2.19.6.rcS文件介绍1

### 2.19.6.0、/etc/init.d/rcS文件

/etc/init.d/rcS文件是linux的运行时配置文件中最重要的一个，其他的一些配置都是由这个文件引出来的。这个文件可以很复杂也可以很简单，里面可以有很多的配置项。

\#!/bin/sh

PATH=/sbin:/bin:/usr/sbin:/usr/bin

 

runlevel=S

prevlevel=N

 

umask 022

 

export PATH runlevel prevlevel

 

mount -a

 

echo /sbin/mdev > /proc/sys/kernel/hotplug

mdev -s

 

/bin/hostname -F /etc/sysconfig/HOSTNAME

### 2.19.6.1、PATH=xxx

(1)首先从shell脚本的语法角度分析，这一行定义了一个变量PATH，值等于后面的字符串

(2)后面用export导出了这个PATH，那么PATH就变成了一个环境变量。

(3)PATH这个环境变量是linux系统内部定义的一个环境变量，含义是操作系统去执行程序时会默认到PATH指定的各个目录下去寻找。如果找不到就认定这个程序不存在，如果找到了就去执行它。将一个可执行程序的目录导出到PATH，可以让我们不带路径来执行这个程序。

(4)rcS中为什么要先导出PATH？就是因为我们希望一旦进入命令行下时，PATH环境变量中就有默认的/bin /sbin /usr/bin /usr/sbin 这几个常见的可执行程序的路径，这样我们进入命令行后就可以ls、cd等直接使用了。

(5)为什么我们的rcS文件还没添加，系统启动就有了PATH中的值？原因在于busybox自己用代码硬编码为我们导出了一些环境变量，其中就有PATH。

 

### 2.19.6.2、runlevel=

(1)runlevel也是一个shell变量，并且被导出为环境变量

(2)runlevel这个环境变量到底有什么用？

(3)runlevel=S表示将系统设置为单用户模式

 

### 2.19.6.3、umask=

(1)umask是linux的一个命令，作用是设置linux系统的umask值。

(2)umask值决定当前用户在创建文件时的默认权限。

 

### 2.19.6.4、mount -a

(1)mount命令是用来挂载文件系统的

(2)mount -a是挂载所有的应该被挂载的文件系统，在busybox中mount -a时busybox会去查找一个文件**/etc/fstab**文件，这个文件按照一定的格式列出来所有应该被挂载的文件系统（包括了虚拟文件系统）

\# /etc/fstab: static file system information.

\#

\# Use 'vol_id --uuid' to print the universally unique identifier for a

\# device; this may be used with UUID= as a more robust way to name devices

\# that works even if disks are added and removed. See fstab(5).

\#

\#     <file system>    <mount point>   <type>  <options>  <dump>    <pass>

​      proc         /proc          proc   defaults     0       0

​      sysfs        /sys           sysfs   defaults     0      0

​      tmpfs        /var           tmpfs  defaults     0        0

​      tmpfs        /tmp          tmpfs  defaults     0        0

​      tmpfs        /dev          tmpfs  defaults     0        0

 

 

## 2.19.7.rcS文件实战1

### 2.19.7.1、PATH&runlevel

(1)我们实战发现rcS文件明明存在但是却提示不存在，问题原因就是rcS文件在windows下创建的，行尾换行符为'\r\n'，多了点东西。但是因为ubuntu中的vi对行尾做了优化，所以在ubuntu中是看不出来多了东西的。但是在securecrt下一看就发现每一行末尾多出来了一个^M。

(2)这个故事告诉我们：shell脚本文件如果格式不对，运行时可能会被提示文件不存在。

(3)扩展讲一个：有时候一个应用程序执行时也会提示文件不存在，问题可能是这个程序所调用的一个动态链接库找不到。

(4)测试结果：PATH本来在busybox中就已经用代码导出过了，所以rcS中再次导出没有任何明显的现象，因此看不出什么差别；runlevel实际执行结果一直是unknown，问题在于busybox并不支持runlevel这个特性。

 

### 2.19.7.2、umask测试

(1)umask是022的时候，默认touch创建一个文件的权限是644

(2)umask是044的时候，默认touch创建一个文件的权限是622

(3)umask是444的时候，默认touch创建一个文件的权限是222

总结：umask的规律就是：umask值和默认创建文件的权限值加起来是666.

 

### 2.19.7.3、mount测试

(1)挂载时全部出错：

mount: mounting proc on /proc failed: No such file or directory

mount: mounting sysfs on /sys failed: No such file or directory

mount: mounting tmpfs on /var failed: No such file or directory

mount: mounting tmpfs on /tmp failed: No such file or directory

mount: mounting tmpfs on /dev failed: No such file or directory

(2)原因是因为根文件系统中找不到挂载点。所谓挂载点就是我们要将目标文件系统（当然这里都是虚拟文件系统）挂载到当前文件系统中的某一个目录中，这个目录就是挂载点。

(3)解决方案就是自己在制作的rootfs根目录下创建这些挂载点目录即可。

(4)验证是否挂载成功，可以看挂载时输出信息；还可以启动后去看proc和sys文件夹，如果有文件出现则证明挂载成功了，如果没东西就证明失败了。

 

 

## 2.19.8.rcS文件介绍2

### 2.19.8.1、mdev

echo /sbin/mdev > /proc/sys/kernel/hotplug

mdev -s

 

(1)mdev是udev的嵌入式简化版本，udev/mdev是用来配合linux驱动工作的一个应用层的软件，udev/mdev的工作就是配合linux驱动生成相应的/dev目录下的设备文件。

(2)因为这个问题涉及到驱动，因此详细讲解要等到驱动部分。这里我们只是通过一些直观的现象来初步理解udev/mdev的工作效果。

(3)在rcS文件中没有启动mdev的时候，/dev目录下启动后是空的；在rcS文件中添加上mdev有关的2行配置项后，再次启动系统后发现/dev目录下生成了很多的设备驱动文件。

(4)/dev目录下的设备驱动文件就是mdev生成的，这就是mdev的效果和意义。

 

### 2.19.8.2、hostname

/bin/hostname -F /etc/sysconfig/HOSTNAME

(1)hostname是linux中的一个shell命令：命令（hostname xxx）执行后可以用来设置当前系统的主机名为xxx，直接hostname不加参数可以显示当前系统的主机名。

(2)/bin/hostname -F /etc/sysconfig/HOSTNAME -F来指定了一个主机名配置文件（这个文件一般文件名叫hostname或者HOSTNAME）

 

### 2.19.8.3、ifconfig

(1)有时候我们希望开机后进入命令行时ip地址就是一个指定的ip地址（譬如192.168.1.30），这时候就可以在rcS文件中ifconfig eth0 192.168.1.30

 

 

## 2.19.9.profile文件和用户登录理论

### 2.19.9.1、profile文件添加

(1)之前添加了/bin/hostname在/etc/sysconfig/HOSTNAME文件中定义了一个hostname（aston210），实际效果是：命令行下hostname命令查到的host名字确实是aston210。但是问题就是命令行的提示符是没有显示的。

(2)这个问题的解决就要靠profile文件。将提供的profile文件放入/etc/目录下即可。

\# Ash profile

\# vim: syntax=sh

 

\# No core files by default

ulimit -S -c 0 > /dev/null 2>&1

 

USER="`id -un`"

LOGNAME=$USER

PS1='[\u@\h \W]\# '

PATH=$PATH

 

HOSTNAME=`/bin/hostname`

 

export USER LOGNAME PS1 PATH

 

 

(3)添加了之后的实验现象：命令行提示符前面显示：[@aston210 ]#

结论是：第一，profile文件起了作用，hostname显示出来了。第二，还有个问题，登录用户名没显示出来。原因就是我们直接进入了命令行而没有做登录。等我们添加了用户登录功能，并且成功登陆后这个问题就能解决。

(4)profile文件工作原理是：profile文件也是被busybox（init进程）自动调用的，所以是认名字的。

 

### 2.19.9.2、如何看到用户登录界面

(1)linux中有一个原则就是用一个小程序来完成一个功能。如果我们产品确实需要很复杂的综合型的功能，我们倾向于先使用很多个小程序完成其中的一个功能，然后再将这些小程序集成起来完成整个大功能的产品。

(2)这种集成很多个小程序来完成一个大的功能，有很多种技术实现。譬如shell脚本，还有一些别的技术，譬如linux启动中的inittab。

(3)因为我们之前intttab中有一个配置项 ::askfirst:-/bin/sh，这个配置项作用就是当系统启动后就去执行/bin/sh，执行这个就会出现命令行。因此我们这样的安排就会直接进入命令行而不会出现登录界面。

(4)我们要出现登录界面，就不能直接执行/bin/sh，而应该执行一个负责出现登录界面并且负责管理用户名和密码的一个程序，busybox中也集成了这个程序（就是/bin/login和/sbin/gettty），因此我们要在inittab中用/bin/login或者/sbin/getty去替代/bin/sh。

 

### 2.19.9.3、用户名和密码的设置

(1)用户名和密码的设置是和登录程序有关联的，但是/bin/login和/sbin/getty在用户名和密码的管理上是一样的。其实常见的所有的linux系统的用户名和密码的管理几乎都是一样的。

(2)密码一般都是用加密文字的，而不是用明文。意思就是系统中的密码肯定是在系统中的一个专门用来存密码的文件中存储的，用明文存密码有风险，因此linux系统都是用密文来存储密码的。关于密文密码的使用下节课实践时会详细讲。

 

 

## 2.19.10.用户登录实战

### 2.19.10.1、添加/bin/login到sysinit

​    \#::askfirst:-/bin/sh

​    ::askfirst:/bin/login

(1)在inittab中修改，去掉/bin/sh，换上/bin/login，则系统启动后出现登录界面。可以输入用户名和密码。

(2)实验现象：成功出现用户登录界面，但是死活密码不对。

 

### 2.19.10.2、添加passwd和shadow文件

(1)为什么用户名和密码不对？因为我们根本没有为root用户设置密码。

(2)linux系统中用来描述用户名和密码的文件是passwd和shadow文件，这两个文件都在etc目录下。passwd文件中存储的是用户的密码设置，shadow文件中存储的是加密后的密码。

(3)我们直接复制ubuntu系统中的/etc/passwd和/etc/shadow文件到当前制作的rootfs目录下，然后再做修改即可。

   Passwd: 

  

Shadow: 

 

(4)/etc/passwd和/etc/shadow修理好后，shadow中默认有一个加密的密码口令，这个口令和你拷贝的shadow本身有关，像我的ubuntu中root用户的密码就是root，因此复制过来后登陆时的密码还是root。

### 2.19.10.3、重置密码实践

(1)ubuntu刚装好的时候默认登录是用普通用户登录的，默认root用户是关闭的。普通用户的密码是在装系统的时候设置的，普通用户登陆后可以使用su passwd root给root用户设置密码，设置了密码后root用户才可以登录。

(2)其实这个原因就是root用户在/etc/shadow文件中加密口令是空白的。所以是不能登录的。

(3)busybox中因为没有普通用户，所以做法是：默认root用户如果加密口令是空的则默认无密码直接登录。等我们登陆了之后还是可以用passwd root给root用户设置密码。

(4)平时有时候我们忘记了自己的操作系统的密码，怎么办？有一种解决方法就是用其他系统（WindowsPE系统或者ubuntu的单用户模式等···）来引导启动，启动后挂载到我们的硬盘上，然后找到/etc/shadow文件，去掉密文密码后保存。然后再重启系统后密码就没了。

 

### 2.19.10.4、getty实战

(1)大家后面做项目会发现，inittab中最常见的用于登录的程序不是/bin/login，反而是/sbin/getty。

(2)这两个的差别不详，但是在busybox中这两个是一样的。这两个其实都是busybox的符号链接而已。因此不用严格区分这两个

(3)我们可以在inittab中用getty替换login程序来实现同样的效果。

S3c2410_serial2::respawn:/sbin/getty -L s3c2410_serial2 115200 vt100

  Vt100 是串口的样式模式。

## 2.19.11.动态链接库的拷贝

### 2.19.11.1、静态编译链接helloworld程序并执行

(1)任务：自己写一个helloworld程序，然后交叉编译连接，然后丢到开发板根文件系统中，开机后去运行。

(2)C程序如果使用gcc来编译则可以在主机ubuntu中运行，但是不能在开发板运行；要在开发板运行需要用arm-linux-gcc来交叉编译，但是这时候就不能在主机ubuntu中运行了。我们可以用file xx命令来查看一个elf可执行程序是哪个架构的。

(3)静态链接：arm-linux-gcc hello.c -o hello_satic -static

(4)实验结果：静态编译连接后生成的hello_satic已经可以成功运行。

 

### 2.19.11.2、动态编译连接helloworld程序并执行

(1)动态链接：arm-linux-gcc hello.c -o hello_dynamic

(2)实验结果：-sh: ./hello_dynamic: not found运行时提示找不到程序。

(3)错误分析：动态连接的hello程序中调用到了printf函数，而printf函数在动态连接时要在运行时环境（开发板的rootfs）中去寻找对应的库文件（开发板rootfs中部署的动态链接库中包含了printf函数的那个库文件）。如果找到了则printf函数就会被成功解析，然后hello_dynamic程序就会被执行；如果找不到则程序就不能被执行，命令行会提示错误信息**-sh: ./hello_dynamic: not found**

(4)解决方案：将arm-linux-gcc的动态链接库文件复制到开发板rootfs的/lib目录下即可解决。

### 2.19.11.3、找到并复制动态链接库文件到rootfs中

(1)我们用的arm-2009q3这个交叉编译工具链的动态链接库在/usr/local/arm/arm-2009q3/arm-none-linux-gnueabi/libc/lib目录下。其他的一些交叉编译工具链中动态链接库的目录不一定在这里，要去找一下。找的方法就是find：

​      Find -name “*libm.so*”

(2)复制动态链接库到roots/lib目录下。复制时要注意参数用-rdf，主要目的就是符号链接复制过来还是符号链接。

复制命令：cp lib/*so* /root/porting_x210/rootfs/rootfs/lib/ -rdf

(3)现在再去测试./hello_dynamic看看是否可以运行，实验结果是可以运行。

 

### 2.19.11.4、使用strip工具去掉库中符号信息

动态链接库so文件中包含了调试符号信息，这些符号信息在运行时是没用的（调试时用的），这些符号会占用一定空间。在传统的嵌入式系统中flash空间是有限的，为了节省空间常常把这些符号信息去掉。这样节省空间并且不影响运行。

去掉符号命令：arm-linux-strip *so*

实际操作后发现库文件由3.8M变成了3.0M，节省了0.8M的空间。

### 2.19.11.5、执行modinfo xx.ko时modules.dep文件找不到

 

modinfo使用时出现的问题：

(1)开发板执行modinfo xx.ko时出现：

modinfo: can't open '/lib/modules/2.6.35.7/modules.dep': No such file or directory

解决办法：百度中搜到：提示找不到modules.dep文件。我们不需要手动创建该文件，使用depmod指令即可自动生成。

(2)然后去命令行执行depmod，提示：

depmod: can't change directory to 'lib/modules/2.6.35.7': No such file or directory

(3)没有这个/lib/modules/2.6.35.7目录，手动创建该目录，再次执行depmod即可得到3个文件：

modules.alias   modules.dep    modules.symbols

(4)再去执行modinfo xx.ko即可。

如果提示没有找到depmod命令，则要去busybox的配置中添加这个选项并重新编译FS。

参考：https://blog.csdn.net/armeasy/article/details/39621265

————————————————

版权声明：本文为CSDN博主「lao三哥」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/weixin_39888281/article/details/93136861

## 2.19.12.开机自启动与主流rcS格式介绍

### 2.19.12.1、修改rcS实现开机自启动

(1)开机自启动指的是让一些应用程序能够开机后自动执行。

(2)开机自启动的实现原理就是在开机会自动执行的脚本rcS中添加上执行某个程序的语句代码即可。

### 2.19.12.2、前台运行与后台运行

(1)程序运行时占用了当前的控制台，因此这个程序不结束我们都无法使用控制台，这就叫前台运行。默认执行程序就是前台运行的。

(2)后台运行就是让这个程序运行，并且同时让出控制台。这时候运行的程序还能照常运行而且还能够不影响当前控制台的使用。

(3)让一个程序后台运行的方法就是 **./xxx &**

 

### 2.19.12.3、开机装载驱动等其他开机自动执行

我们开机除了自动执行一些应用程序外，还可装载驱动， 我们都可以在rcS中添加。

### 2.19.12.4、实际开发中rootfs的rcS是怎样的

(1)我们以X210开发板九鼎科技做的rootfs中rcS部分来分析

(2)分析inittab发现：sysinit执行rcS，shutdown时执行rcK。

(3)分析/etc/init.d/rcS和rcK文件发现，rcS和rcK都是去遍历执行/etc/init.d/目录下的S开头的脚本文件，区别是rcS传参是start，rcK传参是stop。

(4)由此可以分析出来，正式产品中的rcS和rcK都是一个引入，而不是真正干活的。真正干活的配置脚本是/etc/init.d/S??*。这些文件中肯定有一个判断参数是start还是stop，然后start时去做一些初始化，stop时做一些清理工作。

 

 

## 2.19.13.制作ext2格式的镜像并烧录启动

### 2.19.13.1、确定文件夹格式的rootfs可用

(1)设置bootargs为nfs启动方式，然后从主机ubuntu中做好的文件夹格式的rootfs去启动，然后看启动效果，作为将来的参照物。

### 2.19.13.2、动手制作ext2格式的镜像

(1)

dd if=/dev/zero of=rootfs.ext2 bs=1024 count=10240

losetup /dev/loop1 rootfs.ext2

mke2fs -m 0 /dev/loop1 10240

mount -t ext2 /dev/loop1 ./ext2_rootfs/

(2)向./rootfs中复制内容，用cp ../rootfs/* ./ -rf

(3)umount /dev/loop1

losetup -d /dev/loop1

(4)完成后得到的rootfs.ext2就是我们做好的rootfs镜像。拿去烧录即可。

 

### 2.19.13.3、烧录镜像并设置合适的bootargs

(1)使用fastboot烧录制作好的rootfs.ext2到开发板inand中

fastboot flash system rootfs.ext2

烧录完成后重启系统

(2)设置bootargs为：set bootargs console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext2

(3)启动后发现现象和之前nfs方式启动挂载rootfs后一样的，至此rootfs制作实验圆满完成。

 

### 2.19.13.4、总结

(1)13节课将rootfs的制作步骤和原理已经完全清楚的讲完了。

(2)制作过程本身如果有文档指导非常容易，非常简单，但是我们学习时侧重于不是rootfs制作本身，而是rootfs工作的原理分析。

 

 

 

 

 



 

# 第二十章 buildroot的引入和介绍

## 2.20.0 章节概要

**2.20.1.X210的bsp介绍**

​    本节介绍x210开发板的linux+QT的bsp，主流嵌入式SoC的linux bsp结构大都和x210的bsp相类似。

**2.20.2.mk文件分析**

​    本节分析整个bsp的总Makefile文件，该文件中定义的一些函数完成了对主体模块如uboot、kernel等的整个配置编译工作。

**2.20.3.buildroot引入**

​    本节引入buildroot，并且以X210的bsp为例演示buildroot的编译过程和得到的结果。

## 2.20.1.X210的bsp介绍

### 2.20.1.1、嵌入式linux产品的bsp介绍

(1)大部分的ARM架构的linux平台的bsp的内容和结构都是相似的。

(2)bsp一般是芯片厂家/板卡厂家提供的。

 

### 2.20.1.2、X210的linux+QT bsp整体介绍

(1)tslib_x210_qtopia.tgz是用来支持QT的触摸屏操作的应用层库

(2)xboot和uboot是X210支持的2个bootloader源代码。

kernel文件夹中是内核源代码，

buildroot文件夹是用来构建根文件系统的文件夹，

tools里是一些有用工具。

(2)mk脚本是用来管理和编译整个bsp的。

 

### 2.20.1.3、mk的帮助信息

(1)linux下的惯例就是，执行程序时加-h或者--help就可以看到这个程序执行的帮助信息。

(2)mk脚本的主要作用是编译bsp中的所有的源代码（包括bootloader、kernel、rootfs等），但是我们可以完整编译也可以部分编译，我们通过执行mk 后面加不同的参数来指定mk脚本去编译相应的部分。

譬如：

mk -a 即可编译所有的bsp源代码

mk -x 即可只编译xboot

mk -ui 即可只编译uboot针对inand版本开发板的源代码

mk -r    即可只编译buildroot，-r只是得到了文件夹形式的rootfs，并没有将其制作成镜像文件。

mk -re 即可编译buildroot并且制作得到ext3格式的rootfs镜像

mk -rj 即可编译buildroot并且制作得到jffs2格式的rootfs镜像

 

### 2.20.1.4、工作示例

(1)编译uboot      ./mk -ui

(2)编译内核       ./mk -k  

 

注：./mk和mk都是执行mk这个脚本文件，区别在于./mk是带路径的，mk是不带路径的。还有source mk，这个和前两个的区别是source执行时不需要mk文件具有可执行权限，而前面两种要求mk必须在当前用户下具有可执行权限。

 

 

## 2.20.2.mk文件分析

### 2.20.2.1、shell程序结构

(1)shell脚本程序分为：变量定义、函数、代码。shell脚本程序的结构非常类似于C语言程序

(2)shell程序和C语言程序很大的一个差别就是shell没有main函数，shell脚本执行时也是先执行主函数的，不过主函数没有放在一个类似于main这样的函数中，而是直接放在全局下的一些代码。

(3)shell程序执行时首先执行变量定义，然后执行主函数，其他函数在主函数代码中被调用执行。

### 2.20.2.2、主函数

threads=4;

xboot=no;

uboot_inand=no;

uboot_nand=no;

kernel=no;

rootfs=no;

rootfs_ext3=no;

rootfs_jffs2=no;

update=no;

(1)上节课说过mk可以编译整个bsp的源代码，也可以只编译其中一部分。怎么实现控制编译哪个不编译哪个？实现原理就是：用一个函数来完成编译一个（譬如编译内核用build_kernel函数，编译inand的uboot用build_bootloader_uboot_inand），然后用相应的一些变量来控制这个函数要不要被编译（譬如uboot_inand变量=yes就表示要编译inand版本的uboot，=no就表示不要编译），我们编译时通过-xxxxx来传参时，这些传参会影响这些变量的值=yes或者=no

(2)如果我们直接./mk并不传参，则$1为空，这时候按照一套默认的配置来编译。

### 2.20.2.3、各个源文件的编译函数

## 2.20.3.buildroot引入

### 2.20.3.1、buildroot作用介绍

(1)之前自己从零开始构建根文件系统，一路下来事情还挺多，步骤比较麻烦。

(2)交叉编译工具链arm-linux-gcc，我们目前都是从soc官方直接拿来使用的，官方的工具链从何而来？实际上交叉编译工具链都是由gcc配置编译生成的，这个配置编译过程比较复杂，一般人自己去配置编译得到自己的交叉编译工具链是比较麻烦的，所以经常都是用别人最好的。

(3)buildroot就是一个集成包，这个包里集成了交叉编译工具链的制作，以及整个rootfs的配置编译过程。也就是说，使用buildroot可以很简便的得到一个做好的文件夹形式的根文件系统。

(4)buildroot将很多东西集成进来后，移植了linux kernel的make xxx_defconfig+make menuconfig的2步配置法，我们可以在buildroot的配置界面下完成集成在里边的所有东西的配置，然后直接make就可以最终得到文件夹形式的rootfs。

 

### 2.20.3.2、make x210ii_defconfig

(1)先make xxx_defconfig

(2)make menuconfig

(3)make

 

### 2.20.3.3、make及其错误解决

(1)直接make会遇到很多错误，这些错误原因都是因为ubuntu中缺乏一些必要软件包造成的。解决方案是先安装这些必要的软件包。

(2)编译过程会需要从网上下载一些软件包，因此整个编译过程需要在联网状态下进行。

编译buildroot的错误解决方案（环境为ubuntu14.04）

 

(1)配置

make x210ii_defconfig

 

 

(2)安装需要的软件包

sudo apt-get install g++ bison flex texinfo git hgsubversion whois

 

(3)编译

make

 

 

\-----------------------------------------------------------------

以下是我直接编译时遇到的错误及其解决过程，希望对大家有所帮助。

 

错误1、You may have to install 'g++' on your build machine

 

 

You must install 'bison' on your build machine

 

 

make: *** [core-dependencies] Error 1

 

解决：

安装g++：           sudo apt-get install g++      

安装bison：          sudo apt-get install bison

 

(3)再次make

错误2、You must install 'flex' on your build machine

 

解决：

安装bison：          sudo apt-get install flex

 

(4)再次make

错误3、You must install 'makeinfo' on your build machine

makeinfo is usually part of the texinfo package in your distribution

 

解决：

安装makeinfo：       sudo apt-get install makeinfo

 

提示：Reading package lists... Done

Building dependency tree    

Reading state information... Done

E: Unable to locate package makeinfo

 

解决：看错误3的提示信息中，有提示makeinfo是texinfo的一部分，因此尝试安装texinfo替代：    sudo apt-get install texinfo

 

(5)再次make

错误4、You must install 'git' on your build machine

 

解决：

安装git：         sudo apt-get install git

 

(6)再次make

错误5、You must install 'hg' on your build machine

 

解决：

安装git：         sudo apt-get install hg

 

提示：Reading package lists... Done

Building dependency tree    

Reading state information... Done

E: Unable to locate package hg

 

解决：

首先使用：apt-cache search hg查找和hg有关的安装包，在查找到的列表中发现有hgsubversion，于是安装这个替代，命令为：sudo apt-get install hgsubversion

 

(7)再次make

错误6、You need the 'mkpasswd' utility to set the root password

 

(in Debian/ubuntu, 'mkpasswd' provided by the whois package)

 

解决：

根据提示信息，安装whois： sudo apt-get install whois

 

### 2.20.2.4、编译后结果查看与分析

(1)编译后生成的文件夹格式的rootfs在buildroot/output/images/rootfs.tar。我们将其复制到了根目录下的release目录下去，这个文件就是一个完整的可以工作的文件夹形式的rootfs。

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 